{"version":3,"sources":["../node_modules/source-map/lib/base64.js","../node_modules/source-map/lib/base64-vlq.js","../node_modules/source-map/lib/util.js","../node_modules/source-map/lib/array-set.js","../node_modules/source-map/lib/mapping-list.js","../node_modules/source-map/lib/source-map-generator.js","../node_modules/source-map/lib/binary-search.js","../node_modules/source-map/lib/quick-sort.js","../node_modules/source-map/lib/source-map-consumer.js","../node_modules/source-map/lib/source-node.js","../node_modules/source-map/source-map.js","../src/common/symbol.ts","../src/type/index.ts","../src/common/node.ts","../src/common/error.ts","../src/wasm/tool/constant.ts","../src/wasm/node.ts","../src/wasm/section/wsection.ts","../src/wasm/section/wcode_section.ts","../src/wasm/section/wexport_section.ts","../src/wasm/section/wimport_item.ts","../src/wasm/section/wimport_memory.ts","../src/wasm/section/wfunction_type.ts","../src/wasm/section/wfunction.ts","../src/wasm/section/wimport_section.ts","../src/wasm/emitter/emitter_context.ts","../src/wasm/emitter/emitter.ts","../src/wasm/emitter/json_emitter.ts","../src/wasm/section/wdata_section.ts","../src/wasm/section/wexport_function.ts","../src/wasm/section/wmemory_section.ts","../src/wasm/section/wfunction_section.ts","../src/wasm/section/wtable.ts","../src/wasm/expression/wexpression.ts","../src/wasm/expression/wconst.ts","../src/wasm/section/wglobal_variable.ts","../src/wasm/section/welement.ts","../src/wasm/section/welement_section.ts","../src/wasm/section/wimport_function.ts","../src/wasm/section/wtype_section.ts","../src/wasm/section/wtable_section.ts","../src/wasm/section/wglobal_section.ts","../src/wasm/section/wdata_segment.ts","../node_modules/bn.js/lib/bn.js","../src/wasm/tool/leb128.ts","../src/wasm/tool/utf8.ts","../src/wasm/emitter/wasm_emitter.ts","../src/wasm/statement/wstatement.ts","../src/wasm/statement/wreturn.ts","../node_modules/long/src/long.js","../src/wasm/tool/calculator.ts","../src/wasm/expression/wbinary_operation.ts","../src/wasm/statement/wstore.ts","../src/wasm/statement/wbr.ts","../src/wasm/statement/wexpr_statement.ts","../src/wasm/statement/wblock.ts","../src/wasm/statement/wset_local.ts","../src/wasm/statement/wset_global.ts","../src/wasm/statement/wloop.ts","../src/wasm/statement/wbr_if.ts","../src/wasm/statement/wif_else_block.ts","../src/wasm/statement/wdrop.ts","../src/wasm/expression/wget_address.ts","../src/wasm/expression/wget_function_address.ts","../src/wasm/expression/wget_global.ts","../src/wasm/expression/wempty_expression.ts","../src/wasm/expression/wfake_expression.ts","../src/wasm/expression/wunary_operation.ts","../src/wasm/expression/wconditional_expression.ts","../src/wasm/expression/wget_local.ts","../src/wasm/expression/wcall_indirect.ts","../src/wasm/expression/wload.ts","../src/wasm/expression/wcall.ts","../src/wasm/expression/wcovert_operation.ts","../src/wasm/module.ts","../src/wasm/index.ts","../src/type/template_type.ts","../src/common/template.ts","../src/type/class_type.ts","../src/type/primitive_type.ts","../src/type/compound_type.ts","../src/common/utils.ts","../src/type/function_type.ts","../src/codegen/address.ts","../src/codegen/scope.ts","../src/codegen/template/template_deduce.ts","../src/codegen/template/function_template_instantiation.ts","../src/codegen/overload.ts","../src/codegen/conversion.ts","../src/codegen/expression/expression.ts","../src/codegen/expression/constant.ts","../src/codegen/expression/integer_constant.ts","../src/codegen/expression/anonymous_expression.ts","../src/codegen/function/call_expression.ts","../src/codegen/reference.ts","../src/codegen/expression/binary_expression.ts","../src/codegen/expression/assignment_expression.ts","../src/codegen/expression/subscript_expression.ts","../src/codegen/expression/unary_expression.ts","../src/codegen/class/member_expression.ts","../src/codegen/template/class_template_instantiation.ts","../src/codegen/expression/identifier.ts","../src/codegen/class/destructor.ts","../src/codegen/statement/statement.ts","../src/codegen/function/return_statement.ts","../src/codegen/function/function.ts","../src/codegen/index.ts","../src/codegen/memory.ts","../src/codegen/context.ts","../src/library/library.ts","../src/library/math.ts","../src/library/stdio.ts","../src/library/string.ts","../src/library/ctype.ts","../src/library/stdlib.ts","../src/arduino/pin.ts","../src/arduino/arduinoBoard.ts","../src/library/arduino.ts","../src/library/syscall.ts","../src/library/index.ts","../src/wasm/tool/dumper.ts","../src/linker/index.ts","../node_modules/pegjs/lib/utils/arrays.js","../node_modules/pegjs/lib/utils/objects.js","../node_modules/pegjs/lib/utils/classes.js","../node_modules/pegjs/lib/grammar-error.js","../node_modules/pegjs/lib/parser.js","../node_modules/pegjs/lib/compiler/visitor.js","../node_modules/pegjs/lib/compiler/asts.js","../node_modules/pegjs/lib/compiler/passes/report-undefined-rules.js","../node_modules/pegjs/lib/compiler/passes/report-duplicate-rules.js","../node_modules/pegjs/lib/compiler/passes/report-duplicate-labels.js","../node_modules/pegjs/lib/compiler/passes/report-infinite-recursion.js","../node_modules/pegjs/lib/compiler/passes/report-infinite-repetition.js","../node_modules/pegjs/lib/compiler/passes/remove-proxy-rules.js","../node_modules/pegjs/lib/compiler/opcodes.js","../node_modules/pegjs/lib/compiler/js.js","../node_modules/pegjs/lib/compiler/passes/generate-bytecode.js","../node_modules/pegjs/lib/compiler/passes/generate-js.js","../node_modules/pegjs/lib/compiler/index.js","../node_modules/pegjs/lib/peg.js","../src/codegen/class/type_name.ts","../src/codegen/statement/using_statement.ts","../src/codegen/declaration/declaration.ts","../src/codegen/declaration/declarator.ts","../src/codegen/declaration/function_declarator.ts","../src/codegen/function/function_definition.ts","../src/codegen/function/parameter_list.ts","../src/codegen/statement/compound_statement.ts","../src/codegen/statement/expression_statement.ts","../src/codegen/declaration/object_initializer.ts","../src/codegen/class/constructor_declaration.ts","../src/codegen/class/destructor_declaration.ts","../src/codegen/class/class_specifier.ts","../src/codegen/function/parameter_declaration.ts","../src/codegen/template/type_parameter.ts","../src/codegen/template/template_declaration.ts","../src/codegen/template/template_argument.ts","../src/codegen/statement/break_statement.ts","../src/codegen/declaration/identifier_declarator.ts","../src/codegen/declaration/initializer_list.ts","../src/codegen/declaration/init_declartor.ts","../src/codegen/class/enum_specifier.ts","../src/codegen/declaration/specifier_list.ts","../src/codegen/statement/for_statement.ts","../src/codegen/statement/case_statement.ts","../src/codegen/statement/continue_statement.ts","../src/codegen/statement/using_namespace_statements.ts","../src/codegen/statement/dowhile_statement.ts","../src/codegen/statement/switch_statement.ts","../src/codegen/statement/if_statement.ts","../src/codegen/statement/goto_statement.ts","../src/codegen/statement/labeled_statement.ts","../src/codegen/statement/while_statement.ts","../src/codegen/declaration/array_declarator.ts","../src/codegen/class/new_expression.ts","../src/codegen/class/constructor_call_expression.ts","../src/codegen/class/delete_expression.ts","../src/codegen/class/base_specifier.ts","../src/codegen/expression/floating_constant.ts","../src/codegen/expression/string_literal.ts","../src/codegen/expression/cast_expression.ts","../src/codegen/expression/conditional_expression.ts","../src/codegen/expression/character_constant.ts","../src/codegen/expression/postfix_expression.ts","../src/codegen/declaration/namepsace_block.ts","../src/codegen/declaration/pointer_declarator.ts","../src/codegen/declaration/translation_unit.ts","../src/parser/ast.ts","../src/parser/c.lang.ts","../src/parser/index.ts","../src/preprocessor/context.ts","../src/preprocessor/index.ts","../src/runtime/allocator.ts","../src/runtime/runtime.ts","../src/runtime/native_runtime.ts","../src/runtime/js_runtime.ts","../src/runtime/vmfile.ts","../src/tools/compiler.ts"],"names":["intToCharMap","split","exports","encode","number","length","TypeError","decode","charCode","base64","require","VLQ_BASE_SHIFT","VLQ_BASE","VLQ_BASE_MASK","VLQ_CONTINUATION_BIT","toVLQSigned","aValue","fromVLQSigned","shifted","digit","encoded","vlq","aStr","aIndex","aOutParam","continuation","strLen","result","shift","Error","charCodeAt","charAt","value","rest","getArg","aArgs","aName","aDefaultValue","arguments","urlRegexp","dataUrlRegexp","urlParse","aUrl","match","scheme","auth","host","port","path","urlGenerate","aParsedUrl","url","normalize","aPath","part","isAbsolute","parts","up","i","splice","join","aRoot","aPathUrl","aRootUrl","joined","replace","relative","level","indexOf","index","lastIndexOf","slice","Array","substr","supportsNullProto","Object","create","identity","s","toSetString","isProtoString","fromSetString","compareByOriginalPositions","mappingA","mappingB","onlyCompareOriginal","cmp","source","originalLine","originalColumn","generatedColumn","generatedLine","name","compareByGeneratedPositionsDeflated","onlyCompareGenerated","strcmp","aStr1","aStr2","compareByGeneratedPositionsInflated","util","has","prototype","hasOwnProperty","hasNativeMap","Map","ArraySet","_array","_set","fromArray","aArray","aAllowDuplicates","set","len","add","size","getOwnPropertyNames","sStr","isDuplicate","call","idx","push","get","at","aIdx","toArray","generatedPositionAfter","lineA","lineB","columnA","columnB","MappingList","_sorted","_last","unsortedForEach","aCallback","aThisArg","forEach","aMapping","sort","base64VLQ","SourceMapGenerator","_file","_sourceRoot","_skipValidation","_sources","_names","_mappings","_sourcesContents","_version","fromSourceMap","aSourceMapConsumer","sourceRoot","generator","file","eachMapping","mapping","newMapping","generated","line","column","original","addMapping","sources","sourceFile","content","sourceContentFor","setSourceContent","_validateMapping","String","aSourceFile","aSourceContent","keys","applySourceMap","aSourceMapPath","newSources","newNames","originalPositionFor","aGenerated","aOriginal","aSource","JSON","stringify","_serializeMappings","next","nameIdx","sourceIdx","previousGeneratedColumn","previousGeneratedLine","previousOriginalColumn","previousOriginalLine","previousName","previousSource","mappings","_generateSourcesContent","aSources","aSourceRoot","map","key","toJSON","version","names","sourcesContent","toString","recursiveSearch","aLow","aHigh","aNeedle","aHaystack","aCompare","aBias","mid","Math","floor","LEAST_UPPER_BOUND","GREATEST_LOWER_BOUND","search","swap","ary","x","y","temp","randomIntInRange","low","high","round","random","doQuickSort","comparator","p","r","pivot","j","q","quickSort","binarySearch","SourceMapConsumer","aSourceMap","sourceMap","parse","sections","IndexedSourceMapConsumer","BasicSourceMapConsumer","Mapping","lastOffset","_sections","offset","offsetLine","offsetColumn","generatedOffset","consumer","__generatedMappings","defineProperty","_parseMappings","__originalMappings","_charIsMappingSeparator","c","GENERATED_ORDER","ORIGINAL_ORDER","aContext","aOrder","context","_generatedMappings","_originalMappings","allGeneratedPositionsFor","needle","_findMapping","undefined","lastColumn","smc","generatedMappings","destGeneratedMappings","destOriginalMappings","srcMapping","destMapping","str","segment","end","cachedSegments","originalMappings","aMappings","aLineName","aColumnName","aComparator","computeColumnSpans","nextMapping","lastGeneratedColumn","Infinity","hasContentsOfAllSources","some","sc","nullOnMissing","fileUriAbsPath","generatedPositionFor","constructor","sectionIndex","section","bias","every","generatedPosition","sectionMappings","adjustedMapping","REGEX_NEWLINE","NEWLINE_CODE","isSourceNode","SourceNode","aLine","aColumn","aChunks","children","sourceContents","fromStringWithSourceMap","aGeneratedCode","aRelativePath","node","remainingLines","remainingLinesIndex","shiftNextLine","getNextLine","lastGeneratedLine","lastMapping","code","nextLine","addMappingWithCode","aChunk","isArray","chunk","prepend","unshift","walk","aFn","aSep","newChildren","replaceRight","aPattern","aReplacement","lastChild","walkSourceContents","toStringWithSourceMap","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","sourceContent","arrays","range","start","stop","find","array","valueOrPredicate","contains","each","iterator","pluck","e","predicate","module","objects","object","values","clone","defaults","classes","subclass","child","parent","ctor","GrammarError","message","location","captureStackTrace","peg$subclass","peg$SyntaxError","expected","found","peg$parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","Grammar","peg$parseGrammar","peg$startRuleFunction","peg$c0","initializer","rules","type","optional","extractList","peg$c1","peg$c2","peg$c3","peg$literalExpectation","peg$c4","displayName","expression","peg$c5","peg$c6","peg$c7","head","tail","alternatives","buildList","peg$c8","peg$c9","elements","peg$c10","peg$c11","peg$c12","label","peg$c13","operator","OPS_TO_PREFIXED_TYPES","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","OPS_TO_SUFFIXED_TYPES","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","OPS_TO_SEMANTIC_PREDICATE_TYPES","peg$c34","peg$c35","peg$otherExpectation","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$classExpectation","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c63","peg$c64","peg$c65","peg$c66","peg$c67","peg$c68","peg$c69","peg$c70","peg$c71","peg$c72","peg$c73","peg$c74","peg$c75","sequence","peg$c76","peg$c77","peg$c78","peg$c79","peg$c80","peg$c81","peg$c82","peg$c83","ignoreCase","peg$c84","peg$c85","peg$c86","peg$c87","chars","peg$c88","peg$c89","peg$c90","text","peg$c91","peg$c92","peg$c93","peg$c94","peg$c95","peg$c96","peg$c97","peg$c98","inverted","filterEmptyStrings","peg$c99","peg$c100","peg$c101","begin","peg$computeLocation","peg$savedPos","peg$currPos","peg$buildSimpleError","error","peg$c102","peg$c103","peg$c104","peg$c105","peg$c106","peg$c107","peg$c108","peg$c109","peg$c110","peg$c111","peg$c112","peg$c113","peg$c114","peg$c115","peg$c116","peg$c117","peg$c118","peg$c119","peg$c120","peg$c121","peg$c122","peg$c123","peg$c124","peg$c125","peg$c126","peg$c127","peg$c128","digits","fromCharCode","parseInt","peg$c129","peg$c130","peg$c131","peg$c132","peg$c133","peg$c134","peg$c135","peg$c136","peg$c137","peg$c138","peg$c139","peg$c140","peg$c141","peg$c142","peg$c143","peg$c144","peg$c145","peg$c146","peg$c147","peg$c148","peg$c149","peg$c150","peg$c151","peg$c152","peg$c153","peg$c154","peg$c155","peg$c156","peg$c157","peg$c158","peg$c159","peg$c160","peg$c161","peg$c162","peg$c163","peg$c164","peg$c165","peg$c166","peg$c167","peg$c168","peg$c169","peg$c170","peg$c171","peg$c172","peg$c173","peg$c174","peg$c175","peg$c176","peg$c177","peg$c178","peg$c179","peg$c180","peg$c181","peg$c182","peg$c183","peg$c184","peg$c185","peg$c186","peg$c187","peg$c188","peg$c189","peg$c190","peg$c191","peg$c192","peg$c193","peg$c194","peg$c195","peg$c196","peg$c197","peg$c198","peg$c199","peg$c200","peg$c201","peg$c202","peg$c203","peg$c204","peg$c205","peg$c206","peg$c207","peg$c208","peg$c209","peg$c210","peg$c211","peg$c212","peg$c213","peg$c214","peg$c215","peg$c216","peg$c217","peg$c218","peg$c219","peg$c220","peg$c221","peg$c222","peg$c223","peg$c224","peg$c225","peg$c226","peg$c227","peg$c228","peg$c229","peg$c230","peg$c231","peg$c232","peg$c233","peg$c234","peg$c235","peg$c236","peg$c237","peg$c238","peg$c239","peg$posDetailsCache","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","substring","description","peg$computePosDetails","pos","details","startPos","endPos","startPosDetails","endPosDetails","peg$fail","peg$buildStructuredError","buildMessage","s0","s2","s3","s4","s5","s6","peg$parse__","s1","peg$parseCodeBlock","peg$parseEOS","peg$parseInitializer","peg$parseRule","peg$parseIdentifierName","peg$parseStringLiteral","peg$parseChoiceExpression","s7","peg$parseActionExpression","peg$parseLabeledExpression","peg$parseSequenceExpression","peg$parseIdentifierPart","peg$parseBreakToken","peg$parseCaseToken","peg$parseCatchToken","peg$parseContinueToken","peg$parseDebuggerToken","peg$parseDefaultToken","peg$parseDeleteToken","peg$parseDoToken","peg$parseElseToken","peg$parseFinallyToken","peg$parseForToken","peg$parseFunctionToken","peg$parseIfToken","peg$parseInstanceofToken","peg$parseInToken","peg$parseNewToken","peg$parseReturnToken","peg$parseSwitchToken","peg$parseThisToken","peg$parseThrowToken","peg$parseTryToken","peg$parseTypeofToken","peg$parseVarToken","peg$parseVoidToken","peg$parseWhileToken","peg$parseWithToken","peg$parseKeyword","peg$parseClassToken","peg$parseConstToken","peg$parseEnumToken","peg$parseExportToken","peg$parseExtendsToken","peg$parseImportToken","peg$parseSuperToken","peg$parseFutureReservedWord","peg$parseNullToken","peg$parseTrueToken","peg$parseFalseToken","peg$parseBooleanLiteral","peg$parseReservedWord","peg$parseIdentifier","peg$parsePrefixedExpression","peg$parsePrefixedOperator","peg$parseSuffixedExpression","peg$parsePrimaryExpression","peg$parseSuffixedOperator","peg$parseLiteralMatcher","peg$parseClassCharacterRange","peg$parseClassCharacter","peg$parseCharacterClassMatcher","peg$parseAnyMatcher","peg$parseRuleReferenceExpression","peg$parseSemanticPredicateOperator","peg$parseSemanticPredicateExpression","peg$parseSourceCharacter","peg$parseWhiteSpace","test","peg$parseZs","peg$parseLineTerminator","peg$parseLineTerminatorSequence","peg$parseComment","peg$parseMultiLineComment","peg$parseSingleLineComment","peg$parseMultiLineCommentNoLineTerminator","peg$parseIdentifierStart","peg$parseLu","peg$parseLl","peg$parseLt","peg$parseLm","peg$parseLo","peg$parseNl","peg$parseUnicodeLetter","peg$parseUnicodeEscapeSequence","peg$parseMn","peg$parseMc","peg$parseUnicodeCombiningMark","peg$parseNd","peg$parsePc","peg$parseDoubleStringCharacter","peg$parseSingleStringCharacter","peg$parseEscapeSequence","peg$parseLineContinuation","peg$parseSingleEscapeCharacter","peg$parseDecimalDigit","peg$parseEscapeCharacter","peg$parseNonEscapeCharacter","peg$parseCharacterEscapeSequence","peg$parseHexDigit","peg$parseHexEscapeSequence","peg$parseCode","peg$parse_","peg$parseEOF","list","concat","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","escapedParts","classEscape","any","other","hex","ch","toUpperCase","descriptions","describeExpected","describeFound","SyntaxError","visitor","build","functions","visit","apply","visitNop","visitExpression","extraArgs","visitChildren","property","DEFAULT_FUNCTIONS","grammar","rule","named","choice","action","labeled","simple_and","simple_not","zero_or_more","one_or_more","group","semantic_and","semantic_not","rule_ref","asts","findRule","ast","indexOfRule","alwaysConsumesOnSuccess","consumesTrue","consumesFalse","consumesExpression","consumes","reportUndefinedRules","check","reportDuplicateRules","reportDuplicateLabels","checkExpressionWithClonedEnv","env","alternative","reportInfiniteRecursion","visitedRules","pop","element","reportInfiniteRepetition","removeProxyRules","indices","from","to","replaceRuleRefs","allowedStartRules","reverse","opcodes","PUSH","PUSH_UNDEFINED","PUSH_NULL","PUSH_FAILED","PUSH_EMPTY_ARRAY","PUSH_CURR_POS","POP","POP_CURR_POS","POP_N","NIP","APPEND","WRAP","TEXT","IF","IF_ERROR","IF_NOT_ERROR","WHILE_NOT_ERROR","MATCH_ANY","MATCH_STRING","MATCH_STRING_IC","MATCH_REGEXP","ACCEPT_N","ACCEPT_STRING","FAIL","LOAD_SAVED_POS","UPDATE_SAVED_POS","CALL","RULE","SILENT_FAILS_ON","SILENT_FAILS_OFF","js","stringEscape","regexpClassEscape","op","generateBytecode","consts","addConst","addFunctionConst","params","buildSequence","buildCondition","condCode","thenCode","elseCode","buildCall","functionIndex","delta","sp","buildSimplePredicate","negative","generate","buildSemanticPredicate","buildAppendLoop","expressionCode","bodyCode","bytecode","nameIndex","buildAlternativesCode","emitCall","buildElementsCode","processedCount","stringIndex","expectedIndex","toLowerCase","regexp","regexpIndex","generateJS","indent2","indent6","indent10","generateTables","optimize","b","generateRuleHeader","ruleNameCode","ruleIndexCode","trace","cache","generateRuleFooter","resultCode","generateInterpreter","cond","generateCondition","argsLength","baseLength","thenLengthCode","elseLengthCode","generateRuleFunction","stack","maxSp","exprCode","n","top","compile","bc","ip","compileCondition","argCount","thenSp","elseSp","thenLength","elseLength","baseSp","compileLoop","bodySp","bodyLength","compileCall","paramsLength","eval","generateToplevel","startRuleIndices","startRuleIndex","startRuleFunctions","startRuleFunction","ruleNames","generateWrapper","toplevelCode","generateGeneratedByComment","generateParserObject","bare","commonjs","dependencyVars","dependencies","requires","variable","amd","dependencyIds","id","globals","exportVar","umd","format","compiler","passes","transform","stage","output","peg","VERSION","parser","plugins","config","converted","convertPasses","use"],"mappings":"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KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,CAAC,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AAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,OAAY,GAAO,GACzlLoH,GAAW,uFACXC,GAAWrH,GAAqB,CAAC,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,MAAW,GAAO,GACjLsH,GAAW,s1HACXC,GAAWvH,GAAqB,CAAC,CAAC,IAAK,KAAM,CAAC,IAAQ,KAAS,CAAC,IAAQ,KAAS,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAAU,IAA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C,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,IAAU,CAAC,IAAU,KAAW,IAAU,IAAU,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAAU,KAAW,CAAC,IAA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,IAAM3C,GAAGC,aAAazE,KAAKttB,MAAQ,IACnCmuB,KAAKG,YAAYD,IAAKf,KAAKttB,SAE7BpC,MAAMgE,KAAKuyB,QAAQ/lB,OACnBxQ,MAAMgE,KAAKuyB,QAAQW,mBACjB,IAAMhD,GAAGC,aAAazE,KAAKttB,MAAQ,IACnCd,EAAE,MAGJtB,MAAMgE,KAAK,KAEJhE,MAAMI,KAAK,MAGpB,SAAS64B,mBACP,IACIC,EAAoBC,EACpBC,EAAoBC,EACpBC,EAHAt5B,EAAQ,GA+cZ,OA1cAA,EAAMgE,KAAK,CACT,yCACA,kDACA,uCACA,kCACA,IACA,GACA,iEACA,6BACA,8BACA,2BACA,8BACA,mCACA,GACA,yDACA,sDACA,MACA,IACA,GACA,wCACA,GACA,6DACA,qCACA,2CACA,oEACA,aACA,GACA,2CACA,mCACA,mBACA,GACA,6DACA,oEACA,oGACA,qDACA,cACA,GACA,iFACA,aACA,GACA,uCACA,oCACA,aACA,GACA,uCACA,mCACA,aACA,GACA,yCACA,4CACA,YACA,WACA,GACA,uBACA,0DACA,MACA,GACA,gCACA,eACA,sCACA,mCACA,kCACA,kCACA,kCACA,kCACA,yFACA,4FACA,MACA,GACA,8BACA,eACA,sCACA,kCACA,kCACA,iCACA,kCACA,kCACA,kCACA,kCACA,yFACA,4FACA,MACA,GACA,gDACA,sEACA,MACA,GACA,0CACA,qDACA,gBACA,GACA,8CACA,4DACA,QACA,GACA,2BACA,GACA,qCACA,2DACA,yDACA,+CACA,iBACA,YACA,UACA,iCACA,QACA,GACA,qCACA,gBACA,kCACA,GACA,gBACA,6DACA,GACA,iBACA,sDACA,sBACA,qDACA,QACA,MACA,GACA,oCACA,4EACA,MACA,GACA,kGACA,KACA,IACA5D,KAAK,OAEH8T,QAAQ8iB,OACVh3B,EAAMgE,KAAK,CACT,iCACA,0BACA,IACA,GACA,wDACA,qBACA,GACA,0BACA,mCACA,6BACA,GACA,mCACA,6BACA,WACA,GACA,wBACA,QACA,GACA,qCACA,6DACA,QACA,GACA,yCACA,qBACA,8EACA,8EACA,wCACA,0DACA,WACA,QACA,MACA,GACA,0BACA,yBACA,oBACA,4BACA,eACA,GACA,yBACA,4BACA,oBACA,eACA,GACA,wBACA,4BACA,oBACA,eACA,GACA,eACA,oEACA,MACA,KACA,IACA5D,KAAK,OAGTJ,EAAMgE,KAAK,CACT,uCACA,iDACA,GACA,yBACA,IACA5D,KAAK,OAEkB,SAArB8T,QAAQyiB,UACVuC,EAAmB,KACAlnB,OAAOpJ,IACLsL,QAAQ+d,kBACR,SAASpnB,GAAK,OAAOA,EAAI,KAAO0lB,KAAKG,YAAYD,IAAK5lB,KACtDzK,KAAK,MACP,KACnB+4B,EAAiB5I,KAAKG,YAAYD,IAAKvc,QAAQ+d,kBAAkB,IAEjEjyB,EAAMgE,KAAK,CACT,gCAAkCk1B,EAAmB,IACrD,gCAAkCC,EAAiB,KACnD/4B,KAAK,SAEPg5B,EAAqB,KACFpnB,OAAOpJ,IACLsL,QAAQ+d,kBACR,SAASpnB,GAAK,OAAOA,EAAI,cAAgBA,IACzCzK,KAAK,MACP,KACnBi5B,EAAoB,YAAcnlB,QAAQ+d,kBAAkB,GAE5DjyB,EAAMgE,KAAK,CACT,kCAAoCo1B,EAAqB,IACzD,kCAAoCC,EAAoB,KACxDj5B,KAAK,QAGTJ,EAAMgE,KAAK,IAEXhE,EAAMgE,KAAKwyB,QAAQE,mBAEnB12B,EAAMgE,KAAK,CACT,GACA,kCACA,kCACA,yDACA,kCACA,mCACA,kCACA,IACA5D,KAAK,OAEH8T,QAAQ+iB,OACVj3B,EAAMgE,KAAK,CACT,+BACA,IACA5D,KAAK,OAGL8T,QAAQ8iB,QACe,SAArB9iB,QAAQyiB,WACV2C,EAAY,IACAtnB,OAAOpJ,IACL6nB,IAAI9b,MACJ,SAAS9J,GAAK,MAAO,IAAMqpB,GAAGC,aAAatpB,EAAEzI,MAAQ,MACrDhC,KAAK,MACP,IAEZJ,EAAMgE,KAAK,CACT,yBAA2Bs1B,EAAY,IACvC,IACAl5B,KAAK,QAGTJ,EAAMgE,KAAK,CACT,qFACA,IACA5D,KAAK,QAGTJ,EAAMgE,KAAK,CACT,oBACA,IACA5D,KAAK,OAEkB,SAArB8T,QAAQyiB,SACV32B,EAAMgE,KAAK,CACT,kCACA,0DACA,4FACA,QACA,GACA,oEACA,OACA5D,KAAK,OAEPJ,EAAMgE,KAAK,CACT,kCACA,4DACA,4FACA,QACA,GACA,yEACA,OACA5D,KAAK,OAGTJ,EAAMgE,KAAK,CACT,GACA,sBACA,yDACA,MACA,GACA,0BACA,6DACA,MACA,GACA,+CACA,iGACA,GACA,sCACA,6CACA,oDACA,iBACA,SACA,MACA,GACA,wCACA,iGACA,GACA,qDACA,MACA,GACA,wDACA,sEACA,MACA,GACA,iEACA,0FACA,MACA,GACA,oCACA,8BACA,MACA,GACA,oCACA,8BACA,MACA,GACA,iDACA,0DACA,MACA,GACA,0CACA,iDACA,GACA,qBACA,wBACA,eACA,qBACA,0CACA,eACA,UACA,GACA,0CACA,oBACA,gCACA,iCACA,WACA,GACA,0BACA,4CACA,4BACA,gCACA,mBACA,8BACA,YACA,GACA,eACA,UACA,GACA,4CACA,wBACA,QACA,MACA,GACA,qDACA,6DACA,2DACA,GACA,eACA,iBACA,4BACA,wCACA,yCACA,WACA,eACA,0BACA,sCACA,uCACA,UACA,SACA,MACA,GACA,kCACA,oDACA,GACA,0CACA,sCACA,kCACA,QACA,GACA,0CACA,MACA,GACA,uDACA,iEACA,MACA,GACA,mEACA,kCACA,uDACA,kBACA,eACA,iBACA,SACA,MACA,IACA5D,KAAK,OAEkB,SAArB8T,QAAQyiB,UACV32B,EAAMgE,KAAKuyB,QAAQa,wBACnBp3B,EAAMgE,KAAK,KAEXgO,OAAOQ,KAAKie,IAAI9b,MAAO,SAAS+a,GAC9B1vB,EAAMgE,KAAKuyB,QAAQoB,qBAAqBjI,KACxC1vB,EAAMgE,KAAK,MAIXysB,IAAI/b,cACN1U,EAAMgE,KAAKuyB,QAAQ9F,IAAI/b,YAAYlE,OACnCxQ,EAAMgE,KAAK,KAGY,SAArBkQ,QAAQyiB,SACV32B,EAAMgE,KAAK,qDAEXhE,EAAMgE,KAAK,2CAGbhE,EAAMgE,KAAK,CACT,GACA,qEACA,yBACA,aA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","file":"compiler.074b1ff2.js","sourceRoot":"..","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap)\n    : new BasicSourceMapConsumer(sourceMap);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      if (source != null && sourceRoot != null) {\n        source = util.join(sourceRoot, source);\n      }\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: Optional. the column number in the original source.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n    if (!this._sources.has(needle.source)) {\n      return [];\n    }\n    needle.source = this._sources.indexOf(needle.source);\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The only parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._sources.toArray().map(function (s) {\n      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n    }, this);\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          if (this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    if (this.sourceRoot != null) {\n      aSource = util.relative(this.sourceRoot, aSource);\n    }\n\n    if (this._sources.has(aSource)) {\n      return this.sourcesContent[this._sources.indexOf(aSource)];\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + aSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    if (this.sourceRoot != null) {\n      source = util.relative(this.sourceRoot, source);\n    }\n    if (!this._sources.has(source)) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n    source = this._sources.indexOf(source);\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The only parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        if (section.consumer.sourceRoot !== null) {\n          source = util.join(section.consumer.sourceRoot, source);\n        }\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = section.consumer._names.at(mapping.name);\n        this._names.add(name);\n        name = this._names.indexOf(name);\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 05/08/2018\n */\n\nimport {Scope} from \"../codegen/scope\";\nimport {AccessControl, Type} from \"../type\";\nimport {FunctionType} from \"../type/function_type\";\n\nexport abstract class Symbol {\n    public accessControl: AccessControl;\n\n    constructor(accessControl: AccessControl) {\n        this.accessControl = accessControl;\n    }\n\n    public abstract isDefine(): boolean;\n\n    public abstract getType(): Type;\n}\n\nexport abstract class OverloadSymbol extends Symbol {\n    public abstract getIndexName(): string;\n    public abstract getFullName(): string;\n}\n\nexport enum AddressType {\n    GLOBAL,\n    LOCAL,\n    LOCAL_REF,\n    STACK,\n    MEMORY_DATA,\n    MEMORY_BSS,\n    MEMORY_EXTERN,\n    RVALUE,\n    CONSTANT,\n    GLOBAL_SP,\n}\n\nexport class Variable extends Symbol {\n    public shortName: string;\n    public fullName: string;\n    public fileName: string;\n    public type: Type;\n    public addressType: AddressType;\n    public location: number | string;\n\n    constructor(shortName: string, fullName: string, fileName: string, type: Type,\n                storageType: AddressType, location: number | string, accessControl: AccessControl) {\n        super(accessControl);\n        this.shortName = shortName;\n        this.fullName = fullName;\n        this.fileName = fileName;\n        this.type = type;\n        this.addressType = storageType;\n        this.location = location;\n    }\n\n    public toString() {\n        return `${this.shortName}:${this.type.toString()}`;\n    }\n\n    public isDefine() {\n        return this.addressType !== AddressType.MEMORY_EXTERN;\n    }\n\n    public getType() {\n        return this.type;\n    }\n}\n\nexport class FunctionEntity extends OverloadSymbol {\n    public shortName: string;\n    public fullName: string;\n    public fileName: string;\n    public type: FunctionType;\n\n    public isLibCall: boolean;\n    public hasDefine: boolean;\n    public parametersSize: number;\n    public $sp: number; // the 'local $sp' number\n\n    public parameterInits: Array<null | string>;\n    public declareActiveScopes: Scope[];\n\n    constructor(shortName: string, fullName: string, fileName: string,\n                type: FunctionType, parameterInits: Array<null | string>,\n                isLibCall: boolean, isDefine: boolean, accessControl: AccessControl,\n                declareActiveScopes: Scope[]) {\n        super(accessControl);\n        this.shortName = shortName;\n        this.fullName = fullName;\n        this.fileName = fileName;\n        this.type = type;\n        this.isLibCall = isLibCall;\n        this.hasDefine = isDefine;\n        this.parameterInits = parameterInits;\n        this.$sp = 0;\n        this.parametersSize = type.parameterTypes\n            .map((x) => x.length)\n            .reduce((x, y) => x + y, 0);\n        this.declareActiveScopes = declareActiveScopes;\n    }\n\n    public isDefine(): boolean {\n        return this.hasDefine;\n    }\n\n    public getType() {\n        return this.type;\n    }\n\n    public getIndexName(): string {\n        return this.shortName.split(\"@\")[0];\n    }\n\n    public getFullName(): string {\n        return this.fullName;\n    }\n}\n","import {Symbol} from \"../common/symbol\";\nimport {WType} from \"../wasm\";\n\nexport abstract class Type extends Symbol {\n\n    constructor() {\n        super(AccessControl.Public);\n    }\n\n    public equals(type: Type) {\n        return this.constructor === type.constructor;\n    }\n\n    public compatWith(type: Type) {\n        return this.constructor === type.constructor;\n    }\n\n    public abstract toWType(): WType;\n\n    public abstract toString(): string;\n\n    public abstract get length(): number;\n\n    public abstract toMangledName(): string;\n\n    public isDefine() {\n        return false;\n    }\n\n    public getType(): Type {\n        return this;\n    }\n}\n\nexport enum AccessControl {\n    Public,\n    Private,\n    Protected,\n    Unknown,\n}\n\nexport function getAccessControlFromString(str: string) {\n    if ( str === \"public\" ) {\n        return AccessControl.Public;\n    } else if ( str === \"protected\") {\n        return AccessControl.Protected;\n    } else {\n        return AccessControl.Private;\n    }\n}\n","import {CompileContext} from \"../codegen/context\";\nimport {ClassType} from \"../type/class_type\";\n\nexport class Position {\n    public offset: number;\n    public line: number;\n    public column: number;\n\n    constructor(offset: number, line: number, column: number) {\n        this.offset = offset;\n        this.line = line;\n        this.column = column;\n    }\n\n    public toString() {\n        return `(${this.line}:${this.column})`;\n    }\n}\n\nexport class SourceLocation {\n    public fileName: string;\n    public source: string;\n    public start: Position;\n    public end: Position;\n\n    constructor(fileName: string, source: string, start: Position, end: Position) {\n        this.fileName = fileName;\n        this.source = source;\n        this.start = start;\n        this.end = end;\n    }\n\n    public toString() {\n        return `${this.start.line}(${this.start.column}) - ${this.end.line}(${this.end.column})`;\n    }\n}\n\nexport const EmptyLocation = new SourceLocation(\"\", \"\",\n    new Position(1, -1, 1),\n    new Position(1, -1, 1),\n);\n\nexport abstract class Node {\n\n    public static getEmptyLocation() {\n        return EmptyLocation;\n    }\n    public location: SourceLocation;\n\n    protected constructor(location: SourceLocation) {\n        this.location = location;\n    }\n\n}\n\nexport abstract class Directive extends Node {\n\n    constructor(location: SourceLocation) {\n        super(location);\n    }\n    public abstract codegen(ctx: CompileContext): void;\n}\n\nexport abstract class ClassDirective extends Directive {\n\n    constructor(location: SourceLocation) {\n        super(location);\n    }\n\n    public abstract declare(ctx: CompileContext, classType: ClassType): void;\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 16/06/2018\n */\n\nimport {Node, Position, SourceLocation} from \"./node\";\n\nexport class FatalError extends Error {\n}\n\nexport class InternalError extends Error {\n}\n\nexport class LinkerError extends Error {\n}\n\nexport class RuntimeError extends Error {\n}\n\nexport class EmitError extends Error {\n}\n\nexport class CompilerError extends Error {\n    public name: string;\n    public node: Node;\n    public location: SourceLocation;\n    public errorLine: string;\n    constructor(message: string, node: Node) {\n        super(message);\n        this.name = this.constructor.name;\n        this.node = node;\n        if ( node ) {\n            this.location = node.location;\n        }  else {\n            this.location = new SourceLocation(\n                \"\", \"\",\n                new Position(0, 0, 0),\n                new Position(0, 0, 0),\n            );\n        }\n        this.errorLine = \"\";\n    }\n\n    public toString() {\n        return `${this.name}: ${this.message} at ${this.location.start.line}:${this.location.start.column}`;\n    }\n}\n\nexport class TypeError extends CompilerError {\n}\n\nexport class SyntaxError extends CompilerError {\n}\n\nexport class LanguageError extends CompilerError {\n}\n\nexport class PreprocessingError extends CompilerError {\n}\n\nexport class PreprocessError extends Error {\n}\n\nexport function assertType<T extends Node>(object: Node | Node[], type: { new(...args: any[]): T }) {\n    if (object instanceof Array) {\n        if (object.length === 0) {\n            throw new FatalError(`the node expect to be ${type.prototype.constructor.name}`\n                + `, but actual is a empty array.`);\n        } else {\n            throw new SyntaxError(`the node expect to be ${type.prototype.constructor.name}`\n                + `, but actual is a array of ${object[0].constructor.name}.`, object[0]);\n        }\n    }\n    if (!(object instanceof type)) {\n        throw new SyntaxError(`the node expect to be ${type.prototype.constructor.name}`\n            + `, but actual is ${object.constructor.name}.`\n            , object);\n    }\n}\n","export const OpCodes = new Map<number, string>([\n    [0x0, \"unreachable\"],\n    [0x1, \"nop\"],\n    [0x2, \"block\"],\n    [0x3, \"loop\"],\n    [0x4, \"if\"],\n    [0x5, \"else\"],\n    [0xb, \"end\"],\n    [0xc, \"br\"],\n    [0xd, \"br_if\"],\n    [0xe, \"br_table\"],\n    [0xf, \"return\"],\n    [0x10, \"call\"],\n    [0x11, \"call_indirect\"],\n    [0x1a, \"drop\"],\n    [0x1b, \"select\"],\n    [0x20, \"get_local\"],\n    [0x21, \"set_local\"],\n    [0x22, \"tee_local\"],\n    [0x23, \"get_global\"],\n    [0x24, \"set_global\"],\n    [0x28, \"i32.load\"],\n    [0x29, \"i64.load\"],\n    [0x2a, \"f32.load\"],\n    [0x2b, \"f64.load\"],\n    [0x2c, \"i32.load8_s\"],\n    [0x2d, \"i32.load8_u\"],\n    [0x2e, \"i32.load16_s\"],\n    [0x2f, \"i32.load16_u\"],\n    [0x30, \"i64.load8_s\"],\n    [0x31, \"i64.load8_u\"],\n    [0x32, \"i64.load16_s\"],\n    [0x33, \"i64.load16_u\"],\n    [0x34, \"i64.load32_s\"],\n    [0x35, \"i64.load32_u\"],\n    [0x36, \"i32.store\"],\n    [0x37, \"i64.store\"],\n    [0x38, \"f32.store\"],\n    [0x39, \"f64.store\"],\n    [0x3a, \"i32.store8\"],\n    [0x3b, \"i32.store16\"],\n    [0x3c, \"i64.store8\"],\n    [0x3d, \"i64.store16\"],\n    [0x3e, \"i64.store32\"],\n    [0x3f, \"current_memory\"],\n    [0x40, \"grow_memory\"],\n    [0x41, \"i32.const\"],\n    [0x42, \"i64.const\"],\n    [0x43, \"f32.const\"],\n    [0x44, \"f64.const\"],\n    [0x45, \"i32.eqz\"],\n    [0x46, \"i32.eq\"],\n    [0x47, \"i32.ne\"],\n    [0x48, \"i32.lt_s\"],\n    [0x49, \"i32.lt_u\"],\n    [0x4a, \"i32.gt_s\"],\n    [0x4b, \"i32.gt_u\"],\n    [0x4c, \"i32.le_s\"],\n    [0x4d, \"i32.le_u\"],\n    [0x4e, \"i32.ge_s\"],\n    [0x4f, \"i32.ge_u\"],\n    [0x50, \"i64.eqz\"],\n    [0x51, \"i64.eq\"],\n    [0x52, \"i64.ne\"],\n    [0x53, \"i64.lt_s\"],\n    [0x54, \"i64.lt_u\"],\n    [0x55, \"i64.gt_s\"],\n    [0x56, \"i64.gt_u\"],\n    [0x57, \"i64.le_s\"],\n    [0x58, \"i64.le_u\"],\n    [0x59, \"i64.ge_s\"],\n    [0x5a, \"i64.ge_u\"],\n    [0x5b, \"f32.eq\"],\n    [0x5c, \"f32.ne\"],\n    [0x5d, \"f32.lt\"],\n    [0x5e, \"f32.gt\"],\n    [0x5f, \"f32.le\"],\n    [0x60, \"f32.ge\"],\n    [0x61, \"f64.eq\"],\n    [0x62, \"f64.ne\"],\n    [0x63, \"f64.lt\"],\n    [0x64, \"f64.gt\"],\n    [0x65, \"f64.le\"],\n    [0x66, \"f64.ge\"],\n    [0x67, \"i32.clz\"],\n    [0x68, \"i32.ctz\"],\n    [0x69, \"i32.popcnt\"],\n    [0x6a, \"i32.add\"],\n    [0x6b, \"i32.sub\"],\n    [0x6c, \"i32.mul\"],\n    [0x6d, \"i32.div_s\"],\n    [0x6e, \"i32.div_u\"],\n    [0x6f, \"i32.rem_s\"],\n    [0x70, \"i32.rem_u\"],\n    [0x71, \"i32.and\"],\n    [0x72, \"i32.or\"],\n    [0x73, \"i32.xor\"],\n    [0x74, \"i32.shl\"],\n    [0x75, \"i32.shr_s\"],\n    [0x76, \"i32.shr_u\"],\n    [0x77, \"i32.rotl\"],\n    [0x78, \"i32.rotr\"],\n    [0x79, \"i64.clz\"],\n    [0x7a, \"i64.ctz\"],\n    [0x7b, \"i64.popcnt\"],\n    [0x7c, \"i64.add\"],\n    [0x7d, \"i64.sub\"],\n    [0x7e, \"i64.mul\"],\n    [0x7f, \"i64.div_s\"],\n    [0x80, \"i64.div_u\"],\n    [0x81, \"i64.rem_s\"],\n    [0x82, \"i64.rem_u\"],\n    [0x83, \"i64.and\"],\n    [0x84, \"i64.or\"],\n    [0x85, \"i64.xor\"],\n    [0x86, \"i64.shl\"],\n    [0x87, \"i64.shr_s\"],\n    [0x88, \"i64.shr_u\"],\n    [0x89, \"i64.rotl\"],\n    [0x8a, \"i64.rotr\"],\n    [0x8b, \"f32.abs\"],\n    [0x8c, \"f32.neg\"],\n    [0x8d, \"f32.ceil\"],\n    [0x8e, \"f32.floor\"],\n    [0x8f, \"f32.trunc\"],\n    [0x90, \"f32.nearest\"],\n    [0x91, \"f32.sqrt\"],\n    [0x92, \"f32.add\"],\n    [0x93, \"f32.sub\"],\n    [0x94, \"f32.mul\"],\n    [0x95, \"f32.div\"],\n    [0x96, \"f32.min\"],\n    [0x97, \"f32.max\"],\n    [0x98, \"f32.copysign\"],\n    [0x99, \"f64.abs\"],\n    [0x9a, \"f64.neg\"],\n    [0x9b, \"f64.ceil\"],\n    [0x9c, \"f64.floor\"],\n    [0x9d, \"f64.trunc\"],\n    [0x9e, \"f64.nearest\"],\n    [0x9f, \"f64.sqrt\"],\n    [0xa0, \"f64.add\"],\n    [0xa1, \"f64.sub\"],\n    [0xa2, \"f64.mul\"],\n    [0xa3, \"f64.div\"],\n    [0xa4, \"f64.min\"],\n    [0xa5, \"f64.max\"],\n    [0xa6, \"f64.copysign\"],\n    [0xa7, \"i32.wrap_i64\"],\n    [0xa8, \"i32.trunc_s_f32\"],\n    [0xa9, \"i32.trunc_u_f32\"],\n    [0xaa, \"i32.trunc_s_f64\"],\n    [0xab, \"i32.trunc_u_f64\"],\n    [0xac, \"i64.extend_s_i32\"],\n    [0xad, \"i64.extend_u_i32\"],\n    [0xae, \"i64.trunc_s_f32\"],\n    [0xaf, \"i64.trunc_u_f32\"],\n    [0xb0, \"i64.trunc_s_f64\"],\n    [0xb1, \"i64.trunc_u_f64\"],\n    [0xb2, \"f32.convert_s_i32\"],\n    [0xb3, \"f32.convert_u_i32\"],\n    [0xb4, \"f32.convert_s_i64\"],\n    [0xb5, \"f32.convert_u_i64\"],\n    [0xb6, \"f32.demote_f64\"],\n    [0xb7, \"f64.convert_s_i32\"],\n    [0xb8, \"f64.convert_u_i32\"],\n    [0xb9, \"f64.convert_s_i64\"],\n    [0xba, \"f64.convert_u_i64\"],\n    [0xbb, \"f64.promote_f32\"],\n    [0xbc, \"i32.reinterpret_f32\"],\n    [0xbd, \"i64.reinterpret_f64\"],\n    [0xbe, \"f32.reinterpret_i32\"],\n    [0xbf, \"f64.reinterpret_i64\"],\n]);\n\nexport enum Control {\n    unreachable = 0x0,\n    nop = 0x1,\n    block = 0x2,\n    loop = 0x3,\n    if = 0x4,\n    else = 0x5,\n    end = 0xb,\n    br = 0xc,\n    br_if = 0xd,\n    br_table = 0xe,\n    return = 0xf,\n    call = 0x10,\n    call_indirect = 0x11,\n    drop = 0x1a,\n    select = 0x1b,\n    get_local = 0x20,\n    set_local = 0x21,\n    tee_local = 0x22,\n    get_global = 0x23,\n    set_global = 0x24,\n    current_memory = 0x3f,\n    grow_memory = 0x40,\n}\n\nexport enum U32 {\n    load = 0x28,\n    load8_s = 0x2c,\n    load8_u = 0x2d,\n    load16_s = 0x2e,\n    load16_u = 0x2f,\n    store = 0x36,\n    store8 = 0x3a,\n    store16 = 0x3b,\n}\n\nexport enum U64 {\n    load = 0x29,\n    load8_s = 0x30,\n    load8_u = 0x31,\n    load16_s = 0x32,\n    load16_u = 0x33,\n    load32_s = 0x34,\n    load32_u = 0x35,\n    store = 0x37,\n    store8 = 0x3c,\n    store16 = 0x3d,\n    store32 = 0x3e,\n}\n\nexport enum F32 {\n    load = 0x2a,\n    store = 0x38,\n    const = 0x43,\n}\n\nexport enum F64 {\n    load = 0x2b,\n    store = 0x39,\n    const = 0x44,\n}\n\nexport enum I32 {\n    const = 0x41,\n    load = 0x28,\n    load8_s = 0x2c,\n    load8_u = 0x2d,\n    load16_s = 0x2e,\n    load16_u = 0x2f,\n    store = 0x36,\n    store8 = 0x3a,\n    store16 = 0x3b,\n}\n\nexport enum I64 {\n    const = 0x42,\n    load = 0x29,\n    load8_s = 0x30,\n    load8_u = 0x31,\n    load16_s = 0x32,\n    load16_u = 0x33,\n    load32_s = 0x34,\n    load32_u = 0x35,\n    store = 0x37,\n    store8 = 0x3c,\n    store16 = 0x3d,\n    store32 = 0x3e,\n}\n\nexport enum I32Binary {\n    eq = 0x46,\n    ne = 0x47,\n    lt_s = 0x48,\n    lt_u = 0x49,\n    gt_s = 0x4a,\n    gt_u = 0x4b,\n    le_s = 0x4c,\n    le_u = 0x4d,\n    ge_s = 0x4e,\n    ge_u = 0x4f,\n    add = 0x6a,\n    sub = 0x6b,\n    mul = 0x6c,\n    div_s = 0x6d,\n    div_u = 0x6e,\n    rem_s = 0x6f,\n    rem_u = 0x70,\n    and = 0x71,\n    or = 0x72,\n    xor = 0x73,\n    shl = 0x74,\n    shr_s = 0x75,\n    shr_u = 0x76,\n    rotl = 0x77,\n    rotr = 0x78,\n}\n\nexport enum I64Binary {\n    eq = 0x51,\n    ne = 0x52,\n    lt_s = 0x53,\n    lt_u = 0x54,\n    gt_s = 0x55,\n    gt_u = 0x56,\n    le_s = 0x57,\n    le_u = 0x58,\n    ge_s = 0x59,\n    ge_u = 0x5a,\n    add = 0x7c,\n    sub = 0x7d,\n    mul = 0x7e,\n    div_s = 0x7f,\n    div_u = 0x80,\n    rem_s = 0x81,\n    rem_u = 0x82,\n    and = 0x83,\n    or = 0x84,\n    xor = 0x85,\n    shl = 0x86,\n    shr_s = 0x87,\n    shr_u = 0x88,\n    // not impl\n    rotl = 0x89,\n    rotr = 0x8a,\n}\n\nexport enum F32Binary {\n    eq = 0x5b,\n    ne = 0x5c,\n    lt = 0x5d,\n    gt = 0x5e,\n    le = 0x5f,\n    ge = 0x60,\n    add = 0x92,\n    sub = 0x93,\n    mul = 0x94,\n    div = 0x95,\n    min = 0x96,\n    max = 0x97,\n    copysign = 0x98,\n}\n\nexport enum F64Binary {\n    eq = 0x61,\n    ne = 0x62,\n    lt = 0x63,\n    gt = 0x64,\n    le = 0x65,\n    ge = 0x66,\n    add = 0xa0,\n    sub = 0xa1,\n    mul = 0xa2,\n    div = 0xa3,\n    min = 0xa4,\n    max = 0xa5,\n    copysign = 0xa6,\n}\n\nexport enum I32Unary {\n    eqz = 0x45,\n    // not impl\n    clz = 0x67,\n    ctz = 0x68,\n    popcnt = 0x69,\n}\n\nexport enum I32Convert {\n    wrap$i64 = 0xa7,\n    trunc_s$f32 = 0xa8,\n    trunc_u$f32 = 0xa9,\n    trunc_s$f64 = 0xaa,\n    trunc_u$f64 = 0xab,\n    reinterpret$f32 = 0xbc,\n}\n\nexport enum I64Unary {\n    eqz = 0x50,\n    clz = 0x79,\n    ctz = 0x7a,\n    popcnt = 0x7b,\n}\n\nexport enum I64Convert {\n    extend_s$i32 = 0xac,\n    extend_u$i32 = 0xad,\n    trunc_s$f32 = 0xae,\n    trunc_u$f32 = 0xaf,\n    trunc_s$f64 = 0xb0,\n    trunc_u$f64 = 0xb1,\n    reinterpret$f64 = 0xbd,\n}\n\nexport enum F32Unary {\n    abs = 0x8b,\n    ceil = 0x8d,\n    trunc = 0x8f,\n    sqrt = 0x91,\n    neg = 0x8c,\n    floor = 0x8e,\n    nearest = 0x90,\n}\n\nexport enum F32Convert {\n    convert_s$i32 = 0xb2,\n    convert_u$i32 = 0xb3,\n    convert_s$i64 = 0xb4,\n    convert_u$i64 = 0xb5,\n    demote$f64 = 0xb6,\n    reinterpret$i32 = 0xbe,\n}\n\nexport enum F64Unary {\n    abs = 0x99,\n    ceil = 0x9b,\n    trunc = 0x9d,\n    sqrt = 0x9f,\n    neg = 0x9a,\n    floor = 0x9c,\n    nearest = 0x9e,\n}\n\nexport enum F64Convert {\n    convert_s$i32 = 0xb7,\n    convert_u$i32 = 0xb8,\n    convert_s$i64 = 0xb9,\n    convert_u$i64 = 0xba,\n    promote$f32 = 0xbb,\n    reinterpret$i64 = 0xbf,\n}\n\nexport enum WType {\n    i32 = 0x7F,\n    i64 = 0x7E,\n    f32 = 0x7D,\n    f64 = 0x7C,\n    u32 = 0x01,\n    u64 = 0x02,\n    i8 = 0x03,\n    u8 = 0x04,\n    i16 = 0x05,\n    u16 = 0x06,\n    none = 0x00,\n    any = 0x07,\n    str = 0x08,\n}\n\nexport enum SectionCode {\n    custom = 0x00,\n    type = 0x01,\n    import = 0x02,\n    function = 0x03,\n    table = 0x04,\n    memory = 0x05,\n    global = 0x06,\n    export = 0x07,\n    start = 0x08,\n    element = 0x09,\n    code = 0x0a,\n    data = 0x0b,\n}\n\nexport const WTypeMap = new Map<WType, any>([\n    [WType.i32, I32],\n    [WType.i64, I64],\n    [WType.u32, U32],\n    [WType.u64, U64],\n    [WType.f32, F32],\n    [WType.f64, F64],\n]);\nexport type UnaryOperator = I32Unary | F32Unary | I64Unary | F64Unary;\nexport type BinaryOperator = I32Binary | F32Binary | I64Binary | F64Binary;\nexport type ConvertOperator = I32Convert | F32Convert | I64Convert | F64Convert;\n\nfunction createMapItem(array: any, target: WType): Array<[number, WType]> {\n    return Object.keys(array)\n        .map((x) => parseInt(x))\n        .filter((x) => x)\n        .map((x) => [x, target] as [number, WType]);\n}\n\nexport const OpTypeMap = new Map<UnaryOperator | BinaryOperator, WType>([\n    ...createMapItem(I32Unary, WType.i32),\n    ...createMapItem(I64Unary, WType.i64),\n    ...createMapItem(F32Unary, WType.f32),\n    ...createMapItem(F64Unary, WType.f64),\n    ...createMapItem(I32Binary, WType.i32),\n    ...createMapItem(I64Binary, WType.i64),\n    ...createMapItem(F32Binary, WType.f32),\n    ...createMapItem(F64Binary, WType.f64),\n    ...createMapItem(I32Convert, WType.i32),\n    ...createMapItem(I64Convert, WType.i64),\n    ...createMapItem(F32Convert, WType.f32),\n    ...createMapItem(F64Convert, WType.f64),\n]);\n\nexport function getTypeConvertOpe(srcType: WType, dstType: WType): ConvertOperator | null {\n    switch (srcType) {\n        case WType.i32:\n            switch (dstType) {\n                case WType.i32: return null;\n                case WType.u32: return null;\n                case WType.i64: return I64Convert.extend_s$i32;\n                case WType.u64: return I64Convert.extend_s$i32;\n                case WType.f32: return F32Convert.convert_s$i32;\n                case WType.f64: return F64Convert.convert_s$i32;\n            }\n            return null;\n        case WType.u32:\n            switch (dstType) {\n                case WType.i32: return null;\n                case WType.u32: return null;\n                case WType.i64: return I64Convert.extend_u$i32;\n                case WType.u64: return I64Convert.extend_u$i32;\n                case WType.f32: return F32Convert.convert_u$i32;\n                case WType.f64: return F64Convert.convert_u$i32;\n            }\n            return null;\n        case WType.i64:\n            switch (dstType) {\n                case WType.i32: return I32Convert.wrap$i64;\n                case WType.u32: return I32Convert.wrap$i64;\n                case WType.i64: return null;\n                case WType.u64: return null;\n                case WType.f32: return F32Convert.convert_s$i64;\n                case WType.f64: return F64Convert.convert_s$i64;\n            }\n            return null;\n        case WType.u64:\n            switch (dstType) {\n                case WType.i32: return I32Convert.wrap$i64;\n                case WType.u32: return I32Convert.wrap$i64;\n                case WType.i64: return null;\n                case WType.u64: return null;\n                case WType.f32: return F32Convert.convert_u$i64;\n                case WType.f64: return F64Convert.convert_u$i64;\n            }\n            return null;\n        case WType.f32:\n            switch (dstType) {\n                case WType.i32: return I32Convert.trunc_s$f32;\n                case WType.u32: return I32Convert.trunc_u$f32;\n                case WType.i64: return I64Convert.trunc_s$f32;\n                case WType.u64: return I64Convert.trunc_u$f32;\n                case WType.f32: return null;\n                case WType.f64: return F64Convert.promote$f32;\n            }\n            return null;\n        case WType.f64:\n            switch (dstType) {\n                case WType.i32: return I32Convert.trunc_s$f64;\n                case WType.u32: return I32Convert.trunc_u$f64;\n                case WType.i64: return I64Convert.trunc_s$f64;\n                case WType.u64: return I64Convert.trunc_u$f64;\n                case WType.f32: return F32Convert.demote$f64;\n                case WType.f64: return null;\n            }\n            return null;\n    }\n    return null;\n}\n\nexport function getOpFromStr(op: string, type: WType): BinaryOperator| UnaryOperator | null {\n    switch (getOperationType(type)) {\n        case WType.i32:\n            switch (op) {\n                case \"+\": return I32Binary.add;\n                case \"-\": return I32Binary.sub;\n                case \"*\": return I32Binary.mul;\n                case \"/\": return I32Binary.div_s;\n                case \"%\": return I32Binary.rem_s;\n                case \"<\": return I32Binary.lt_s;\n                case \">\": return I32Binary.gt_s;\n                case \"<=\": return I32Binary.le_s;\n                case \">=\": return I32Binary.ge_s;\n                case \"==\": return I32Binary.eq;\n                case \"!=\": return I32Binary.ne;\n                case \"&\": return I32Binary.and;\n                case \"|\": return I32Binary.or;\n                case \"&&\": return I32Binary.and;\n                case \"||\": return I32Binary.or;\n                case \"^\": return I32Binary.xor;\n                case \">>\": return I32Binary.shr_s;\n                case \"<<\": return I32Binary.shr_s;\n                case \"!\": return I32Unary.eqz;\n            }\n            return null;\n        case WType.u32:\n            switch (op) {\n                case \"+\": return I32Binary.add;\n                case \"-\": return I32Binary.sub;\n                case \"*\": return I32Binary.mul;\n                case \"/\": return I32Binary.div_u;\n                case \"%\": return I32Binary.rem_u;\n                case \"<\": return I32Binary.lt_u;\n                case \">\": return I32Binary.gt_u;\n                case \"<=\": return I32Binary.le_u;\n                case \">=\": return I32Binary.ge_u;\n                case \"==\": return I32Binary.eq;\n                case \"!=\": return I32Binary.ne;\n                case \"&\": return I32Binary.and;\n                case \"|\": return I32Binary.or;\n                case \"^\": return I32Binary.xor;\n                case \">>\": return I32Binary.shr_u;\n                case \"<<\": return I32Binary.shr_u;\n                case \"!\": return I32Unary.eqz;\n            }\n            return null;\n        case WType.i64:\n            switch (op) {\n                case \"+\": return I64Binary.add;\n                case \"-\": return I64Binary.sub;\n                case \"*\": return I64Binary.mul;\n                case \"/\": return I64Binary.div_s;\n                case \"%\": return I64Binary.rem_s;\n                case \"<\": return I64Binary.lt_s;\n                case \">\": return I64Binary.gt_s;\n                case \"<=\": return I64Binary.le_s;\n                case \">=\": return I64Binary.ge_s;\n                case \"==\": return I64Binary.eq;\n                case \"!=\": return I64Binary.ne;\n                case \"&\": return I64Binary.and;\n                case \"|\": return I64Binary.or;\n                case \"^\": return I64Binary.xor;\n                case \">>\": return I64Binary.shr_s;\n                case \"<<\": return I64Binary.shr_s;\n                case \"!\": return I64Unary.eqz;\n            }\n            return null;\n        case WType.u64:\n            switch (op) {\n                case \"+\": return I64Binary.add;\n                case \"-\": return I64Binary.sub;\n                case \"*\": return I64Binary.mul;\n                case \"/\": return I64Binary.div_u;\n                case \"%\": return I64Binary.rem_u;\n                case \"<\": return I64Binary.lt_u;\n                case \">\": return I64Binary.gt_u;\n                case \"<=\": return I64Binary.le_u;\n                case \">=\": return I64Binary.ge_u;\n                case \"==\": return I64Binary.eq;\n                case \"!=\": return I64Binary.ne;\n                case \"&\": return I64Binary.and;\n                case \"|\": return I64Binary.or;\n                case \"^\": return I64Binary.xor;\n                case \">>\": return I64Binary.shr_u;\n                case \"<<\": return I64Binary.shr_u;\n            }\n            return null;\n        case WType.f32:\n            switch (op) {\n                case \"+\": return F32Binary.add;\n                case \"-\": return F32Binary.sub;\n                case \"*\": return F32Binary.mul;\n                case \"/\": return F32Binary.div;\n                case \"<\": return F32Binary.lt;\n                case \">\": return F32Binary.gt;\n                case \"<=\": return F32Binary.le;\n                case \">=\": return F32Binary.ge;\n                case \"==\": return F32Binary.eq;\n                case \"!=\": return F32Binary.ne;\n            }\n            return null;\n        case WType.f64:\n            switch (op) {\n                case \"+\": return F64Binary.add;\n                case \"-\": return F64Binary.sub;\n                case \"*\": return F64Binary.mul;\n                case \"/\": return F64Binary.div;\n                case \"<\": return F64Binary.lt;\n                case \">\": return F64Binary.gt;\n                case \"<=\": return F64Binary.le;\n                case \">=\": return F64Binary.ge;\n                case \"==\": return F64Binary.eq;\n                case \"!=\": return F64Binary.ne;\n            }\n            return null;\n    }\n    return null;\n}\n\nexport function getOperationType(type: WType): WType {\n    switch (type) {\n        case WType.u8:\n        case WType.u16:\n        case WType.u32: return WType.u32;\n        case WType.i8:\n        case WType.i16:\n        case WType.i32: return WType.i32;\n        case WType.f32: return WType.f32;\n        case WType.f64: return WType.f64;\n        case WType.i64: return WType.i64;\n        case WType.u64: return WType.u64;\n    }\n    return WType.none;\n}\n\nexport function getNativeType(type: WType): WType {\n    switch (type) {\n        case WType.u8:\n        case WType.u16:\n        case WType.u32:\n        case WType.i8:\n        case WType.i16:\n        case WType.i32: return WType.i32;\n        case WType.f32: return WType.f32;\n        case WType.f64: return WType.f64;\n        case WType.i64:\n        case WType.u64: return WType.i64;\n    }\n    return WType.none;\n}\n\nexport const WLoadIns = new Set<number>([\n    I32.load, I32.load8_s, I32.load8_u, I32.load16_s, I32.load16_u,\n    I64.load, I64.load8_s, I64.load8_u, I64.load16_s, I64.load16_u,\n    F32.load, F64.load,\n]);\nexport const WStoreIns = new Set<number>([\n    I32.store, I32.store8, I32.store16,\n    I64.store, I64.store8, I64.store32,\n    F32.store, F64.store,\n]);\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 14/07/2018\n */\nimport {SourceLocation} from \"../common/node\";\nimport {Emitter} from \"./emitter/emitter\";\n\nexport abstract class WNode {\n    public location: SourceLocation;\n\n    protected constructor(location: SourceLocation) {\n        this.location = location;\n    }\n\n    public abstract emit(e: Emitter): void;\n\n    public optimize(e: Emitter): void {\n        return;\n    }\n}\n","import {WNode} from \"../node\";\n\nexport abstract class WSection extends WNode {\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {SectionCode, WType} from \"../tool/constant\";\nimport {WFunction} from \"./wfunction\";\nimport {WSection} from \"./wsection\";\n\nexport class WCodeSection extends WSection {\n    public functions: WFunction[];\n\n    constructor(functions: WFunction[], location: SourceLocation) {\n        super(location);\n        this.functions = functions;\n    }\n\n    public emit(e: Emitter): void {\n        e.writeByte(SectionCode.code);\n        const slot = e.createLengthSlot();\n        e.emit(WType.u32, this.functions.length);\n        this.functions.map((func) => func.emit(e));\n        e.fillLengthSlot(slot);\n    }\n\n    public optimize(e: Emitter): void {\n        this.functions.map((x) => x.optimize(e));\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {SectionCode, WType} from \"../tool/constant\";\nimport {WExportFunction} from \"./wexport_function\";\nimport {WSection} from \"./wsection\";\n\nexport class WExportSection extends WSection {\n    public functions: WExportFunction[];\n\n    constructor(functions: WExportFunction[], location: SourceLocation) {\n        super(location);\n        this.functions = functions;\n    }\n\n    public emit(e: Emitter): void {\n        e.writeByte(SectionCode.export);\n        const slot = e.createLengthSlot();\n        e.emit(WType.u32, this.functions.length);\n        this.functions.map((func) => func.emit(e));\n        e.fillLengthSlot(slot);\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WNode} from \"../node\";\nimport {WType} from \"../tool/constant\";\n\nexport class WImportItem extends WNode {\n    public module: string;\n    public name: string;\n\n    constructor(module: string, name: string, location: SourceLocation) {\n        super(location);\n        this.module = module;\n        this.name = name;\n    }\n\n    public emit(e: Emitter): void {\n        e.emit(WType.str, this.module);\n        e.emit(WType.str, this.name);\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WType} from \"../tool/constant\";\nimport {WImportItem} from \"./wimport_item\";\n\nexport class WImportMemory extends WImportItem {\n    public min: number;\n    public max: number | null;\n\n    constructor(module: string, name: string, min: number, max: number | null, location: SourceLocation) {\n        super(module, name, location);\n        this.min = min;\n        this.max = max;\n    }\n\n    public emit(e: Emitter): void {\n        super.emit(e);\n        e.writeByte(0x02);\n        if (this.max === null) {\n            e.writeByte(0x00);\n            e.emit(WType.u32, this.min);\n        } else {\n            e.writeByte(0x01);\n            e.writeByte(this.min);\n            e.writeByte(this.max);\n        }\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WNode} from \"../node\";\nimport {getNativeType, WType} from \"../tool/constant\";\n\nexport class WFunctionType extends WNode {\n\n    public static n2s(x: number): string {\n        if (x === WType.i32) { return \"i\"; }\n        if (x === WType.i64) { return \"l\"; }\n        if (x === WType.f32) { return \"f\"; }\n        if (x === WType.f64) { return \"d\"; }\n        return \"v\";\n    }\n\n    public static s2n(x: string): WType {\n        if (x === \"i\") { return WType.i32; }\n        if (x === \"l\") { return WType.i64; }\n        if (x === \"f\") { return WType.f32; }\n        if (x === \"d\") { return WType.f64; }\n        return WType.none;\n    }\n\n    public static fromEncoding(encoding: string, location: SourceLocation) {\n        const result = new WFunctionType([], [], location);\n        if (encoding.charAt(0) !== \"v\") {\n            result.returnTypes.push(WFunctionType.s2n(encoding.charAt(0)));\n        }\n        for (let i = 1; i < encoding.length; i++) {\n            result.parameters.push(WFunctionType.s2n(encoding.charAt(i)));\n        }\n        return result;\n    }\n\n    public returnTypes: WType[];\n    public parameters: WType[];\n\n    constructor(returnTypes: WType[], parameters: WType[], location: SourceLocation) {\n        super(location);\n        this.returnTypes = returnTypes;\n        this.parameters = parameters;\n    }\n\n    public emit(e: Emitter): void {\n        e.writeByte(0x60);\n        e.emit(WType.u32, this.parameters.length);\n        this.parameters.map((type) => e.emit(WType.u32, getNativeType(type)));\n        e.emit(WType.u32, this.returnTypes.length);\n        this.returnTypes.map((type) => e.emit(WType.u32, getNativeType(type)));\n    }\n\n    public toString(): string {\n        return this.parameters.join(\",\") + \"#\" + this.returnTypes.join(\",\");\n    }\n\n    public toEncoding(): string {\n        let result = \"\";\n        if (this.returnTypes.length === 0) {\n            result += \"v\";\n        } else {\n            result += WFunctionType.n2s(getNativeType(this.returnTypes[0]));\n        }\n        this.parameters.map((ty) => result += WFunctionType.n2s(getNativeType(ty)));\n        return result;\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WNode} from \"../node\";\nimport {WStatement} from \"../statement/wstatement\";\nimport {Control, getNativeType, WType} from \"../tool/constant\";\nimport {WFunctionType} from \"./wfunction_type\";\n\nexport class WFunction extends WNode {\n    public name: string;\n    public type: WFunctionType;\n    public local: WType[];\n    public body: WStatement[];\n    public signatureId: number;\n    public displayName: string;\n\n    // fill in linking\n    public dataStart: number;\n    public bssStart: number;\n    public fileName: string;\n\n    constructor(name: string, displayName: string, returnType: WType[], parameters: WType[],\n                local: WType[], body: WStatement[], location: SourceLocation) {\n        super(location);\n        this.name = name;\n        this.displayName = displayName;\n        this.type = new WFunctionType(returnType, parameters, location);\n        this.local = local;\n        this.body = body;\n        this.signatureId = 0;\n\n        // fill in linking\n        this.dataStart = 0;\n        this.bssStart = 0;\n        this.fileName = \"\";\n    }\n\n    public emit(e: Emitter): void {\n        const slot = e.createLengthSlot();\n        e.emit(WType.u32, this.local.length);\n        this.local.map((x) => {\n            e.emit(WType.u32, 1);\n            e.writeByte(getNativeType(x));\n        });\n        e.enterFunction(this);\n        this.body.map((stmt) => stmt.emit(e));\n        e.submitFunction();\n        e.emitIns(Control.end, WType.none, 0, this.location);\n        e.fillLengthSlot(slot);\n    }\n\n    public optimize(e: Emitter): void {\n        this.body.map((x) => x.optimize(e));\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WNode} from \"../node\";\nimport {SectionCode, WType} from \"../tool/constant\";\nimport {WImportItem} from \"./wimport_item\";\n\nexport class WImportSection extends WNode {\n    public imports: WImportItem[];\n\n    constructor(imports: WImportItem[],\n                location: SourceLocation) {\n        super(location);\n        this.imports = imports;\n    }\n\n    public emit(e: Emitter): void {\n        e.writeByte(SectionCode.import);\n        const slot = e.createLengthSlot();\n        e.emit(WType.u32, this.imports.length);\n        this.imports.map((x) => x.emit(e));\n        e.fillLengthSlot(slot);\n    }\n}\n","import {SourceMapConsumer} from \"source-map\";\nimport {WFunctionType} from \"..\";\nimport {EmitError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {SourceMap} from \"../../common/object\";\nimport {WFunction} from \"../section/wfunction\";\nimport {WType} from \"../tool/constant\";\n\nexport interface FunctionInfo {\n    id: number;\n    type: WFunctionType;\n}\n\nexport interface GlobalInfo {\n    id: number;\n    type: WType;\n}\n\nexport class EmitterContext {\n\n    public funcTypeEncodingMap: Map<string, number>;\n    public functionMap: Map<string, FunctionInfo>;\n    public globalMap: Map<string, GlobalInfo>;\n    public functionIdNow: number;\n    public globalIdNow: number;\n    public currentFunction: WFunction | null;\n    public externMap: Map<string, number>;\n    public sourceMap: Map<string, SourceMap>;\n    public sourceMapConsumer: SourceMapConsumer | null;\n\n    constructor(externMap: Map<string, number>, sourceMap: Map<string, SourceMap>) {\n        this.functionMap = new Map<string, FunctionInfo>();\n        this.globalMap = new Map<string, GlobalInfo>();\n        this.funcTypeEncodingMap = new Map<string, number>();\n        this.functionIdNow = 0;\n        this.globalIdNow = 0;\n        this.currentFunction = null;\n        this.externMap = externMap;\n        this.sourceMap = sourceMap;\n        this.sourceMapConsumer = null;\n    }\n\n    public getStartLine(location: SourceLocation): number {\n        if (this.sourceMapConsumer && location.start.line >= 1) {\n            return this.sourceMapConsumer.originalPositionFor(location.start).line;\n        }\n        return -1;\n    }\n\n    public getEndLine(location: SourceLocation): number {\n        if (this.sourceMapConsumer && location.end.line >= 1) {\n            return this.sourceMapConsumer.originalPositionFor(location.end).line;\n        }\n        return -1;\n    }\n\n    public setSourceMap(fileName: string) {\n        if (fileName && this.sourceMap && this.sourceMap.get(fileName)) {\n            this.sourceMapConsumer = new SourceMapConsumer(this.sourceMap.get(fileName)!.sourceMap.toString());\n        } else {\n            this.sourceMapConsumer = null;\n        }\n    }\n\n    public getFuncInfo(name: string): FunctionInfo {\n        const info = this.functionMap.get(name);\n        if (!info) {\n            throw new EmitError(`undefined function ${name}`);\n        }\n        return info;\n    }\n\n    public submitFunc(name: string, type: WFunctionType): number {\n        if (this.functionMap.has(name)) {\n            throw new EmitError(`duplicated name ${name}`);\n        }\n        this.functionMap.set(name, {\n            id: this.functionIdNow,\n            type,\n        });\n        return this.functionIdNow++;\n    }\n\n    public getGlobalInfo(name: string): GlobalInfo {\n        const info = this.globalMap.get(name);\n        if (!info) {\n            throw new EmitError(`undefined name ${name}`);\n        }\n        return info;\n    }\n\n    public submitGlobal(name: string, type: WType): number {\n        if (this.globalMap.has(name)) {\n            throw new EmitError(`duplicated name ${name}`);\n        }\n        this.globalMap.set(name, {\n            id: this.globalIdNow,\n            type,\n        });\n        return this.globalIdNow++;\n    }\n\n    public setCurrentFunc(func: WFunction | null) {\n        this.currentFunction = func;\n        this.sourceMapConsumer = null;\n        if (func !== null) {\n            const sourceMap = this.sourceMap.get(func.fileName);\n            if (sourceMap) {\n                this.sourceMapConsumer = new SourceMapConsumer(sourceMap.sourceMap.toString());\n            }\n        }\n    }\n\n    public getCurrentFunc(): WFunction {\n        if (!this.currentFunction) {\n            throw new EmitError(`not in func`);\n        }\n        return this.currentFunction;\n    }\n\n    public getExternLocation(name: string): number {\n        const item = this.externMap.get(name);\n        if (!item) {\n            throw new EmitError(`unresolve symbol ${name}`);\n        }\n        return item;\n    }\n\n    public getTypeIdxFromEncoding(encoding: string): number {\n        const item = this.funcTypeEncodingMap.get(encoding);\n        if (!item) {\n            throw new EmitError(`unresolve type ${encoding}`);\n        }\n        return item;\n    }\n\n    public setTypeIdxFromEncoding(encoding: string, idx: number): void {\n        this.funcTypeEncodingMap.set(encoding, idx);\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {SourceMap} from \"../../common/object\";\nimport {WFunction} from \"../section/wfunction\";\nimport {WType} from \"../tool/constant\";\nimport {EmitterContext} from \"./emitter_context\";\n\nexport abstract class Emitter {\n\n    public ctx: EmitterContext;\n\n    constructor(externMap: Map<string, number>, sourceMap: Map<string, SourceMap>) {\n        this.ctx = new EmitterContext(externMap, sourceMap);\n    }\n\n    public abstract emit(type: WType, value: number | string): void;\n\n    public abstract emitIns(control: number, valueType: WType, value: number | string,\n                            location: SourceLocation, align?: boolean): void;\n\n    public abstract createLengthSlot(): [number, number];\n\n    public abstract fillLengthSlot(slot: [number, number]): void;\n\n    public abstract enterFunction(func: WFunction): void;\n\n    public abstract submitFunction(): void;\n\n    public abstract writeByte(byte: number): void;\n\n    public abstract writeBytes(bytes: number[]): void;\n\n}\n","import {Scope} from \"../../codegen/scope\";\nimport {SourceLocation} from \"../../common/node\";\nimport {SourceMap} from \"../../common/object\";\nimport {WFunction} from \"../section/wfunction\";\nimport {Control, getNativeType, WType} from \"../tool/constant\";\nimport {Emitter} from \"./emitter\";\n\nexport type WASMJSONInstruction = [number, number | string, number];\n\nexport interface WASMJSONFunction {\n    name: string;\n    fileName: string;\n    displayName: string;\n    locals: number[];\n    codes: WASMJSONInstruction[];\n    type: string;\n    signatureId: number;\n    lineIdx: Set<number>;\n    dataStart: number;\n    bssStart: number;\n    scope: Scope | null;\n    memoryInfo: Array<[number, number, number]>;\n    sourceRange: [number, number];\n}\n\nexport interface WASMJSON {\n    functions: WASMJSONFunction[];\n    types: string[];\n    data: Array<{\n        offset: number;\n        data: ArrayBuffer;\n    }>;\n    globals: Array<{\n        name: string,\n        type: number,\n        init: string,\n    }>;\n    imports: Array<{\n        module: string;\n        name: string;\n        type: string;\n    }>;\n    exports: {\n        [key: string]: number,\n    };\n}\n\nexport class JSONEmitter extends Emitter {\n    public memoryInfo: Array<[number, number, number]>;\n    public insBuffer: WASMJSONInstruction[];\n    public wasmJSON: WASMJSON;\n    public constructor(externMap: Map<string, number>, sourceMap: Map<string, SourceMap>) {\n        super(externMap, sourceMap);\n        this.memoryInfo = [];\n        this.insBuffer = [];\n        this.wasmJSON = {\n            functions: [],\n            types: [],\n            globals: [],\n            imports: [],\n            data: [],\n            exports: {},\n        };\n    }\n\n    public writeByte(byte: number): void {\n        // ignore\n    }\n\n    public writeBytes(bytes: number[]): void {\n        // ignore\n    }\n\n    public createLengthSlot(): [number, number] {\n        // ignore\n        return [0, 0];\n    }\n\n    public emit(type: WType, value: number | string): void {\n        // ignore\n    }\n\n    public fillLengthSlot(slot: [number, number]): void {\n        // ignore\n    }\n\n    public emitIns(control: number, valueType: WType, value: number | string,\n                   location: SourceLocation, align?: boolean): void {\n        this.insBuffer.push([control, value, this.ctx.getStartLine(location)]);\n    }\n\n    public enterFunction(func: WFunction): void {\n        this.ctx.setCurrentFunc(func);\n        this.insBuffer = [];\n    }\n\n    public submitFunction(): void {\n        // match the block/end pair\n        const codes = this.insBuffer;\n        const stack = [];\n        for (let i = 0; i < codes.length; i++) {\n            if (codes[i][0] === Control.if || codes[i][0] === Control.block || codes[i][0] === Control.loop) {\n                stack.push(i);\n            } else if (codes[i][0] === Control.else) {\n                codes[stack[stack.length - 1]][1] = i;\n                stack.pop();\n                stack.push(i);\n            } else if (codes[i][0] === Control.end) {\n                codes[stack[stack.length - 1]][1] = i;\n                stack.pop();\n            }\n        }\n        codes.push([Control.return, 0, -1]);\n\n        // build inverse idx\n        const inverseIdx = new Set<number>();\n        const lineIdx = new Set<number>();\n        for (let i = 0; i < codes.length; i++) {\n            if (codes[i][2] !== -1 && !inverseIdx.has(codes[i][2])) {\n                inverseIdx.add(codes[i][2]);\n                lineIdx.add(i);\n            }\n        }\n        const func = this.ctx.getCurrentFunc();\n        this.wasmJSON.functions.push({\n            name: func.name,\n            fileName: func.fileName,\n            displayName: func.displayName,\n            locals: func.local.map((x) => getNativeType(x)),\n            codes,\n            type: func.type.toEncoding(),\n            signatureId: func.signatureId,\n            lineIdx,\n            dataStart: func.dataStart,\n            bssStart: func.bssStart,\n            scope: null,\n            memoryInfo: this.memoryInfo,\n            sourceRange: [this.ctx.getStartLine(func.location), this.ctx.getEndLine(func.location)],\n        });\n        this.memoryInfo = [];\n        this.ctx.setCurrentFunc(null);\n    }\n\n    public getJSON(): WASMJSON {\n        return this.wasmJSON;\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {JSONEmitter} from \"../emitter/json_emitter\";\nimport {SectionCode, WType} from \"../tool/constant\";\nimport {WDataSegment} from \"./wdata_segment\";\nimport {WSection} from \"./wsection\";\n\nexport class WDataSection extends WSection {\n    public segments: WDataSegment[];\n\n    constructor(segments: WDataSegment[], location: SourceLocation) {\n        super(location);\n        this.segments = segments;\n    }\n\n    public emit(e: Emitter): void {\n        e.writeByte(SectionCode.data);\n        const slot = e.createLengthSlot();\n        e.emit(WType.u32, this.segments.length);\n        this.segments.map((x) => x.emit(e));\n        e.fillLengthSlot(slot);\n        if (e instanceof JSONEmitter) {\n            e.getJSON().data = this.segments.map((x) => ({\n                offset: x.offsetNumber,\n                data: x.dataBuffer,\n            }));\n        }\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {JSONEmitter} from \"../emitter/json_emitter\";\nimport {WNode} from \"../node\";\nimport {WType} from \"../tool/constant\";\n\nexport class WExportFunction extends WNode {\n    public name: string;\n\n    constructor(name: string, location: SourceLocation) {\n        super(location);\n        this.name = name;\n    }\n\n    public emit(e: Emitter): void {\n        e.emit(WType.str, this.name);\n        e.writeByte(0x00);\n        e.emit(WType.u32, e.ctx.getFuncInfo(this.name).id);\n        if (e instanceof JSONEmitter) {\n            e.getJSON().exports[this.name] = e.ctx.getFuncInfo(this.name).id;\n        }\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WNode} from \"../node\";\nimport {SectionCode, WType} from \"../tool/constant\";\n\nexport class WMemorySection extends WNode {\n    public pageInfo: Array<[number, number | null]>;\n\n    constructor(pageInfo: Array<[number, (number | null)]>, location: SourceLocation) {\n        super(location);\n        this.pageInfo = pageInfo;\n    }\n\n    public emit(e: Emitter): void {\n        e.writeByte(SectionCode.memory);\n        const slot = e.createLengthSlot();\n        e.emit(WType.u32, this.pageInfo.length);\n        this.pageInfo.map((tuple) => {\n            const val = tuple[1];\n            if (val === null) {\n                e.writeByte(0x00);\n                e.emit(WType.u32, tuple[0]);\n            } else {\n                e.writeByte(0x01);\n                e.emit(WType.u32, tuple[0]);\n                e.emit(WType.u32, val);\n            }\n        });\n        e.fillLengthSlot(slot);\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {SectionCode, WType} from \"../tool/constant\";\nimport {WFunction} from \"./wfunction\";\nimport {WSection} from \"./wsection\";\n\nexport class WFunctionSection extends WSection {\n    public functions: WFunction[];\n\n    constructor(functions: WFunction[], location: SourceLocation) {\n        super(location);\n        this.functions = functions;\n    }\n\n    public emit(e: Emitter): void {\n        e.writeByte(SectionCode.function);\n        const slot = e.createLengthSlot();\n        e.emit(WType.u32, this.functions.length);\n        this.functions.map((x) => e.ctx.submitFunc(x.name, x.type));\n        this.functions.map((x) => e.emit(WType.u32, x.signatureId));\n        e.fillLengthSlot(slot);\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WNode} from \"../node\";\nimport {WType} from \"../tool/constant\";\n\nexport class WTable extends WNode {\n\n    public len: number;\n\n    constructor(len: number, location: SourceLocation) {\n        super(location);\n        this.len = len;\n    }\n\n    public emit(e: Emitter): void {\n        e.writeByte(0x70);\n        e.writeByte(0x00);\n        e.emit(WType.u32, this.len);\n    }\n\n}\n","import {Emitter} from \"../emitter/emitter\";\nimport {WNode} from \"../node\";\nimport {WType} from \"../tool/constant\";\n\nexport abstract class WExpression extends WNode {\n\n    public abstract deduceType(e: Emitter): WType;\n\n    public abstract isPure(): boolean;\n\n    public fold(): WExpression {\n        return this;\n    }\n\n}\n\nexport enum WMemoryLocation {\n    RAW,\n    DATA,\n    BSS,\n    EXTERN,\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {F32, F64, getNativeType, I32, I64, WType} from \"../tool/constant\";\nimport {WExpression} from \"./wexpression\";\n\nexport class WConst extends WExpression {\n    public type: WType;\n    public constant: string;\n\n    constructor(type: WType, constant: string, location: SourceLocation) {\n        super(location);\n        this.type = type;\n        this.constant = constant;\n    }\n\n    public emit(e: Emitter): void {\n        switch (getNativeType(this.type)) {\n            case WType.i32:\n                e.emitIns(I32.const, WType.i32, parseInt(this.constant), this.location);\n                break;\n            case WType.i64:\n                e.emitIns(I64.const, WType.i64, this.constant.split(\".\")[0], this.location);\n                break;\n            case WType.f32:\n                e.emitIns(F32.const, WType.f32, parseFloat(this.constant), this.location);\n                break;\n            case WType.f64:\n                e.emitIns(F64.const, WType.f64, parseFloat(this.constant), this.location);\n                break;\n        }\n    }\n\n    public deduceType(e: Emitter): WType {\n        return this.type;\n    }\n\n    public isPure(): boolean {\n        return true;\n    }\n}\n","import {EmitError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {JSONEmitter} from \"../emitter/json_emitter\";\nimport {WConst} from \"../expression/wconst\";\nimport {WExpression} from \"../expression/wexpression\";\nimport {WNode} from \"../node\";\nimport {Control, getNativeType, WType} from \"../tool/constant\";\n\nexport class WGlobalVariable extends WNode {\n    public name: string;\n    public type: WType;\n    public init: WExpression;\n\n    constructor(name: string, type: WType, init: WExpression, location: SourceLocation) {\n        super(location);\n        this.name = name;\n        this.type = type;\n        this.init = init;\n    }\n\n    public emit(e: Emitter): void {\n        e.ctx.submitGlobal(this.name, this.type);\n        e.writeByte(getNativeType(this.type));\n        e.writeByte(0x01); // mutable\n        this.init.emit(e);\n        e.writeByte(Control.end);\n        if ( e instanceof JSONEmitter) {\n            if (this.init instanceof WConst) {\n                e.getJSON().globals.push({\n                    name: this.name,\n                    type: getNativeType(this.type),\n                    init: this.init.constant,\n                });\n            } else {\n                throw new EmitError(`unknown error`);\n            }\n        }\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WConst} from \"../expression/wconst\";\nimport {WExpression} from \"../expression/wexpression\";\nimport {WNode} from \"../node\";\nimport {Control, WType} from \"../tool/constant\";\n\nexport class WElement extends WNode {\n\n    public len: number;\n    public offset: WExpression;\n\n    constructor(idx: number, location: SourceLocation) {\n        super(location);\n        this.len = idx;\n        this.offset = new WConst(WType.i32, \"0\", location);\n    }\n\n    public emit(e: Emitter): void {\n        e.writeByte(0x00); // table idx\n        this.offset.emit(e);\n        e.writeByte(Control.end);\n        e.emit(WType.u32, this.len);\n        for (let i = 0; i < this.len; i++) {\n            e.emit(WType.u32, i);\n        }\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {SectionCode, WType} from \"../tool/constant\";\nimport {WElement} from \"./welement\";\nimport {WSection} from \"./wsection\";\n\nexport class WElementSection extends WSection {\n    public elems: WElement[];\n\n    constructor(len: number, location: SourceLocation) {\n        super(location);\n        this.elems = [new WElement(len, location)];\n    }\n\n    public emit(e: Emitter): void {\n        e.writeByte(SectionCode.element);\n        const slot = e.createLengthSlot();\n        e.emit(WType.u32, this.elems.length);\n        this.elems.map((x) => x.emit(e));\n        e.fillLengthSlot(slot);\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {JSONEmitter} from \"../emitter/json_emitter\";\nimport {WType} from \"../tool/constant\";\nimport {WFunctionType} from \"./wfunction_type\";\nimport {WImportItem} from \"./wimport_item\";\n\nexport class WImportFunction extends WImportItem {\n\n    public type: WFunctionType;\n    public signatureId: number;\n\n    constructor(module: string, name: string, returnType: WType[],\n                parameters: WType[], location: SourceLocation) {\n        super(module, name, location);\n        this.module = module;\n        this.name = name;\n        this.type = new WFunctionType(returnType, parameters, this.location);\n        this.signatureId = 0;\n    }\n\n    public emit(e: Emitter): void {\n        super.emit(e);\n        e.writeByte(0x00);\n        e.emit(WType.u32, this.signatureId);\n        e.ctx.submitFunc(this.name, this.type);\n        if (e instanceof JSONEmitter) {\n            e.getJSON().imports.push({\n                module: this.module,\n                name: this.name,\n                type: this.type.toEncoding(),\n            });\n        }\n    }\n}\n","import {JSONEmitter} from \"..\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {SectionCode, WType} from \"../tool/constant\";\nimport {WFunctionType} from \"./wfunction_type\";\nimport {WSection} from \"./wsection\";\n\nexport class WTypeSection extends WSection {\n    public types: WFunctionType[];\n\n    constructor(types: WFunctionType[], location: SourceLocation) {\n        super(location);\n        this.types = types;\n    }\n\n    public emit(e: Emitter): void {\n        e.writeByte(SectionCode.type);\n        const slot = e.createLengthSlot();\n        e.emit(WType.u32, this.types.length);\n        for (let i = 0; i < this.types.length; i++) {\n            e.ctx.setTypeIdxFromEncoding(this.types[i].toEncoding(), i);\n            this.types[i].emit(e);\n        }\n        e.fillLengthSlot(slot);\n        if (e instanceof JSONEmitter) {\n            e.getJSON().types = this.types.map( (x) => x.toEncoding());\n        }\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {SectionCode, WType} from \"../tool/constant\";\nimport {WSection} from \"./wsection\";\nimport {WTable} from \"./wtable\";\n\nexport class WTableSection extends WSection {\n\n    public tables: WTable[];\n\n    constructor(tables: WTable[], location: SourceLocation) {\n        super(location);\n        this.tables = tables;\n    }\n\n    public emit(e: Emitter): void {\n        e.writeByte(SectionCode.table);\n        const slot = e.createLengthSlot();\n        e.emit(WType.u32, this.tables.length);\n        this.tables.map((x) => x.emit(e));\n        e.fillLengthSlot(slot);\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {SectionCode, WType} from \"../tool/constant\";\nimport {WGlobalVariable} from \"./wglobal_variable\";\nimport {WSection} from \"./wsection\";\n\nexport class WGlobalSection extends WSection {\n    public globals: WGlobalVariable[];\n\n    constructor(functions: WGlobalVariable[], location: SourceLocation) {\n        super(location);\n        this.globals = functions;\n    }\n\n    public emit(e: Emitter): void {\n        e.writeByte(SectionCode.global);\n        const slot = e.createLengthSlot();\n        e.emit(WType.u32, this.globals.length);\n        this.globals.map((x) => x.emit(e));\n        e.fillLengthSlot(slot);\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WConst} from \"../expression/wconst\";\nimport {WExpression} from \"../expression/wexpression\";\nimport {WNode} from \"../node\";\nimport {Control, WType} from \"../tool/constant\";\n\nexport class WDataSegment extends WNode {\n    public memIdx: number;\n    public offset: WExpression;\n    public dataBuffer: ArrayBuffer;\n    public offsetNumber: number;\n\n    constructor(offset: number, dataBuffer: ArrayBuffer, location: SourceLocation) {\n        super(location);\n        this.memIdx = 0;\n        this.offsetNumber = offset;\n        this.offset = new WConst(WType.i32, offset.toString(), location);\n        this.dataBuffer = dataBuffer;\n    }\n\n    public emit(e: Emitter): void {\n        e.emit(WType.u32, this.memIdx);\n        this.offset.emit(e);\n        e.writeByte(Control.end);\n        e.emit(WType.u32, this.dataBuffer.byteLength);\n        const ui8a = new Uint8Array(this.dataBuffer);\n        for (let i = 0; i < this.dataBuffer.byteLength; i++) {\n            e.writeByte(ui8a[i]);\n        }\n    }\n\n}\n","(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {\n      Buffer = window.Buffer;\n    } else {\n      Buffer = require('buffer').Buffer;\n    }\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n      this.negative = 1;\n    }\n\n    if (start < number.length) {\n      if (base === 16) {\n        this._parseHex(number, start, endian);\n      } else {\n        this._parseBase(number, base, start);\n        if (endian === 'le') {\n          this._initArray(this.toArray(), base, endian);\n        }\n      }\n    }\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [ number & 0x3ffffff ];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [ 0 ];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this.strip();\n  };\n\n  function parseHex4Bits (string, index) {\n    var c = string.charCodeAt(index);\n    // 'A' - 'F'\n    if (c >= 65 && c <= 70) {\n      return c - 55;\n    // 'a' - 'f'\n    } else if (c >= 97 && c <= 102) {\n      return c - 87;\n    // '0' - '9'\n    } else {\n      return (c - 48) & 0xf;\n    }\n  }\n\n  function parseHexByte (string, lowerBound, index) {\n    var r = parseHex4Bits(string, index);\n    if (index - 1 >= lowerBound) {\n      r |= parseHex4Bits(string, index - 1) << 4;\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start, endian) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    // 24-bits chunks\n    var off = 0;\n    var j = 0;\n\n    var w;\n    if (endian === 'be') {\n      for (i = number.length - 1; i >= start; i -= 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    } else {\n      var parseLength = number.length - start;\n      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    }\n\n    this.strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        r += c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        r += c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r += c;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [ 0 ];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    this.strip();\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype.strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  BN.prototype.inspect = function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  };\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16);\n  };\n\n  BN.prototype.toBuffer = function toBuffer (endian, length) {\n    assert(typeof Buffer !== 'undefined');\n    return this.toArrayLike(Buffer, endian, length);\n  };\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    this.strip();\n    var littleEndian = endian === 'le';\n    var res = new ArrayType(reqLength);\n\n    var b, i;\n    var q = this.clone();\n    if (!littleEndian) {\n      // Assume big-endian\n      for (i = 0; i < reqLength - byteLength; i++) {\n        res[i] = 0;\n      }\n\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[reqLength - i - 1] = b;\n      }\n    } else {\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[i] = b;\n      }\n\n      for (; i < reqLength; i++) {\n        res[i] = 0;\n      }\n    }\n\n    return res;\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this.strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this.strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this.strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    var fftm = new FFTM();\n    return fftm.mulp(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out.strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this.strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) < num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this.strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this.strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q.strip();\n    }\n    a.strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modn = function modn (num) {\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return acc;\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this.strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is BN v4 instance\n        r.strip();\n      } else {\n        // r is BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n    return a.umod(this.m)._forceRed(this);\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})(typeof module === 'undefined' || module, this);\n","import Bn = require(\"bn.js\");\n\nexport interface ByteStream {\n    view: DataView;\n    now: number;\n    nowSize: number;\n}\n\nexport function readLeb128Int(stream: ByteStream): Bn {\n    const num = new Bn(0);\n    let shift = 0;\n    let byte;\n    while (true) {\n        byte = stream.view.getUint8(stream.now++);\n        num.ior(new Bn(byte & 0x7f).shln(shift));\n        shift += 7;\n        if (byte >> 7 === 0) {\n            break;\n        }\n    }\n    // sign extend if negitive\n    if (byte & 0x40) {\n        num.setn(shift);\n    }\n    return num.fromTwos(shift);\n}\n\nexport function writeLeb128Int(stream: ByteStream, number: number | string): void {\n    let num = new Bn(number);\n    const isNeg = num.isNeg();\n    if (isNeg) {\n        num = num.toTwos(num.bitLength() + 8);\n    }\n    while (true) {\n        const i = num.maskn(7).toNumber();\n        num.ishrn(7);\n        if ((isNegOne(num) && (i & 0x40) !== 0) ||\n            (num.isZero() && (i & 0x40) === 0)) {\n            stream.view.setUint8(stream.now++, i);\n            stream.nowSize++;\n            break;\n        } else {\n            stream.view.setUint8(stream.now++, i | 0x80);\n            stream.nowSize++;\n        }\n    }\n    function isNegOne(x: Bn) {\n        return isNeg && x.toString(2).indexOf(\"0\") < 0;\n    }\n}\n\nexport function readLeb128Uint(stream: ByteStream): Bn {\n    const num = new Bn(0);\n    let shift = 0;\n    let byte;\n    while (true) {\n        byte = stream.view.getUint8(stream.now++);\n        num.ior(new Bn(byte & 0x7f).shln(shift));\n        if (byte >> 7 === 0) {\n            break;\n        } else {\n            shift += 7;\n        }\n    }\n    return num;\n}\n\nexport function writeLeb128Uint(stream: ByteStream, number: number | string): void {\n    const num = new Bn(number);\n    while (true) {\n        const i = num.maskn(7).toNumber();\n        num.ishrn(7);\n        if (num.isZero()) {\n            stream.view.setUint8(stream.now++, i);\n            stream.nowSize++;\n            break;\n        } else {\n            stream.view.setUint8(stream.now++, i | 0x80);\n            stream.nowSize++;\n        }\n    }\n}\n\nexport function getLeb128IntLength(number: number | string): number {\n    let result = 0;\n    let num = new Bn(number);\n    const isNeg = num.isNeg();\n    if (isNeg) {\n        num = num.toTwos(num.bitLength() + 8);\n    }\n    while (true) {\n        const i = num.maskn(7).toNumber();\n        num.ishrn(7);\n        if ((isNegOne(num) && (i & 0x40) !== 0) ||\n            (num.isZero() && (i & 0x40) === 0)) {\n            result++;\n            break;\n        } else {\n            result++;\n        }\n    }\n    function isNegOne(x: Bn) {\n        return isNeg && x.toString(2).indexOf(\"0\") < 0;\n    }\n    return result;\n}\n\nexport function getLeb128UintLength(number: number): number {\n    let result = 0;\n    const num = new Bn(number);\n    while (true) {\n        num.ishrn(7);\n        if (num.isZero()) {\n            result++;\n            break;\n        } else {\n            result++;\n        }\n    }\n    return result;\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 14/07/2018\n */\nimport {ByteStream, getLeb128UintLength, readLeb128Uint, writeLeb128Uint} from \"./leb128\";\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\nexport function readUtf8Str(stream: ByteStream): string {\n    const length = readLeb128Uint(stream).toNumber();\n    return decoder.decode(stream.view.buffer.slice(0, length));\n}\n\nexport function writeUtf8String(stream: ByteStream, input: string) {\n    const array = encoder.encode(input);\n    writeLeb128Uint(stream, array.byteLength);\n    new Uint8Array(stream.view.buffer).set(array, stream.now);\n    stream.now += array.byteLength;\n    stream.nowSize += array.byteLength;\n}\n\nexport function getUtf8StringLength(input: string) {\n    const blen = encoder.encode(input).byteLength;\n    return getLeb128UintLength(blen) + blen;\n}\n","import {InternalError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {SourceMap} from \"../../common/object\";\nimport {WFunction} from \"../section/wfunction\";\nimport {WType} from \"../tool/constant\";\nimport {getLeb128UintLength, writeLeb128Int, writeLeb128Uint} from \"../tool/leb128\";\nimport {writeUtf8String} from \"../tool/utf8\";\nimport {Emitter} from \"./emitter\";\n\nfunction getAlign(value: string | number) {\n    return 0;\n}\n\nexport class WASMEmitter extends Emitter {\n    public buffer: ArrayBuffer;\n    public view: DataView;\n    public now: number;\n    public nowSize: number;\n    public slots: Array<[number, number]>;\n\n    public constructor(externMap: Map<string, number>, sourceMap: Map<string, SourceMap>) {\n        super(externMap, sourceMap);\n        this.buffer = new ArrayBuffer(20000);\n        this.view = new DataView(this.buffer);\n        this.now = 0;\n        this.nowSize = 0;\n        this.slots = [];\n    }\n\n    public createLengthSlot(): [number, number] {\n        const slot = [this.nowSize, this.now] as [number, number];\n        this.slots.push(slot);\n        this.now += 4;\n        return slot;\n    }\n\n    public fillLengthSlot(slot: [number, number]): void {\n        const len = this.nowSize - slot[0];\n        this.nowSize += getLeb128UintLength(len);\n        this.view.setUint32(slot[1], len);\n    }\n\n    public writeByte(byte: number): void {\n        this.view.setUint8(this.now++, byte);\n        this.nowSize++;\n    }\n\n    public writeBytes(bytes: number[]): void {\n        for (const byte of bytes) {\n            this.view.setUint8(this.now++, byte);\n            this.nowSize++;\n        }\n    }\n\n    public emit(type: WType, value: number | string): void {\n        switch (type) {\n            case WType.none:\n                break;\n            case WType.u8:\n                if (typeof(value) === \"string\") {\n                    throw new InternalError(\"unexpected string\");\n                }\n                this.view.setUint8(this.now, value);\n                this.now += 1;\n                this.nowSize += 1;\n                break;\n            case WType.u32:\n            case WType.u64:\n                writeLeb128Uint(this, value);\n                break;\n            case WType.i32:\n            case WType.i64:\n                writeLeb128Int(this, value);\n                break;\n            case WType.f32:\n                if (typeof(value) === \"string\") {\n                    throw new InternalError(\"unexpected string\");\n                }\n                this.view.setFloat32(this.now, value, true);\n                this.now += 4;\n                this.nowSize += 4;\n                break;\n            case WType.f64:\n                if (typeof(value) === \"string\") {\n                    throw new InternalError(\"unexpected string\");\n                }\n                this.view.setFloat64(this.now, value, true);\n                this.now += 8;\n                this.nowSize += 8;\n                break;\n            case WType.str:\n                if (typeof(value) === \"number\") {\n                    throw new InternalError(\"unexpected string\");\n                }\n                writeUtf8String(this, value);\n                break;\n            default:\n                throw new InternalError(\"unexpected wtype\");\n        }\n    }\n\n    public emitIns(control: number, valueType: WType, value: number | string,\n                   location: SourceLocation, align?: boolean): void {\n        this.writeByte(control);\n        if (align) {\n            this.emit(WType.u32, getAlign(value));\n        }\n        this.emit(valueType, value);\n    }\n\n    public enterFunction(func: WFunction): void {\n        this.ctx.setCurrentFunc(func);\n    }\n\n    public submitFunction(): void {\n        this.ctx.setCurrentFunc(null);\n    }\n\n    public toArrayBuffer(): ArrayBuffer {\n        const result = new ArrayBuffer(this.nowSize);\n        const resultArray = new Uint8Array(result);\n        const resultView = new DataView(result);\n        const bufferArray = new Uint8Array(this.buffer);\n        const stream = {\n            view: resultView,\n            now: 0,\n            nowSize: 0,\n        };\n        let last = 0;\n        for (const slot of this.slots) {\n            if (slot[1] !== last) {\n                resultArray.set(bufferArray.slice(last, slot[1]), stream.now);\n                stream.now += slot[1] - last;\n            }\n            const len = this.view.getUint32(slot[1]);\n            writeLeb128Uint(stream, len);\n            last = slot[1] + 4;\n        }\n        resultArray.set(bufferArray.slice(last, this.now), stream.now);\n        stream.now += this.now - last;\n        if (stream.now !== this.nowSize) {\n            throw new InternalError(`something wrong`);\n        }\n        return result;\n    }\n}\n","import {WNode} from \"../node\";\n\nexport abstract class WStatement extends WNode {\n\n}\n","import {EmitError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WExpression} from \"../expression/wexpression\";\nimport {Control, getNativeType, WType} from \"../tool/constant\";\nimport {WStatement} from \"./wstatement\";\n\nexport class WReturn extends WStatement {\n    public expr: WExpression | null;\n\n    constructor(expr: WExpression | null, location: SourceLocation) {\n        super(location);\n        this.expr = expr;\n        if (expr !== null) {\n            this.expr = expr;\n        }\n    }\n\n    public emit(e: Emitter): void {\n        const curFunc = e.ctx.getCurrentFunc();\n        if ( curFunc.type.returnTypes.length === 0 && this.expr !== null) {\n            throw new EmitError(`type mismatch at WReturn`);\n        }\n        if ( curFunc.type.returnTypes.length !== 0) {\n            if (this.expr === null) {\n                throw new EmitError(`type mismatch at WReturn`);\n            }\n            const exprType = this.expr.deduceType(e);\n            if (getNativeType(exprType) !== getNativeType(curFunc.type.returnTypes[0])) {\n                throw new EmitError(`type mismatch at WReturn`);\n            }\n        }\n        if (this.expr !== null) {\n            this.expr.emit(e);\n        }\n        e.emitIns(Control.return, WType.none, 0, this.location);\n    }\n\n    public optimize(e: Emitter): void {\n        if (this.expr !== null) {\n            this.expr = this.expr.fold();\n            this.expr.optimize(e);\n        }\n    }\n\n}\n","module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 14/07/2018\n */\nimport * as Long from \"long\";\nimport {RuntimeError} from \"../../common/error\";\nimport {\n    BinaryOperator,\n    F32Binary,\n    F32Unary,\n    F64Binary, F64Unary,\n    I32Binary,\n    I32Unary,\n    I64Binary,\n    I64Unary,\n    UnaryOperator,\n} from \"./constant\";\n\nexport function doUnaryCompute(ope: UnaryOperator, value: number): number {\n    switch (ope) {\n        case F32Unary.abs:\n        case F64Unary.abs:\n            return Math.abs(value);\n        case F32Unary.ceil:\n        case F64Unary.ceil:\n            return Math.ceil(value);\n        case F32Unary.floor:\n        case F64Unary.floor:\n            return Math.floor(value);\n        case F32Unary.nearest:\n        case F64Unary.nearest:\n            return Math.floor(value + 0.5);\n        case F32Unary.trunc:\n        case F64Unary.trunc:\n            return value | 0;\n        case F32Unary.sqrt:\n        case F64Unary.sqrt:\n            return Math.sqrt(value);\n        case I32Unary.eqz:\n        case I64Unary.eqz:\n            return +(value === 0);\n        case F32Unary.neg:\n        case F64Unary.neg:\n            return -value;\n\n    }\n    throw new RuntimeError(`unsupport operator ${ope}`);\n}\n\nexport function doLongUnaryCompute(ope: UnaryOperator, value: Long): Long {\n    switch (ope) {\n        case I64Unary.eqz:\n            return Long.fromNumber(+(value.eq(0)));\n    }\n    throw new RuntimeError(`unsupport operator ${ope}`);\n}\n\nexport function doLongBinaryCompute(ope: BinaryOperator, lhs: Long, rhs: Long): Long {\n    switch (ope) {\n        case I64Binary.add:\n            return lhs.add(rhs);\n        case I64Binary.sub:\n            return lhs.sub(rhs);\n        case I64Binary.mul:\n            return lhs.sub(rhs);\n        case I64Binary.div_s:\n        case I64Binary.div_u:\n            return lhs.div(rhs);\n        case I64Binary.rem_s:\n        case I64Binary.rem_u:\n            return lhs.mod(rhs);\n        case I64Binary.ge_s:\n        case I64Binary.ge_u:\n            return Long.fromNumber(+lhs.gte(rhs));\n        case I64Binary.gt_s:\n        case I64Binary.gt_u:\n            return Long.fromNumber(+lhs.gt(rhs));\n        case I64Binary.le_s:\n        case I64Binary.le_u:\n            return Long.fromNumber(+lhs.lte(rhs));\n        case I64Binary.lt_s:\n        case I64Binary.lt_u:\n            return Long.fromNumber(+lhs.lt(rhs));\n        case I64Binary.ne:\n            return Long.fromNumber(+lhs.neq(rhs));\n        case I64Binary.eq:\n            return Long.fromNumber(+lhs.eq(rhs));\n        case I64Binary.and:\n            return lhs.and(rhs);\n        case I64Binary.or:\n            return lhs.or(rhs);\n        case I64Binary.xor:\n            return lhs.xor(rhs);\n        case I64Binary.shl:\n            return lhs.shl(rhs);\n        case I64Binary.shr_s:\n            return lhs.shr(rhs);\n        case I64Binary.shr_u:\n            return lhs.shru(rhs);\n    }\n    throw new RuntimeError(`unsupport operator ${ope}`);\n}\nexport function doBinaryCompute(ope: BinaryOperator, lhs: number, rhs: number): number {\n    switch (ope) {\n        case I32Binary.add:\n        case F32Binary.add:\n        case F64Binary.add:\n            return lhs + rhs;\n        case I32Binary.sub:\n        case F32Binary.sub:\n        case F64Binary.sub:\n            return lhs - rhs;\n        case I32Binary.mul:\n        case F32Binary.mul:\n        case F64Binary.mul:\n            return lhs * rhs;\n        case I32Binary.div_s:\n        case I32Binary.div_u:\n        case F32Binary.div:\n        case F64Binary.div:\n            return lhs / rhs;\n        case I32Binary.rem_s:\n        case I32Binary.rem_u:\n            return lhs % rhs;\n        case I32Binary.ge_s:\n        case I32Binary.ge_u:\n            return +(lhs >= rhs);\n        case I32Binary.gt_s:\n        case I32Binary.gt_u:\n        case F32Binary.gt:\n        case F64Binary.gt:\n            return +(lhs > rhs);\n        case I32Binary.le_s:\n        case I32Binary.le_u:\n        case F32Binary.le:\n        case F64Binary.le:\n            return +(lhs <= rhs);\n        case I32Binary.lt_s:\n        case I32Binary.lt_u:\n        case F32Binary.lt:\n        case F64Binary.lt:\n            return +(lhs < rhs);\n        case I32Binary.eq:\n        case F32Binary.eq:\n        case F64Binary.eq:\n            return +(lhs === rhs);\n        case I32Binary.ne:\n        case F32Binary.ne:\n        case F64Binary.ne:\n            return +(lhs !== rhs);\n        case I32Binary.and:\n            return +(lhs & rhs);\n        case I32Binary.or:\n            return +(lhs | rhs);\n        case I32Binary.xor:\n            return +(lhs ^ rhs);\n        case I32Binary.shl:\n            return lhs << rhs;\n        case I32Binary.shr_s:\n            return lhs >> rhs;\n        case I32Binary.shr_u:\n            return lhs >>> rhs;\n        case F32Binary.copysign:\n        case F64Binary.copysign:\n            return rhs > 0 ? Math.abs(lhs) : -Math.abs(lhs);\n        case F32Binary.max:\n        case F64Binary.max:\n            return Math.max(lhs, rhs);\n        case F32Binary.min:\n        case F64Binary.min:\n            return Math.min(lhs, rhs);\n    }\n    throw new RuntimeError(`unsupport operator ${ope}`);\n}\n","import * as Long from \"long\";\nimport {EmitError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {doBinaryCompute, doLongBinaryCompute} from \"../tool/calculator\";\nimport {BinaryOperator, getNativeType, OpTypeMap, WType} from \"../tool/constant\";\nimport {WConst} from \"./wconst\";\nimport {WExpression} from \"./wexpression\";\n\nexport class WBinaryOperation extends WExpression {\n    public ope: BinaryOperator;\n    public lhs: WExpression;\n    public rhs: WExpression;\n\n    constructor(ope: BinaryOperator, lhs: WExpression, rhs: WExpression, location: SourceLocation) {\n        super(location);\n        this.ope = ope;\n        this.lhs = lhs;\n        this.rhs = rhs;\n    }\n\n    public emit(e: Emitter): void {\n        this.lhs.emit(e);\n        this.rhs.emit(e);\n        e.emitIns(this.ope, WType.none, 0, this.location);\n    }\n\n    public deduceType(e: Emitter): WType {\n        const lhs = getNativeType(this.lhs.deduceType(e));\n        const rhs = getNativeType(this.rhs.deduceType(e));\n        if (lhs !== rhs || OpTypeMap.get(this.ope) !== lhs) {\n            throw new EmitError(`type mismatch in binaryope`);\n        }\n        return lhs;\n    }\n\n    public fold(): WExpression {\n        this.lhs = this.lhs.fold();\n        this.rhs = this.rhs.fold();\n        if (this.lhs instanceof WConst && this.rhs instanceof WConst) {\n            const type = OpTypeMap.get(this.ope)!;\n            if (type === WType.f32 || type === WType.f64) {\n                return new WConst(type,\n                    doBinaryCompute(this.ope,\n                        parseFloat(this.lhs.constant),\n                        parseFloat(this.rhs.constant)).toString(), this.location);\n            } else if (type === WType.i32) {\n                return new WConst(type,\n                    doBinaryCompute(this.ope,\n                        parseInt(this.lhs.constant),\n                        parseInt(this.rhs.constant)).toString(), this.location);\n            } else {\n                return new WConst(type,\n                    doLongBinaryCompute(this.ope,\n                        Long.fromString(this.lhs.constant),\n                        Long.fromString(this.rhs.constant)).toString(), this.location);\n            }\n        } else {\n            return this;\n        }\n    }\n\n    public isPure(): boolean {\n        return this.lhs.isPure() && this.rhs.isPure();\n    }\n}\n","import {EmitError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {JSONEmitter} from \"../emitter/json_emitter\";\nimport {WBinaryOperation} from \"../expression/wbinary_operation\";\nimport {WConst} from \"../expression/wconst\";\nimport {WExpression, WMemoryLocation} from \"../expression/wexpression\";\nimport {F32, F64, getNativeType, I32, I32Binary, I64, WType} from \"../tool/constant\";\nimport {WStatement} from \"./wstatement\";\n\nexport class WStore extends WStatement {\n    public type: WType;\n    public address: WExpression;\n    public value: WExpression;\n    public offset: number;\n    public form: WMemoryLocation;\n    public offsetName: string;\n\n    constructor(type: WType,\n                address: WExpression, value: WExpression,\n                form: WMemoryLocation = WMemoryLocation.RAW, location: SourceLocation) {\n        super(location);\n        this.type = type;\n        this.address = address;\n        this.value = value;\n        this.offset = 0;\n        this.form = form;\n        this.offsetName = \"\";\n    }\n\n    public getOp() {\n        switch (this.type) {\n            case WType.u8:\n            case WType.i8: return I32.store8;\n            case WType.i16:\n            case WType.u16: return I32.store16;\n            case WType.i32:\n            case WType.u32: return I32.store;\n            case WType.f32: return F32.store;\n            case WType.f64: return F64.store;\n            case WType.i64:\n            case WType.u64: return I64.store;\n        }\n    }\n\n    public emit(e: Emitter): void {\n        const offset = this.computeOffset(e);\n        this.address.emit(e);\n        this.value.emit(e);\n        e.emitIns(this.getOp() as number, WType.u32, offset, this.location, true);\n        if (e instanceof JSONEmitter) {\n            e.memoryInfo.push([e.insBuffer.length, this.form, this.offset]);\n        }\n    }\n\n    public replaceAddress() {\n        this.address = new WBinaryOperation(I32Binary.add,\n            this.address,\n            new WConst(WType.i32, this.offset.toString(), this.location),\n            this.location);\n        this.offset = 0;\n    }\n\n    public optimize(e: Emitter): void {\n        this.value = this.value.fold();\n        this.value.optimize(e);\n        this.address = this.address.fold();\n        this.address.optimize(e);\n    }\n\n    private computeOffset(e: Emitter): number {\n        if (getNativeType(this.value.deduceType(e)) !== getNativeType(this.type)) {\n            throw new EmitError(`type mismatch at store: ${this.value.deduceType(e)} and ${this.type}`);\n        }\n        if ( this.address.deduceType(e) !== WType.u32 && this.address.deduceType(e) !== WType.i32 ) {\n            throw new EmitError(`type mismatch at store, address`);\n        }\n        let offset = this.offset;\n        if ( this.form === WMemoryLocation.DATA ) {\n            offset += e.ctx.getCurrentFunc().dataStart;\n        } else if ( this.form === WMemoryLocation.BSS ) {\n            offset += e.ctx.getCurrentFunc().bssStart;\n        } else if ( this.form === WMemoryLocation.EXTERN ) {\n            offset += e.ctx.getExternLocation(this.offsetName);\n        }\n        if ( offset < 0 ) {\n            this.replaceAddress();\n            offset = 0;\n        }\n        return offset;\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {Control, WType} from \"../tool/constant\";\nimport {WStatement} from \"./wstatement\";\n\nexport class WBr extends WStatement {\n    public labelIdx: number;\n\n    constructor(labelIdx: number, location: SourceLocation) {\n        super(location);\n        this.labelIdx = labelIdx;\n    }\n\n    public emit(e: Emitter): void {\n        e.emitIns(Control.br, WType.u32, this.labelIdx, this.location);\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WExpression} from \"../expression/wexpression\";\nimport {WStatement} from \"./wstatement\";\n\nexport class WExprStatement extends WStatement {\n    public expr: WExpression;\n\n    constructor(expr: WExpression, location: SourceLocation) {\n        super(location);\n        this.expr = expr;\n    }\n\n    public emit(e: Emitter): void {\n        this.expr.emit(e);\n    }\n\n    public optimize(e: Emitter): void {\n        this.expr = this.expr.fold();\n        this.expr.optimize(e);\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {Control, WType} from \"../tool/constant\";\nimport {WStatement} from \"./wstatement\";\n\nexport class WBlock extends WStatement {\n    public body: WStatement[];\n\n    constructor(body: WStatement[], location: SourceLocation) {\n        super(location);\n        this.body = body;\n    }\n\n    public emit(e: Emitter): void {\n        e.emitIns(Control.block, WType.u8, 0x40, this.location);\n        this.body.map((stmt) => stmt.emit(e));\n        e.emitIns(Control.end, WType.none, 0, this.location);\n    }\n    public optimize(e: Emitter): void {\n        this.body.map((x) => x.optimize(e));\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WExpression} from \"../expression/wexpression\";\nimport {Control, WType} from \"../tool/constant\";\nimport {WStatement} from \"./wstatement\";\n\nexport class WSetLocal extends WStatement {\n    public type: WType;\n    public offset: number;\n    public value: WExpression;\n\n    constructor(type: WType, offset: number, value: WExpression, location: SourceLocation) {\n        super(location);\n        this.type = type;\n        this.offset = offset;\n        this.value = value;\n    }\n\n    public emit(e: Emitter): void {\n        this.value.emit(e);\n        e.emitIns(Control.set_local, WType.u32, this.offset, this.location);\n    }\n\n    public optimize(e: Emitter): void {\n        this.value = this.value.fold();\n        this.value.optimize(e);\n    }\n}\n","import {EmitError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WExpression} from \"../expression/wexpression\";\nimport {Control, WType} from \"../tool/constant\";\nimport {WStatement} from \"./wstatement\";\n\nexport class WSetGlobal extends WStatement {\n    public type: WType;\n    public name: string;\n    public value: WExpression;\n\n    constructor(type: WType, name: string, value: WExpression, location: SourceLocation) {\n        super(location);\n        this.type = type;\n        this.name = name;\n        this.value = value;\n    }\n\n    public emit(e: Emitter): void {\n        if (e.ctx.getGlobalInfo(this.name).type !== this.type) {\n            throw new EmitError(`type mismatch at set_global`);\n        }\n        this.value.emit(e);\n        e.emitIns(Control.set_global, WType.u32, e.ctx.getGlobalInfo(this.name).id, this.location);\n    }\n\n    public optimize(e: Emitter): void {\n        this.value = this.value.fold();\n        this.value.optimize(e);\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {Control, WType} from \"../tool/constant\";\nimport {WStatement} from \"./wstatement\";\n\nexport class WLoop extends WStatement {\n    public body: WStatement[];\n\n    constructor(body: WStatement[], location: SourceLocation) {\n        super(location);\n        this.body = body;\n    }\n\n    public emit(e: Emitter): void {\n        e.emitIns(Control.loop, WType.u8, 0x40, this.location);\n        this.body.map((stmt) => stmt.emit(e));\n        e.emitIns(Control.end, WType.none, 0, this.location);\n    }\n\n    public optimize(e: Emitter): void {\n        this.body.map((x) => x.optimize(e));\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WExpression} from \"../expression/wexpression\";\nimport {Control, WType} from \"../tool/constant\";\nimport {WStatement} from \"./wstatement\";\n\nexport class WBrIf extends WStatement {\n    public labelIdx: number;\n    public expression: WExpression;\n\n    constructor(labelIdx: number, expression: WExpression, location: SourceLocation) {\n        super(location);\n        this.labelIdx = labelIdx;\n        this.expression = expression;\n    }\n\n    public emit(e: Emitter): void {\n        this.expression.emit(e);\n        e.emitIns(Control.br_if, WType.u32, this.labelIdx, this.location);\n    }\n\n    public optimize(e: Emitter): void {\n        this.expression = this.expression.fold();\n        this.expression.optimize(e);\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WExpression} from \"../expression/wexpression\";\nimport {Control, WType} from \"../tool/constant\";\nimport {WStatement} from \"./wstatement\";\n\nexport class WIfElseBlock extends WStatement {\n    public condition: WExpression;\n    public consequence: WStatement[];\n    public alternative: WStatement[] | null;\n\n    constructor(condition: WExpression, consequence: WStatement[],\n                alternative: WStatement[] | null, location: SourceLocation) {\n        super(location);\n        this.condition = condition;\n        this.consequence = consequence;\n        this.alternative = alternative;\n    }\n\n    public emit(e: Emitter): void {\n        this.condition.emit(e);\n        e.emitIns(Control.if, WType.u8, 0x40, this.location);\n        this.consequence.map((stmt) => stmt.emit(e));\n        if (this.alternative !== null) {\n            e.emitIns(Control.else, WType.none, 0, this.location);\n            this.alternative.map((stmt) => stmt.emit(e));\n        }\n        e.emitIns(Control.end, WType.none, 0, this.location);\n    }\n\n    public optimize(e: Emitter): void {\n        this.condition = this.condition.fold();\n        this.condition.optimize(e);\n        this.consequence.map((x) => x.optimize(e));\n        if (this.alternative !== null) {\n            this.alternative.map((x) => x.optimize(e));\n        }\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WExpression} from \"../expression/wexpression\";\nimport {Control, WType} from \"../tool/constant\";\nimport {WStatement} from \"./wstatement\";\n\nexport class WDrop extends WStatement {\n    public value: WExpression;\n\n    constructor(value: WExpression, location: SourceLocation) {\n        super(location);\n        this.value = value;\n    }\n\n    public emit(e: Emitter): void {\n        this.value.emit(e);\n        e.emitIns(Control.drop, WType.none, 0, this.location);\n    }\n\n    public optimize(e: Emitter): void {\n        this.value = this.value.fold();\n        this.value.optimize(e);\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {JSONEmitter} from \"../emitter/json_emitter\";\nimport {I32, WType} from \"../tool/constant\";\nimport {WExpression, WMemoryLocation} from \"./wexpression\";\n\nexport class WGetAddress extends WExpression {\n    public form: WMemoryLocation;\n    public offset: number;\n    public offsetName: string;\n\n    constructor(form: WMemoryLocation, location: SourceLocation) {\n        super(location);\n        this.form = form;\n        this.offset = 0;\n        this.offsetName = \"\";\n    }\n\n    public emit(e: Emitter): void {\n        let offset = this.offset;\n        if ( this.form === WMemoryLocation.DATA ) {\n            offset += e.ctx.getCurrentFunc().dataStart;\n        } else if ( this.form === WMemoryLocation.BSS ) {\n            offset += e.ctx.getCurrentFunc().bssStart;\n        } else if ( this.form === WMemoryLocation.EXTERN ) {\n            offset += e.ctx.getExternLocation(this.offsetName);\n        }\n        e.emitIns(I32.const, WType.u32, offset, this.location);\n        if (e instanceof JSONEmitter) {\n            e.memoryInfo.push([e.insBuffer.length, this.form, this.offset]);\n        }\n    }\n\n    public deduceType(e: Emitter): WType {\n        return WType.i32;\n    }\n\n    public fold(): WExpression {\n        return this;\n    }\n\n    public isPure(): boolean {\n        return true;\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {I32, WType} from \"../tool/constant\";\nimport {WExpression} from \"./wexpression\";\n\nexport class WGetFunctionAddress extends WExpression {\n    public name: string;\n\n    constructor(name: string, location: SourceLocation) {\n        super(location);\n        this.name = name;\n    }\n\n    public emit(e: Emitter): void {\n        e.emitIns(I32.const, WType.u32, e.ctx.getFuncInfo(this.name).id, this.location);\n    }\n\n    public deduceType(e: Emitter): WType {\n        return WType.i32;\n    }\n\n    public isPure(): boolean {\n        return true;\n    }\n}\n","import {EmitError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {Control, WType} from \"../tool/constant\";\nimport {WExpression} from \"./wexpression\";\n\nexport class WGetGlobal extends WExpression {\n    public type: WType;\n    public name: string;\n\n    constructor(type: WType, name: string, location: SourceLocation) {\n        super(location);\n        this.type = type;\n        this.name = name;\n    }\n\n    public emit(e: Emitter): void {\n        e.emitIns(Control.get_global, WType.u32, e.ctx.getGlobalInfo(this.name).id, this.location);\n    }\n\n    public deduceType(e: Emitter): WType {\n        if ( this.type !== e.ctx.getGlobalInfo(this.name).type) {\n            throw new EmitError(`type mismatch at getglobal`);\n        }\n        return this.type;\n    }\n\n    public isPure(): boolean {\n        return true;\n    }\n}\n","import {EmitError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WType} from \"../tool/constant\";\nimport {WExpression} from \"./wexpression\";\n\nexport class WEmptyExpression extends WExpression {\n\n    constructor(location: SourceLocation) {\n        super(location);\n    }\n\n    public deduceType(e: Emitter): WType {\n        throw new EmitError(`internal error`);\n    }\n\n    public emit(e: Emitter): void {\n        throw new EmitError(`internal error`);\n    }\n\n    public isPure(): boolean {\n        throw new EmitError(`internal error`);\n    }\n\n}\n","import {EmitError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WStatement} from \"../statement/wstatement\";\nimport {WType} from \"../tool/constant\";\nimport {WExpression} from \"./wexpression\";\n\nexport class WFakeExpression extends WExpression {\n    public statement: WStatement;\n\n    constructor(statement: WStatement, location: SourceLocation) {\n        super(location);\n        this.statement = statement;\n    }\n\n    public deduceType(e: Emitter): WType {\n        throw new EmitError(`internal error`);\n    }\n\n    public emit(e: Emitter): void {\n        this.statement.emit(e);\n    }\n\n    public isPure(): boolean {\n        return false;\n    }\n}\n","import * as Long from \"long\";\nimport {EmitError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {doLongUnaryCompute, doUnaryCompute} from \"../tool/calculator\";\nimport {getNativeType, OpTypeMap, UnaryOperator, WType} from \"../tool/constant\";\nimport {WConst} from \"./wconst\";\nimport {WExpression} from \"./wexpression\";\n\nexport class WUnaryOperation extends WExpression {\n    public ope: UnaryOperator;\n    public operand: WExpression;\n\n    constructor(ope: UnaryOperator, operand: WExpression, location: SourceLocation) {\n        super(location);\n        this.ope = ope;\n        this.operand = operand;\n    }\n\n    public emit(e: Emitter): void {\n        this.operand.emit(e);\n        e.emitIns(this.ope, WType.none, 0, this.location);\n    }\n\n    public deduceType(e: Emitter): WType {\n        if ( getNativeType(this.operand.deduceType(e)) !== OpTypeMap.get(this.ope)) {\n            throw new EmitError(`type mismatch at unary ope`);\n        }\n        return this.operand.deduceType(e);\n    }\n\n    public fold(): WExpression {\n        this.operand = this.operand.fold();\n        if (this.operand instanceof WConst) {\n            const type = OpTypeMap.get(this.ope)!;\n            if (type === WType.f32 || type === WType.f64) {\n                return new WConst(type,\n                    doUnaryCompute(this.ope,\n                        parseFloat(this.operand.constant)).toString(), this.location);\n            } else if (type === WType.i32) {\n                return new WConst(type,\n                    doUnaryCompute(this.ope,\n                        parseInt(this.operand.constant)).toString(), this.location);\n            } else {\n                return new WConst(type,\n                    doLongUnaryCompute(this.ope,\n                        Long.fromString(this.operand.constant)).toString(), this.location);\n            }\n        } else {\n            return this;\n        }\n    }\n\n    public isPure(): boolean {\n        return this.operand.isPure();\n    }\n}\n","import {EmitError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {Control, getNativeType, WType} from \"../tool/constant\";\nimport {WExpression} from \"./wexpression\";\n\nexport class WConditionalExpression extends WExpression {\n    public condition: WExpression;\n    public consequence: WExpression;\n    public alternative: WExpression;\n\n    constructor(condition: WExpression, consequence: WExpression,\n                alternative: WExpression, location: SourceLocation) {\n        super(location);\n        this.condition = condition;\n        this.consequence = consequence;\n        this.alternative = alternative;\n    }\n\n    public deduceType(e: Emitter): WType {\n        const l = this.consequence.deduceType(e);\n        const r = this.alternative.deduceType(e);\n        if (getNativeType(l) === getNativeType(r)) {\n            return getNativeType(l);\n        } else {\n            throw new EmitError(`type mismatch at contional expression`);\n        }\n    }\n    public isPure(): boolean {\n        return this.condition.isPure() && this.alternative.isPure() &&\n            this.alternative.isPure();\n    }\n\n    public emit(e: Emitter): void {\n        this.condition.emit(e);\n        e.emitIns(Control.if, WType.u8, this.deduceType(e), this.location);\n        this.consequence.emit(e);\n        e.emitIns(Control.else, WType.none, 0, this.location);\n        this.alternative.emit(e);\n        e.emitIns(Control.end, WType.none, 0,  this.location);\n\n    }\n    public optimize(e: Emitter): void {\n        this.condition = this.condition.fold();\n        this.condition.optimize(e);\n        this.alternative = this.alternative.fold();\n        this.alternative.optimize(e);\n        this.consequence = this.consequence.fold();\n        this.consequence.optimize(e);\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {Control, WType} from \"../tool/constant\";\nimport {WExpression} from \"./wexpression\";\n\nexport class WGetLocal extends WExpression {\n    public type: WType;\n    public offset: number;\n\n    constructor(type: WType, offset: number, location: SourceLocation) {\n        super(location);\n        this.type = type;\n        this.offset = offset;\n    }\n\n    public emit(e: Emitter): void {\n        e.emitIns(Control.get_local, WType.u32, this.offset, this.location);\n    }\n\n    public deduceType(e: Emitter): WType {\n        return this.type;\n    }\n    public isPure(): boolean {\n        return true;\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {WFunctionType} from \"../section/wfunction_type\";\nimport {WStatement} from \"../statement/wstatement\";\nimport {Control, WType} from \"../tool/constant\";\nimport {WExpression} from \"./wexpression\";\n\nexport class WCallIndirect extends WExpression {\n    public target: WExpression;\n    public argument: WExpression[];\n    public afterStatements: WStatement[];\n    public typeEncoding: string;\n\n    constructor(target: WExpression, typeEncoding: string, argument: WExpression[],\n                afterStatements: WStatement[], location: SourceLocation) {\n        super(location);\n        this.target = target;\n        this.typeEncoding = typeEncoding;\n        this.argument = argument;\n        this.afterStatements = afterStatements;\n    }\n\n    public emit(e: Emitter): void {\n        this.argument.map((x) => x.emit(e));\n        this.target.emit(e);\n        e.emitIns(Control.call_indirect, WType.u8, e.ctx.getTypeIdxFromEncoding(this.typeEncoding),\n            this.location);\n        e.writeByte(0x00);\n        this.afterStatements.map((x) => x.emit(e));\n    }\n    public deduceType(e: Emitter): WType {\n        if (this.typeEncoding.charAt(0) === \"v\") {\n            return WType.none;\n        } else {\n            return WFunctionType.s2n(this.typeEncoding.charAt(0));\n        }\n    }\n\n    public fold(): WExpression {\n        this.argument = this.argument.map((x) => x.fold());\n        return this;\n    }\n\n    public isPure(): boolean {\n        return false;\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {F32, F64, I32, I32Binary, I64, WType} from \"../tool/constant\";\nimport {WBinaryOperation} from \"./wbinary_operation\";\nimport {WConst} from \"./wconst\";\nimport {WExpression, WMemoryLocation} from \"./wexpression\";\nimport {JSONEmitter} from \"../emitter/json_emitter\";\n\nexport class WLoad extends WExpression {\n    public type: WType;\n    public address: WExpression;\n    public offset: number;\n    public offsetName: string;\n    public form: WMemoryLocation;\n\n    constructor(type: WType, address: WExpression,\n                form: WMemoryLocation = WMemoryLocation.RAW, location: SourceLocation) {\n        super(location);\n        this.type = type;\n        this.address = address;\n        this.form = form;\n        this.offset = 0;\n        this.offsetName = \"\";\n    }\n\n    public getOp() {\n        switch (this.type) {\n            case WType.u8: return I32.load8_u;\n            case WType.u16: return I32.load16_u;\n            case WType.i8: return I32.load8_s;\n            case WType.i16: return I32.load16_s;\n            case WType.i32:\n            case WType.u32: return I32.load;\n            case WType.f32: return F32.load;\n            case WType.f64: return F64.load;\n            case WType.i64:\n            case WType.u64: return I64.load;\n        }\n    }\n\n    public emit(e: Emitter): void {\n        let offset = this.offset;\n        if ( this.form === WMemoryLocation.DATA ) {\n            offset += e.ctx.getCurrentFunc().dataStart;\n        } else if ( this.form === WMemoryLocation.BSS ) {\n            offset += e.ctx.getCurrentFunc().bssStart;\n        } else if ( this.form === WMemoryLocation.EXTERN ) {\n            offset += e.ctx.getExternLocation(this.offsetName);\n        }\n        if ( offset < 0 ) {\n            this.replaceAddress();\n            offset = 0;\n        }\n        this.address.emit(e);\n        e.emitIns(this.getOp() as number, WType.u32, offset, this.location, true);\n        if(e instanceof JSONEmitter){\n            e.memoryInfo.push([e.insBuffer.length, this.form, this.offset]);\n        }\n    }\n\n    public replaceAddress() {\n        this.address = new WBinaryOperation(I32Binary.add,\n            this.address,\n            new WConst(WType.i32, this.offset.toString(), this.location),\n            this.location);\n        this.offset = 0;\n    }\n\n    public deduceType(e: Emitter): WType {\n        return this.type;\n    }\n\n    public fold(): WExpression {\n        this.address = this.address.fold();\n        return this;\n    }\n\n    public isPure(): boolean {\n        return this.address.isPure();\n    }\n}\n","import {Control, Emitter, getNativeType, WExpression, WFakeExpression, WStatement, WType} from \"..\";\nimport {EmitError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\n\nexport class WCall extends WExpression {\n    public target: string;\n    public argument: WExpression[];\n    public afterStatements: WStatement[];\n\n    constructor(target: string, argument: WExpression[], afterStatements: WStatement[], location: SourceLocation) {\n        super(location);\n        this.target = target;\n        this.argument = argument;\n        this.afterStatements = afterStatements;\n    }\n\n    public emit(e: Emitter): void {\n        this.argument.map((x) => x.emit(e));\n        e.emitIns(Control.call, WType.u32, e.ctx.getFuncInfo(this.target).id, this.location);\n        this.afterStatements.map((x) => x.emit(e));\n    }\n\n    public deduceType(e: Emitter): WType {\n        const funcType = e.ctx.getFuncInfo(this.target).type;\n        const arguTypes = this.argument\n            .filter((x) => ! (x instanceof WFakeExpression))\n            .map((x) => x.deduceType(e));\n        if (funcType.parameters.map((x) => getNativeType(x)).join(\",\")\n            !== arguTypes.map((x) => getNativeType(x)).join(\",\")) {\n            throw new EmitError(`type mismatch at call`);\n        }\n        if (funcType.returnTypes.length === 0) {\n            return WType.none;\n        } else {\n            return funcType.returnTypes[0];\n        }\n    }\n\n    public fold(): WExpression {\n        this.argument = this.argument.map((x) => x.fold());\n        return this;\n    }\n\n    public isPure(): boolean {\n        return false;\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Emitter} from \"../emitter/emitter\";\nimport {ConvertOperator, WType} from \"../tool/constant\";\nimport {WConst} from \"./wconst\";\nimport {WExpression} from \"./wexpression\";\n\nexport class WCovertOperation extends WExpression {\n    public srcType: WType;\n    public dstType: WType;\n    public ope: ConvertOperator;\n    public operand: WExpression;\n\n    constructor(srcType: WType, dstType: WType, operand: WExpression, ope: ConvertOperator, location: SourceLocation) {\n        super(location);\n        this.srcType = srcType;\n        this.dstType = dstType;\n        this.operand = operand;\n        this.ope = ope;\n    }\n\n    public emit(e: Emitter): void {\n        this.operand.emit(e);\n        e.emitIns(this.ope, WType.none, 0, this.location);\n    }\n\n    public deduceType(e: Emitter): WType {\n        return this.dstType;\n    }\n\n    public fold(): WExpression {\n        this.operand = this.operand.fold();\n        if (this.operand instanceof WConst) {\n            if ( this.dstType === WType.f32 || this.dstType === WType.f64) {\n                this.operand.constant = parseFloat(this.operand.constant).toString();\n            } else {\n                this.operand.constant = parseInt(this.operand.constant).toString();\n            }\n            this.operand.type = this.dstType;\n            return this.operand;\n        } else {\n            return this;\n        }\n    }\n\n    public isPure(): boolean {\n        return this.operand.isPure();\n    }\n\n}\n","import {SourceLocation} from \"../common/node\";\nimport {Emitter} from \"./emitter/emitter\";\nimport {WNode} from \"./node\";\nimport {WCodeSection} from \"./section/wcode_section\";\nimport {WDataSection} from \"./section/wdata_section\";\nimport {WDataSegment} from \"./section/wdata_segment\";\nimport {WElementSection} from \"./section/welement_section\";\nimport {WExportFunction} from \"./section/wexport_function\";\nimport {WExportSection} from \"./section/wexport_section\";\nimport {WFunction} from \"./section/wfunction\";\nimport {WFunctionSection} from \"./section/wfunction_section\";\nimport {WFunctionType} from \"./section/wfunction_type\";\nimport {WGlobalSection} from \"./section/wglobal_section\";\nimport {WGlobalVariable} from \"./section/wglobal_variable\";\nimport {WImportFunction} from \"./section/wimport_function\";\nimport {WImportItem} from \"./section/wimport_item\";\nimport {WImportSection} from \"./section/wimport_section\";\nimport {WMemorySection} from \"./section/wmemory_section\";\nimport {WTable} from \"./section/wtable\";\nimport {WTableSection} from \"./section/wtable_section\";\nimport {WTypeSection} from \"./section/wtype_section\";\n\nexport interface WModuleConfig {\n    functions: WFunction[];\n    imports: WImportItem[];\n    exports: string[];\n    globals: WGlobalVariable[];\n    data: WDataSegment[];\n    generateMemory: boolean;\n    requiredFuncTypes: string[];\n}\n\nexport class WModule extends WNode {\n    public typeSection: WTypeSection;\n    public importSection: WImportSection;\n    public functionSection: WFunctionSection;\n    public memorySection: WMemorySection;\n    public globalSection: WGlobalSection;\n    public exportSection: WExportSection;\n    public codeSection: WCodeSection;\n    public dataSection: WDataSection;\n    public tableSection: WTableSection;\n    public elementSection: WElementSection;\n    public generateMemory: boolean;\n    public functions: WFunction[];\n    public importFunctions: WImportFunction[];\n    public funcTypes: WFunctionType[];\n\n    constructor(config: WModuleConfig, location: SourceLocation) {\n        super(location);\n\n        this.functions = config.functions;\n\n        this.funcTypes = [];\n        this.importFunctions =\n            config.imports.filter((x) => x instanceof WImportFunction)\n                .map((x) => x as WImportFunction);\n\n        for (const func of [...this.importFunctions, ...config.functions]) {\n            func.signatureId = this.funcTypes.length;\n            this.funcTypes.push(func.type);\n        }\n\n        const funcLen = this.funcTypes.length;\n        for (const encoding of config.requiredFuncTypes) {\n            this.funcTypes.push(WFunctionType.fromEncoding(encoding, this.location));\n        }\n\n        this.generateMemory = config.generateMemory;\n\n        const exports = config.exports.map((x) => new WExportFunction(x, this.location));\n\n        this.globalSection = new WGlobalSection(config.globals, this.location);\n        this.importSection = new WImportSection(config.imports, this.location);\n        this.memorySection = new WMemorySection([[2, null]], this.location);\n        this.functionSection = new WFunctionSection(config.functions, this.location);\n        this.typeSection = new WTypeSection(this.funcTypes, this.location);\n        this.codeSection = new WCodeSection(config.functions, this.location);\n        this.exportSection = new WExportSection(exports, this.location);\n        this.dataSection = new WDataSection(config.data, this.location);\n        this.tableSection = new WTableSection([new WTable(funcLen, this.location)], this.location);\n        this.elementSection = new WElementSection(funcLen, this.location);\n    }\n\n    public emit(e: Emitter): void {\n        e.writeBytes([0x00, 0x61, 0x73, 0x6D]);\n        e.writeBytes([0x01, 0x00, 0x00, 0x00]);\n        this.typeSection.emit(e);\n        this.importSection.emit(e);\n        this.functionSection.emit(e);\n        this.tableSection.emit(e);\n        if (this.generateMemory) {\n            this.memorySection.emit(e);\n        }\n        this.globalSection.emit(e);\n        this.exportSection.emit(e);\n        this.elementSection.emit(e);\n        this.codeSection.emit(e);\n        this.dataSection.emit(e);\n    }\n\n    public optimize(e: Emitter): void {\n        this.codeSection.optimize(e);\n    }\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 10/07/2018\n */\nimport {WType} from \"./tool/constant\";\n\nexport const i32 = WType.i32;\nexport const i64 = WType.i64;\nexport const f32 = WType.f32;\nexport const f64 = WType.f64;\nexport const u32 = WType.u32;\nexport const u64 = WType.u64;\nexport const i8 = WType.i8;\nexport const u8 = WType.u8;\nexport const i16 = WType.i16;\nexport const u16 = WType.u16;\n\nexport * from \"./section/wcode_section\";\nexport * from \"./section/wexport_section\";\nexport * from \"./section/wimport_memory\";\nexport * from \"./section/wfunction\";\nexport * from \"./section/wimport_section\";\nexport * from \"./section/wdata_section\";\nexport * from \"./section/wexport_function\";\nexport * from \"./section/wfunction_type\";\nexport * from \"./section/wmemory_section\";\nexport * from \"./section/wfunction_section\";\nexport * from \"./section/wtable\";\nexport * from \"./section/wglobal_variable\";\nexport * from \"./section/welement_section\";\nexport * from \"./section/wimport_item\";\nexport * from \"./section/wimport_function\";\nexport * from \"./section/wsection\";\nexport * from \"./section/wtype_section\";\nexport * from \"./section/welement\";\nexport * from \"./section/wtable_section\";\nexport * from \"./section/wglobal_section\";\nexport * from \"./section/wdata_segment\";\nexport * from \"./emitter/emitter\";\nexport * from \"./emitter/emitter_context\";\nexport * from \"./emitter/wasm_emitter\";\nexport * from \"./emitter/json_emitter\";\nexport * from \"./statement/wreturn\";\nexport * from \"./statement/wstore\";\nexport * from \"./statement/wbr\";\nexport * from \"./statement/wexpr_statement\";\nexport * from \"./statement/wblock\";\nexport * from \"./statement/wset_local\";\nexport * from \"./statement/wset_global\";\nexport * from \"./statement/wloop\";\nexport * from \"./statement/wbr_if\";\nexport * from \"./statement/wif_else_block\";\nexport * from \"./statement/wstatement\";\nexport * from \"./statement/wdrop\";\nexport * from \"./expression/wget_address\";\nexport * from \"./expression/wget_function_address\";\nexport * from \"./expression/wexpression\";\nexport * from \"./expression/wget_global\";\nexport * from \"./expression/wempty_expression\";\nexport * from \"./expression/wfake_expression\";\nexport * from \"./expression/wunary_operation\";\nexport * from \"./expression/wbinary_operation\";\nexport * from \"./expression/wconst\";\nexport * from \"./expression/wconditional_expression\";\nexport * from \"./expression/wget_local\";\nexport * from \"./expression/wcall_indirect\";\nexport * from \"./expression/wload\";\nexport * from \"./expression/wcall\";\nexport * from \"./expression/wcovert_operation\";\nexport * from \"./tool/constant\";\nexport * from \"./module\";","import {InternalError} from \"../common/error\";\nimport {WType} from \"../wasm\";\nimport {Type} from \"./index\";\n\nexport class TemplateType extends Type {\n    public get length(): number {\n        throw new InternalError(\"undefined behavior\");\n    }\n\n    public static instance: TemplateType;\n\n    public toMangledName(): string {\n        throw new InternalError(\"undefined behavior\");\n    }\n\n    public toWType(): WType {\n        throw new InternalError(\"undefined behavior\");\n    }\n\n    public toString(): string {\n        throw new InternalError(\"undefined behavior\");\n    }\n}\nTemplateType.instance = new TemplateType();\n\nexport class TemplateParameterPlaceHolderType extends Type {\n    public index: number;\n\n    constructor(index: number) {\n        super();\n        this.index = index;\n    }\n\n    public get length(): number {\n        throw new InternalError(\"undefined behavior\");\n    }\n\n    public toMangledName(): string {\n        return \"^\" + this.index;\n    }\n\n    public toWType(): WType {\n        throw new InternalError(\"undefined behavior\");\n    }\n\n    public toString(): string {\n        return \"^\" + this.index;\n    }\n}\n","import {ClassSpecifier} from \"../codegen/class/class_specifier\";\nimport {FunctionConfig} from \"../codegen/function/function\";\nimport {FunctionDefinition} from \"../codegen/function/function_definition\";\nimport {ScopeContext} from \"../codegen/scope\";\nimport {AccessControl, Type} from \"../type\";\nimport {ClassType} from \"../type/class_type\";\nimport {TemplateType} from \"../type/template_type\";\nimport {FunctionEntity, OverloadSymbol, Symbol} from \"./symbol\";\n\nexport interface TemplateParameter {\n    name: string;\n    type: Type;\n    init: Type | string | null;\n}\n\nexport class FunctionTemplate extends OverloadSymbol {\n    public shortName: string;\n    public fullName: string;\n    public functionConfig: FunctionConfig;\n    public templateParams: TemplateParameter[];\n    public functionBody: FunctionDefinition;\n    public instanceMap: Map<string, FunctionEntity>;\n    public specializationMap: Map<string, FunctionDefinition>;\n    public scopeContext: ScopeContext;\n\n    constructor(shortName: string, fullName: string, functionConfig: FunctionConfig,\n                templateParams: TemplateParameter[], functionBody: FunctionDefinition,\n                scopeContext: ScopeContext, accessControl: AccessControl) {\n        super(accessControl);\n        this.shortName = shortName;\n        this.fullName = fullName;\n        this.functionConfig = functionConfig;\n        this.templateParams = templateParams;\n        this.functionBody = functionBody;\n        this.instanceMap = new Map<string, FunctionEntity>();\n        this.specializationMap = new Map<string, FunctionDefinition>();\n        this.scopeContext = scopeContext;\n    }\n\n    public getType(): Type {\n        return TemplateType.instance;\n    }\n\n    public isDefine(): boolean {\n        return true;\n    }\n\n    public getFullName(): string {\n        return this.fullName;\n    }\n\n    public getIndexName(): string {\n        return this.shortName.split(\"@\")[0];\n    }\n}\n\nexport class ClassTemplate extends Symbol {\n    public shortName: string;\n    public fullName: string;\n    public fileName: string;\n    public templateParams: TemplateParameter[];\n    public classBody: ClassSpecifier;\n    public specializationMap: Map<string, ClassSpecifier>;\n    public scopeContext: ScopeContext;\n    constructor(shortName: string, fullName: string, fileName: string,\n                templateParams: TemplateParameter[], classBody: ClassSpecifier,\n                scopeContext: ScopeContext, accessControl: AccessControl) {\n        super(accessControl);\n        this.templateParams = templateParams;\n        this.classBody = classBody;\n        this.shortName = shortName;\n        this.fileName = fileName;\n        this.fullName = fullName;\n        this.specializationMap = new Map<string, ClassSpecifier>();\n        this.scopeContext = scopeContext;\n    }\n\n    public getType(): Type {\n        return TemplateType.instance;\n    }\n\n    public isDefine(): boolean {\n        return true;\n    }\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 05/08/2018\n */\n\nimport {CompileContext} from \"../codegen/context\";\nimport {ObjectInitializer} from \"../codegen/declaration/object_initializer\";\nimport {Expression} from \"../codegen/expression/expression\";\nimport {FunctionLookUpResult} from \"../codegen/scope\";\nimport {InternalError} from \"../common/error\";\nimport {Variable} from \"../common/symbol\";\nimport {ClassTemplate} from \"../common/template\";\nimport {WType} from \"../wasm\";\nimport {AccessControl, Type} from \"./index\";\n\nexport interface ClassField {\n    name: string;\n    type: Type;\n    startOffset: number;\n    initializer: Expression | ObjectInitializer | null;\n    accessControl: AccessControl;\n}\n\nexport interface Inheritance {\n    classType: ClassType;\n    accessControl: AccessControl;\n}\n\nexport interface VirtualTableItem {\n    indexName: string;\n    fullName: string;\n}\n\nexport interface VirtualTable {\n    className: string;\n    vFunctions: VirtualTableItem[];\n}\n\nexport class ClassType extends Type {\n\n    public shortName: string;\n    public fullName: string;\n    public fileName: string;\n\n    public fields: ClassField[];\n    public fieldMap: Map<string, ClassField>;\n\n    public isUnion: boolean;\n    public isComplete: boolean;\n    public inheritance: Inheritance[];\n\n    // only use in build\n    public accessControl: AccessControl;\n\n    // fill in initialize\n    public selfSize: number;\n    public objectSize: number;\n\n    // vptr settings\n    public requireVPtr: boolean;\n    public VPtrOffset: number;\n    public vTable: VirtualTable;\n    public vTablePtr: number;\n\n    constructor(shortName: string, fullName: string, fileName: string,\n                fields: ClassField[], isUnion: boolean, inheritance: Inheritance[]) {\n        super();\n        this.shortName = shortName;\n        this.fileName = fileName;\n        this.fullName = fullName;\n        this.fields = fields;\n        this.isComplete = false;\n        this.fieldMap = new Map<string, ClassField>();\n        this.isUnion = isUnion;\n        this.inheritance = inheritance;\n        this.selfSize = 0;\n        this.vTablePtr = 0;\n        this.objectSize = this.inheritance.map(\n            (x) => x.classType.length).reduce((x, y) => x + y, 0);\n        this.requireVPtr = false;\n        this.VPtrOffset = 0;\n        this.accessControl = AccessControl.Public;\n        this.vTable = {\n            className: fullName,\n            vFunctions: [],\n        };\n    }\n\n    public initialize() {\n        this.fieldMap = new Map<string, ClassField>(\n            this.fields.map((x) => [x.name, x] as [string, ClassField]));\n        if (this.isUnion) {\n            this.selfSize = Math.max(...this.fields\n                .map((field) => field.type.length));\n        } else {\n            this.selfSize = this.fields\n                .map((field) => field.type.length)\n                .reduce((x, y) => x + y, 0);\n        }\n        if (this.requireVPtr) {\n            this.selfSize += 4;\n        }\n        this.objectSize = this.selfSize + this.inheritance.map(\n            (x) => x.classType.length).reduce((x, y) => x + y, 0);\n        this.isComplete = true;\n    }\n\n    get length(): number {\n        if (!this.isComplete) {\n            throw new InternalError(`class ${this.shortName} is incomplete`);\n        }\n        return this.objectSize;\n    }\n\n    public toWType(): WType {\n        throw new InternalError(`could not to Wtype of func`);\n    }\n\n    public toString() {\n        return this.shortName;\n    }\n\n    public toMangledName() {\n        return \"$\" + this.fullName.replace(/::/g, \"!!\") + \"$\";\n    }\n\n    public isDefine(): boolean {\n        return this.isComplete;\n    }\n\n    public equals(type: Type): boolean {\n        return type === this;\n    }\n\n    public isSubClassOf(type: ClassType): boolean {\n        for (const item of this.inheritance) {\n            if (item.classType.isSubClassOf(type)) {\n                return true;\n            }\n        }\n        return type === this;\n    }\n\n    public compatWith(type: Type): boolean {\n        return type === this || (\n            type instanceof ClassType && (\n                type.isSubClassOf(this) || this.isSubClassOf(type)\n            ));\n    }\n\n    public getField(name: string): ClassField | null {\n        if (!this.isComplete) {\n            throw new InternalError(`class ${this.shortName} is incomplete`);\n        }\n        const item = this.fieldMap.get(name);\n        if (item) {\n            return item;\n        }\n        for (const obj of this.inheritance) {\n            const subItem = obj.classType.getField(name);\n            if (subItem) {\n                return subItem;\n            }\n        }\n        return null;\n    }\n\n    public getMember(ctx: CompileContext, name: string): ClassField | Variable | FunctionLookUpResult | null {\n        const item = ctx.scopeManager.lookup(this.fullName + \"::\" + name);\n        if (item !== null) {\n            if (item instanceof Type || item instanceof ClassTemplate) {\n                return null;\n            } else {\n                return item;\n            }\n        }\n        const field = this.fieldMap.get(name);\n        if ( field ) {\n            return field;\n        }\n        for (const obj of this.inheritance) {\n            const subItem = obj.classType.getMember(ctx, name);\n            if (subItem) {\n                return subItem;\n            }\n        }\n        return null;\n    }\n\n    public setUpVPtr() {\n        let off = 0;\n        for (const parent of this.inheritance) {\n            if (parent.classType.requireVPtr) {\n                this.requireVPtr = true;\n                this.VPtrOffset = parent.classType.VPtrOffset + off;\n                parent.classType.vTable.vFunctions.map((item) =>\n                    this.vTable.vFunctions.push({\n                    indexName: item.indexName,\n                    fullName: item.fullName,\n                }));\n                break;\n            }\n            off += parent.classType.objectSize;\n        }\n        if ( !this.requireVPtr ) {\n            this.requireVPtr = true;\n            this.VPtrOffset = this.objectSize;\n            this.objectSize += 4;\n            this.selfSize += 4;\n        }\n    }\n\n    public registerVFunction(ctx: CompileContext, indexName: string, fullName: string) {\n        const oldItems = this.vTable.vFunctions.filter((x) => x.indexName === indexName);\n        if ( oldItems.length === 0) {\n            this.vTable.vFunctions.push({\n                indexName,\n                fullName,\n            });\n        } else {\n            oldItems[0].fullName = fullName;\n        }\n    }\n\n    public getVCallInfo(indexName: string): [number, number] | null {\n        for (let i = 0; i < this.vTable.vFunctions.length; i++) {\n            if ( this.vTable.vFunctions[i].indexName === indexName) {\n                return [this.VPtrOffset, i * 4];\n            }\n        }\n        let nowOffset = 0;\n        for ( const parent of this.inheritance ) {\n            const vFuncs = parent.classType.vTable.vFunctions;\n            for (let i = 0; i < vFuncs.length; i++) {\n                if ( vFuncs[i].indexName === indexName) {\n                    return [parent.classType.VPtrOffset, i * 4];\n                }\n            }\n            nowOffset += parent.classType.objectSize;\n        }\n        return null;\n    }\n}\n","import {WType} from \"../wasm\";\nimport {Type} from \"./index\";\n\n/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 05/08/2018\n */\n\nexport abstract class PrimitiveType extends Type {\n\n    public compatWith(type: Type): boolean {\n        return type instanceof PrimitiveType;\n    }\n}\n\nexport class VoidType extends PrimitiveType {\n    get length(): number {\n        return 1;\n    }\n\n    public toWType() {\n        return WType.i32;\n    }\n\n    public toMangledName(): string {\n        return \"v\";\n    }\n\n    public toString() {\n        return \"void\";\n    }\n}\n\nexport class NullptrType extends PrimitiveType {\n    get length(): number {\n        return 1;\n    }\n\n    public toWType() {\n        return WType.i32;\n    }\n\n    public toMangledName(): string {\n        return \"nullptr\";\n    }\n\n    public toString() {\n        return \"nullptr\";\n    }\n}\n\nexport abstract class ArithmeticType extends PrimitiveType {\n    public can(type: Type): boolean {\n        return type instanceof ArithmeticType;\n    }\n}\n\nexport abstract class IntegerType extends ArithmeticType {\n\n}\n\nexport abstract class FloatingType extends ArithmeticType {\n}\n\nexport abstract class SignedIntegerType extends IntegerType {\n\n}\n\nexport abstract class UnsignedIntegerType extends IntegerType {\n\n}\n\nexport class BoolType extends UnsignedIntegerType {\n    get length(): number {\n        return 1;\n    }\n\n    public toWType() {\n        return WType.i8;\n    }\n\n    public toMangledName(): string {\n        return \"b\";\n    }\n\n    public toString() {\n        return \"bool\";\n    }\n}\n\n// HACK: Char = Signed Char\nexport class CharType extends SignedIntegerType {\n    get length(): number {\n        return 1;\n    }\n\n    public toWType() {\n        return WType.i8;\n    }\n\n    public toMangledName(): string {\n        return \"c\";\n    }\n\n    public toString() {\n        return \"char\";\n    }\n}\n\nexport class Int16Type extends SignedIntegerType {\n    get length(): number {\n        return 2;\n    }\n\n    public toWType() {\n        return WType.i16;\n    }\n\n    public toMangledName(): string {\n        return \"s\";\n    }\n\n    public toString() {\n        return \"short\";\n    }\n}\n\nexport class Int32Type extends SignedIntegerType {\n    get length(): number {\n        return 4;\n    }\n\n    public toWType() {\n        return WType.i32;\n    }\n\n    public toMangledName(): string {\n        return \"i\";\n    }\n\n    public toString() {\n        return \"int\";\n    }\n}\n\nexport class Int64Type extends SignedIntegerType {\n    get length(): number {\n        return 8;\n    }\n\n    public toWType() {\n        return WType.i64;\n    }\n\n    public toMangledName(): string {\n        return \"l\";\n    }\n\n    public toString() {\n        return \"long long\";\n    }\n}\n\nexport class UnsignedCharType extends UnsignedIntegerType {\n    get length(): number {\n        return 1;\n    }\n\n    public toWType() {\n        return WType.u8;\n    }\n\n    public toMangledName(): string {\n        return \"uc\";\n    }\n\n    public toString() {\n        return \"unsigned char\";\n    }\n}\n\nexport class UnsignedInt16Type extends UnsignedIntegerType {\n    get length(): number {\n        return 2;\n    }\n\n    public toWType() {\n        return WType.u16;\n    }\n\n    public toMangledName(): string {\n        return \"us\";\n    }\n\n    public toString() {\n        return \"unsigned short\";\n    }\n}\n\nexport class UnsignedInt32Type extends UnsignedIntegerType {\n    get length(): number {\n        return 4;\n    }\n\n    public toWType() {\n        return WType.u32;\n    }\n\n    public toMangledName(): string {\n        return \"ui\";\n    }\n\n    public toString() {\n        return \"unsigned int\";\n    }\n}\n\nexport class UnsignedInt64Type extends UnsignedIntegerType {\n    get length(): number {\n        return 8;\n    }\n\n    public toWType() {\n        return WType.u64;\n    }\n\n    public toMangledName(): string {\n        return \"ul\";\n    }\n\n    public toString() {\n        return \"unsigned long long\";\n    }\n}\n\nexport class FloatType extends FloatingType {\n    get length(): number {\n        return 4;\n    }\n\n    public toWType() {\n        return WType.f32;\n    }\n\n    public toMangledName(): string {\n        return \"f\";\n    }\n\n    public toString() {\n        return \"float\";\n    }\n}\n\nexport class DoubleType extends FloatingType {\n    get length(): number {\n        return 8;\n    }\n\n    public toWType() {\n        return WType.f64;\n    }\n\n    public toMangledName(): string {\n        return \"d\";\n    }\n\n    public toString() {\n        return \"double\";\n    }\n}\n\nexport const PrimitiveTypes = {\n    void: new VoidType(),\n    nullptr: new NullptrType(),\n    bool: new BoolType(),\n    char: new CharType(),\n    uchar: new UnsignedCharType(),\n    int16: new Int16Type(),\n    uint16: new UnsignedInt16Type(),\n    int32: new Int32Type(),\n    uint32: new UnsignedInt32Type(),\n    int64: new Int64Type(),\n    uint64: new UnsignedInt64Type(),\n    float: new FloatType(),\n    double: new DoubleType(),\n};\n\nexport const PrimitiveTypesNameMap = new Map<string[][], () => PrimitiveType>([\n    [[[\"void\"]], () => new VoidType()],\n    [[[\"bool\"]], () => new BoolType()],\n    [[[\"char\"], [\"signed\", \"char\"].sort()], () => new CharType()],\n    [[[\"unsigned\", \"char\"].sort()], () => new UnsignedCharType()],\n    [[[\"short\"], [\"signed\", \"short\"].sort(), [\"short\", \"int\"].sort(), [\"signed\", \"short\", \"int\"].sort()],\n        () => new Int16Type()],\n    [[[\"unsigned\", \"short\"].sort(), [\"unsigned\", \"short\", \"int\"].sort()], () => new UnsignedInt16Type()],\n    [[[\"int\"], [\"signed\"], [\"signed\", \"int\"].sort()], () => new Int32Type()],\n    [[[\"unsigned\"], [\"unsigned\", \"int\"].sort()], () => new UnsignedInt32Type()],\n    [[[\"long\"], [\"signed\", \"long\"].sort(), [\"long\", \"int\"].sort(), [\"signed\", \"long\", \"int\"].sort()],\n        () => new Int32Type()],\n    [[[\"unsigned\", \"long\"].sort(), [\"unsigned\", \"long\", \"int\"].sort()], () => new UnsignedInt32Type()],\n    [[[\"long\", \"long\"], [\"signed\", \"long\", \"long\"].sort(), [\"long\", \"long\", \"int\"].sort(),\n        [\"signed\", \"long\", \"long\", \"int\"].sort()], () => new Int64Type()],\n    [[[\"unsigned\", \"long\", \"long\"].sort(), [\"unsigned\", \"long\", \"long\", \"int\"].sort()],\n        () => new UnsignedInt64Type()],\n    [[[\"float\"]], () => new FloatType()],\n    [[[\"double\"]], () => new DoubleType()],\n    // [[['long', 'double'].sort()],                                               PrimitiveTypes.longDouble],\n    [[[\"bool\"]], () => PrimitiveTypes.bool],\n]);\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 05/08/2018\n */\n\nimport {InternalError} from \"../common/error\";\nimport {WType} from \"../wasm\";\nimport {ClassType} from \"./class_type\";\nimport {Type} from \"./index\";\nimport {PrimitiveTypes} from \"./primitive_type\";\n\nconst MACHINE_POINTER_LENGTH = 4;\n\nexport abstract class CompoundType extends Type {\n    public elementType: Type;\n\n    constructor(elementType: Type) {\n        super();\n        this.elementType = elementType;\n    }\n\n    get length() {\n        return MACHINE_POINTER_LENGTH;\n    }\n\n    public equals(type: Type): boolean {\n        return super.equals(type) &&\n            type instanceof CompoundType &&\n            this.elementType.equals(type.elementType);\n    }\n\n    public compatWith(type: Type): boolean {\n        return super.compatWith(type) &&\n            type instanceof CompoundType &&\n            this.elementType.compatWith(type.elementType);\n    }\n}\n\nexport class ConstType extends CompoundType {\n    public toString() {\n        return \"const\" + this.elementType.toString();\n    }\n\n    public toWType() {\n        return this.elementType.toWType();\n    }\n\n    public toMangledName(): string {\n        return \"c\" + this.elementType.toMangledName();\n    }\n\n    public compatWith(type: Type): boolean {\n        return this.elementType.equals(PrimitiveTypes.void)\n            || (type instanceof PointerType && type.elementType.equals(PrimitiveTypes.void))\n            || super.compatWith(type) ||\n            (type instanceof ArrayType && this.elementType.compatWith(type.elementType));\n    }\n}\n\nexport class PointerType extends CompoundType {\n    public toString() {\n        return this.elementType.toString() + \"*\";\n    }\n\n    public toWType() {\n        return WType.u32;\n    }\n\n    public toMangledName(): string {\n        return this.elementType.toMangledName() + \"*\";\n    }\n\n    public compatWith(type: Type): boolean {\n        return this.elementType.equals(PrimitiveTypes.void)\n            || (type instanceof PointerType && type.elementType.equals(PrimitiveTypes.void))\n            || super.compatWith(type) ||\n            (type instanceof ArrayType && this.elementType.compatWith(type.elementType));\n    }\n}\n\nexport abstract class ReferenceType extends CompoundType {\n\n    constructor(elementType: Type) {\n        super(elementType);\n        if (elementType instanceof ReferenceType) {\n            throw new InternalError(`ref to ref is illegal`);\n        }\n    }\n}\n\nexport class LeftReferenceType extends ReferenceType {\n    public toString() {\n        return this.elementType.toString() + \"&\";\n    }\n\n    public toWType() {\n        return WType.u32;\n    }\n\n    public toMangledName(): string {\n        return this.elementType.toMangledName() + \"&\";\n    }\n}\n\nexport class RightReferenceType extends ReferenceType {\n    public toString() {\n        return this.elementType.toString() + \"&&\";\n    }\n\n    public toWType() {\n        return WType.u32;\n    }\n\n    public toMangledName(): string {\n        return this.elementType.toMangledName() + \"&&\";\n    }\n}\n\nexport class ArrayType extends Type {\n\n    public elementType: Type;\n    public size: number;\n\n    constructor(elementType: Type, size: number) {\n        super();\n        this.elementType = elementType;\n        this.size = size;\n    }\n\n    get length() {\n        return this.elementType.length * this.size;\n    }\n\n    public equals(type: Type): boolean {\n        return super.equals(type) &&\n            type instanceof ArrayType &&\n            this.elementType.equals(type.elementType) &&\n            this.size === type.size;\n    }\n\n    public toString() {\n        return this.elementType.toString() + `[${this.length}]`;\n    }\n\n    public toWType(): WType {\n        throw new InternalError(`could not to Wtype of func`);\n    }\n\n    public toMangledName(): string {\n        return this.elementType.toMangledName() + \"[\" + this.size + \"]\";\n    }\n\n    public compatWith(type: Type): boolean {\n        return type.equals(this)\n            || (type instanceof ArrayType && this.elementType.compatWith(type.elementType)\n                || (type instanceof PointerType && type.elementType.equals(this.elementType)))\n            || (this.elementType instanceof ClassType && type instanceof PointerType\n                && type.elementType.compatWith(this.elementType));\n    }\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 16/06/2018\n */\nimport {PrimitiveType, PrimitiveTypesNameMap} from \"../type/primitive_type\";\n\nexport function isArrayEqual(array1: any[], array2: any[]): boolean {\n    if (array1.length !== array2.length) {\n        return false;\n    }\n    if (array1.length === 0) {\n        return true;\n    }\n    if (array1[0].equals) {\n        for (let i = 0; i < array1.length; i++) {\n            if (!array1[i].equals(array2[i])) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        for (let i = 0; i < array1.length; i++) {\n            if (array1[i] !== array2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nexport function getPrimitiveTypeFromSpecifiers(specifierStrings: string[]): PrimitiveType | null {\n    for (const [typeSpecifierStringsArray, primitiveType] of PrimitiveTypesNameMap.entries()) {\n        for (const typeSpecifierStrings of typeSpecifierStringsArray) {\n            if (isArrayEqual(specifierStrings, typeSpecifierStrings)) {\n                return primitiveType();\n            }\n        }\n    }\n    return null;\n}\n\nconst typeSpecifierList = [\"void\", \"bool\", \"char\", \"long\", \"int\", \"unsigned\", \"signed\", \"double\", \"float\", \"short\"];\n\nexport function isTypeSpecifier(key: string) {\n    return typeSpecifierList.indexOf(key) !== -1;\n}\n\nconst typeQualifierList = [\"const\", \"volatile\"];\n\nexport function isTypeQualifier(key: string) {\n    return typeQualifierList.indexOf(key) !== -1;\n}\n\nconst hexchr = \"0123456789ABCDEF\";\n\nexport function toHexString(value: number) {\n    let result = \"\";\n    for (let i = 0; i < 8; i++) {\n        result = hexchr.charAt(value % 16) + result;\n        value = parseInt((value / 16).toString());\n    }\n    if (result.length === 7) {\n        console.log(\"fuck\");\n    }\n    return \"0x\" + result;\n}\n\nexport function fromBytesToString(data: DataView, start: number, size?: number) {\n    let result = \"\";\n    if ( size === undefined) {\n        let i = start, code = data.getUint8(i);\n        while ( code !== 0) {\n            result += String.fromCharCode(code);\n            i ++;\n            code = data.getUint8(i);\n        }\n    } else {\n        for (let i = start; i < start + size; i++) {\n            result += String.fromCharCode(data.getUint8(i));\n        }\n    }\n    return result;\n}\n\nexport function getIndent(indent: number): string {\n    let result = \"\";\n    for (let i = 0; i < indent; i++) { result += \"\\t\"; }\n    return result;\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 05/08/2018\n */\n\nimport {FunctionLookUpResult} from \"../codegen/scope\";\nimport {InternalError} from \"../common/error\";\nimport {isArrayEqual} from \"../common/utils\";\nimport {ClassType} from \"./class_type\";\nimport {ArrayType, PointerType} from \"./compound_type\";\nimport {Type} from \"./index\";\nimport {PrimitiveTypes} from \"./primitive_type\";\nimport {getNativeType, WFunctionType, WType} from \"../wasm\";\n\nexport enum CppFunctionType {\n    Normal,\n    Constructor,\n    Destructor,\n    MemberFunction,\n}\n\nexport class TemplatePlaceholderType extends Type {\n\n    public index: number;\n\n    constructor(index: number) {\n        super();\n        this.index = index;\n    }\n\n    get length(): number {\n        throw new InternalError(\"unexpected\");\n    }\n\n    public toMangledName(): string {\n        return \"^$\" + this.index + \"^\";\n    }\n\n    public toWType(): WType {\n        throw new InternalError(\"unexpected\");\n    }\n\n    public toString(): string {\n        return `[${this.index}]`;\n    }\n}\n\nexport class FunctionType extends Type {\n    // coretype\n    public isVirtual: boolean;\n    public returnType: Type;\n    public parameterTypes: Type[];\n    public variableArguments: boolean;\n    public cppFunctionType: CppFunctionType;\n    public referenceClass: ClassType | null;\n    public isTemplateInstance: boolean;\n\n    constructor(returnType: Type, parameterTypes: Type[], variableArguments: boolean = false) {\n        super();\n        this.returnType = returnType;\n        this.parameterTypes = parameterTypes;\n        this.variableArguments = variableArguments;\n        this.cppFunctionType = CppFunctionType.Normal;\n        this.isVirtual = false;\n        this.referenceClass = null;\n        this.isTemplateInstance = false;\n        for (let i = 0; i < this.parameterTypes.length; i++) {\n            const ty = this.parameterTypes[i];\n            if (ty instanceof ArrayType) {\n                this.parameterTypes[i] = new PointerType(ty.elementType);\n            }\n        }\n    }\n\n    get length(): number {\n        return 0;\n    }\n\n    public equals(type: Type): boolean {\n        return super.equals(type) &&\n            type instanceof FunctionType &&\n            this.returnType.equals(type.returnType) &&\n            isArrayEqual(this.parameterTypes, type.parameterTypes);\n    }\n\n    public toDisplayString(name: string) {\n        if (name.charAt(0) === \"#\") {\n            if (name.charAt(1) === \"$\") {\n                name = name.substring(2);\n            } else {\n                name = \"operator\" + name.substring(1);\n            }\n        }\n        const tokens = name.split(\"@\");\n        if (tokens.length > 2) {\n            name = tokens[0] + \"<\" + tokens[2] + \">\";\n        } else {\n            name = tokens[0];\n        }\n        if (this.cppFunctionType === CppFunctionType.Constructor) {\n            name = this.referenceClass!.shortName + \"::\" + this.referenceClass!.shortName;\n        } else if (this.cppFunctionType === CppFunctionType.Destructor) {\n            name = \"~\" + this.referenceClass!.shortName + \"::\" + this.referenceClass!.shortName;\n        } else if (this.cppFunctionType === CppFunctionType.MemberFunction) {\n            name = this.referenceClass!.shortName + \"::\" + name;\n        }\n        return this.returnType.toString() + \" \" + name + \"(\" +\n            this.parameterTypes.map((x) => x.toString()).join(\", \") + \")\";\n    }\n\n    public toString() {\n        return this.returnType.toString() + \"(\" +\n            this.parameterTypes.map((x) => x.toString()).join(\", \") + \")\";\n    }\n\n    public toWType(): WType {\n        throw new InternalError(`could not to Wtype of func`);\n    }\n\n    public toMangledName(): string {\n        return this.parameterTypes.map((x) => x.toMangledName()).join(\",\");\n    }\n/*\n    public toIndexName(): string {\n        if (this.cppFunctionType === CppFunctionType.Destructor) {\n            return \"~\";\n        }\n        return this.shortName + \"@\" + this.parameterTypes.slice(1).map((x) => x.toMangledName()).join(\",\");\n    }*/\n\n    public compatWith(type: Type): boolean {\n        return type.equals(this);\n    }\n\n    public isMemberFunction(): boolean {\n        return this.cppFunctionType === CppFunctionType.Destructor\n            || this.cppFunctionType === CppFunctionType.MemberFunction;\n    }\n\n    public toWASMEncoding(): string {\n        let result = \"\";\n        if (!this.returnType.equals(PrimitiveTypes.void) && !(this.returnType instanceof ClassType)) {\n            result += WFunctionType.n2s(getNativeType(this.returnType.toWType()));\n        } else {\n            result += \"v\";\n        }\n        this.parameterTypes.filter((ty) => !(ty instanceof ClassType))\n            .map((ty) => result += WFunctionType.n2s(getNativeType(ty.toWType())));\n        return result;\n    }\n}\n\nexport class UnresolvedFunctionOverloadType extends Type {\n\n    public functionLookupResult: FunctionLookUpResult;\n\n    constructor(functionLookupResult: FunctionLookUpResult) {\n        super();\n        this.functionLookupResult = functionLookupResult;\n    }\n\n    public equals(type: Type) {\n        return false;\n    }\n\n    public compatWith(type: Type) {\n        return false;\n    }\n\n    public toString() {\n        return `[UnresolveFunctionOverloadType]`;\n    }\n\n    public get length() {\n        return 0;\n    }\n\n    public toWType(): WType {\n        throw new InternalError(`UnresolveFunctionOverloadType()`);\n    }\n\n    public toMangledName() {\n        return `[UnresolveFunctionOverloadType]`;\n    }\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 15/07/2018\n */\nimport {EmitError, InternalError} from \"../common/error\";\nimport {SourceLocation} from \"../common/node\";\nimport {AddressType} from \"../common/symbol\";\nimport {Type} from \"../type\";\nimport {ClassType} from \"../type/class_type\";\nimport {ArrayType} from \"../type/compound_type\";\nimport {\n    Emitter,\n    getNativeType,\n    I32Binary,\n    WBinaryOperation,\n    WConst, WExpression, WGetAddress, WGetGlobal, WGetLocal,\n    WLoad,\n    WMemoryLocation,\n    WSetGlobal, WSetLocal, WStatement,\n    WStore,\n    WType,\n} from \"../wasm\";\nimport {CompileContext} from \"./context\";\n\nexport class WAddressHolder extends WExpression {\n    public place: number | string | WExpression;\n    public type: AddressType;\n    public offset: number;\n\n    constructor(place: number | string | WExpression, type: AddressType, location: SourceLocation) {\n        super(location);\n        this.place = place;\n        this.type = type;\n        this.offset = 0;\n    }\n\n    public createStore(ctx: CompileContext,\n                       type: Type,\n                       value: WExpression,\n                       requireAlign: boolean = false): WStatement {\n        let result: WStatement | null = null;\n        if ( type instanceof ArrayType || type instanceof ClassType) {\n            throw new InternalError(`could not assign a array or class`);\n        } else {\n            const wtype = requireAlign ? getNativeType(type.toWType()) : type.toWType();\n            switch (this.type) {\n                case AddressType.LOCAL:\n                result = new WSetLocal(\n                    wtype,\n                    this.place as number,\n                    value,\n                    this.location,\n                );\n                if ( this.offset !== 0) {\n                    throw new InternalError(`illegal offset`);\n                }\n                break;\n                case AddressType.MEMORY_DATA:\n                    result = new WStore(\n                        wtype,\n                        new WConst(WType.i32, \"0\", this.location),\n                        value,\n                        WMemoryLocation.DATA,\n                        this.location,\n                    );\n                    (result as WStore).offset = this.place as number + this.offset;\n                    break;\n                case AddressType.MEMORY_BSS:\n                    result = new WStore(\n                        wtype,\n                        new WConst(WType.i32, \"0\", this.location),\n                        value,\n                        WMemoryLocation.BSS,\n                        this.location,\n                    );\n                    (result as WStore).offset = this.place as number + this.offset;\n                    break;\n                case AddressType.MEMORY_EXTERN:\n                    result = new WStore(\n                        wtype,\n                        new WConst(WType.i32, \"0\", this.location),\n                        value,\n                        WMemoryLocation.EXTERN,\n                        this.location,\n                    );\n                    (result as WStore).offset = this.offset;\n                    (result as WStore).offsetName = this.place as string;\n                    break;\n                case AddressType.CONSTANT:\n                    throw new InternalError(`store a constant()`);\n                case AddressType.STACK:\n                    if (ctx.currentFuncContext.currentFunction === null) {\n                        throw new InternalError(`not in function`);\n                    }\n                    result = new WStore(\n                        wtype,\n                        new WGetLocal(WType.i32, ctx.currentFuncContext.currentFunction.$sp, this.location),\n                        value,\n                        WMemoryLocation.RAW,\n                        this.location,\n                    );\n                    (result as WStore).offset = this.place as number + this.offset;\n                    break;\n                case AddressType.GLOBAL:\n                    result = new WSetGlobal(\n                        wtype,\n                        this.place as string,\n                        value,\n                        this.location,\n                    );\n                    if ( this.offset !== 0) {\n                        throw new InternalError(`illegal offset`);\n                    }\n                    break;\n                case AddressType.GLOBAL_SP:\n                    result = new WStore(\n                        // require align\n                        wtype,\n                        new WGetGlobal(WType.u32, \"$sp\", this.location),\n                        value,\n                        WMemoryLocation.RAW,\n                        this.location,\n                    );\n                    (result as WStore).offset = this.place as number + this.offset;\n                    break;\n                case AddressType.RVALUE:\n                    result = new WStore(\n                        wtype,\n                        new WBinaryOperation(I32Binary.add,\n                            this.place as WExpression,\n                            new WConst(WType.i32, this.offset.toString(), this.location),\n                            this.location),\n                        value,\n                        WMemoryLocation.RAW,\n                        this.location,\n                    );\n                    break;\n            }\n        }\n        if (result === null) {\n            throw new InternalError(`createStore()`);\n        }\n        return result;\n    }\n\n    public createLoad(ctx: CompileContext, type: Type): WExpression {\n        let result: WExpression | null = null;\n        if ( type instanceof ArrayType || type instanceof ClassType ) {\n            throw new InternalError(`unsupport`);\n        } else {\n            switch (this.type) {\n                case AddressType.LOCAL:\n                    result = new WGetLocal(\n                        type.toWType(),\n                        this.place as number,\n                        this.location,\n                    );\n                    if ( this.offset !== 0) {\n                        throw new InternalError(`illegal offset`);\n                    }\n                    break;\n                case AddressType.MEMORY_DATA:\n                    result = new WLoad(\n                        type.toWType(),\n                        new WConst(WType.i32, \"0\", this.location),\n                        WMemoryLocation.DATA,\n                        this.location,\n                    );\n                    (result as WLoad).offset = this.place as number + this.offset;\n                    break;\n                case AddressType.MEMORY_BSS:\n                    result = new WLoad(\n                        type.toWType(),\n                        new WConst(WType.i32, \"0\", this.location),\n                        WMemoryLocation.BSS,\n                        this.location,\n                    );\n                    (result as WLoad).offset = this.place as number + this.offset;\n                    break;\n                case AddressType.MEMORY_EXTERN:\n                    result = new WLoad(\n                        type.toWType(),\n                        new WConst(WType.i32, \"0\", this.location),\n                        WMemoryLocation.EXTERN,\n                        this.location,\n                    );\n                    (result as WLoad).offsetName = this.place as string;\n                    (result as WLoad).offset = this.offset;\n                    break;\n                case AddressType.CONSTANT:\n                    result = new WConst(WType.i32, this.place.toString(), this.location);\n                    if ( this.offset !== 0) {\n                        throw new InternalError(`illegal offset`);\n                    }\n                    break;\n                case AddressType.STACK:\n                    if (ctx.currentFuncContext.currentFunction === null) {\n                        throw new InternalError(`not in function`);\n                    }\n                    result = new WLoad(\n                        type.toWType(),\n                        new WGetLocal(WType.i32, ctx.currentFuncContext.currentFunction.$sp, this.location),\n                        WMemoryLocation.RAW,\n                        this.location,\n                    );\n                    (result as WLoad).offset = this.place as number + this.offset;\n                    break;\n                case AddressType.GLOBAL:\n                    result = new WGetGlobal(\n                        type.toWType(),\n                        this.place as string,\n                        this.location,\n                    );\n                    if ( this.offset !== 0) {\n                        throw new InternalError(`illegal offset`);\n                    }\n                    break;\n                case AddressType.GLOBAL_SP:\n                    result = new WLoad(\n                        // require align\n                        type.toWType(),\n                        new WGetGlobal(WType.u32, \"$sp\", this.location),\n                        WMemoryLocation.RAW,\n                        this.location,\n                    );\n                    (result as WLoad).offset = this.place as number + this.offset;\n                    break;\n                case AddressType.RVALUE:\n                    result = new WLoad(\n                        type.toWType(),\n                        new WBinaryOperation(I32Binary.add,\n                            this.place as WExpression,\n                            new WConst(WType.i32, this.offset.toString(), this.location),\n                            this.location),\n                        WMemoryLocation.RAW,\n                        this.location,\n                    );\n                    break;\n            }\n        }\n        if (result === null) {\n            throw new InternalError(`createLoad()`);\n        }\n        return result;\n    }\n\n    public createLoadAddress(ctx: CompileContext): WExpression {\n        let result: WExpression | null = null;\n        switch (this.type) {\n            case AddressType.LOCAL:\n                throw new InternalError(`could not get address of local variable`);\n            case AddressType.MEMORY_DATA:\n                result = new WGetAddress(\n                    WMemoryLocation.DATA,\n                    this.location,\n                );\n                (result as WGetAddress).offset = this.place as number + this.offset;\n                break;\n            case AddressType.MEMORY_BSS:\n                result = new WGetAddress(\n                    WMemoryLocation.BSS,\n                    this.location,\n                );\n                (result as WGetAddress).offset = this.place as number + this.offset;\n                break;\n            case AddressType.MEMORY_EXTERN:\n                result = new WGetAddress(\n                    WMemoryLocation.EXTERN,\n                    this.location,\n                );\n                (result as WGetAddress).offset = this.offset;\n                (result as WGetAddress).offsetName = this.place as string;\n                break;\n            case AddressType.CONSTANT:\n                throw new InternalError(`store a constant()`);\n            case AddressType.STACK:\n                if ( ctx.currentFuncContext.currentFunction === null) {\n                    throw new InternalError(`not in function`);\n                }\n                result = new WBinaryOperation(\n                    I32Binary.add,\n                    new WGetLocal(WType.i32, ctx.currentFuncContext.currentFunction.$sp, this.location),\n                    new WConst(WType.i32, (this.place as number + this.offset).toString(), this.location),\n                    this.location,\n                );\n                break;\n            case AddressType.GLOBAL_SP:\n                if ( ctx.currentFuncContext.currentFunction === null) {\n                    throw new InternalError(`not in function`);\n                }\n                result = new WBinaryOperation(\n                    I32Binary.add,\n                    new WGetGlobal(WType.i32, \"$sp\", this.location),\n                    new WConst(WType.i32, (this.place as number + this.offset).toString(), this.location),\n                    this.location,\n                );\n                break;\n            case AddressType.RVALUE:\n                result = new WBinaryOperation(I32Binary.add,\n                    this.place as WExpression,\n                    new WConst(WType.i32, this.offset.toString(), this.location),\n                    this.location);\n                break;\n            case AddressType.GLOBAL:\n                throw new InternalError(`could not get address of global variable`);\n        }\n        if (result === null) {\n            throw new InternalError(`createStore()`);\n        }\n        return result;\n    }\n\n    public makeOffset(offset: number): WAddressHolder {\n        if (this.type === AddressType.LOCAL) {\n            throw new InternalError(`could not get address of local variable`);\n        }\n        this.offset += offset;\n        return this;\n    }\n\n    public deduceType(e: Emitter): WType {\n        throw new EmitError(`WAddressHolder()`);\n    }\n\n    public emit(e: Emitter): void {\n        throw new EmitError(`WAddressHolder()`);\n    }\n\n    public isPure(): boolean {\n        return true;\n    }\n\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 19/07/2018\n */\n\nimport {InternalError, SyntaxError} from \"../common/error\";\nimport {Node} from \"../common/node\";\nimport {FunctionEntity, OverloadSymbol, Symbol, Variable} from \"../common/symbol\";\nimport {ClassTemplate, FunctionTemplate} from \"../common/template\";\nimport {AccessControl, Type} from \"../type\";\nimport {ClassType} from \"../type/class_type\";\nimport {WAddressHolder} from \"./address\";\nimport {EvaluatedTemplateArgument} from \"./template/template_argument\";\n\nexport class FunctionLookUpResult {\n    public instance: WAddressHolder | null;\n    public instanceType: ClassType | null;\n    public isDynamicCall: boolean;\n    public functions: Array<FunctionEntity | FunctionTemplate>;\n    public templateArguments: EvaluatedTemplateArgument[];\n\n    constructor(functions: Array<FunctionEntity | FunctionTemplate>) {\n        this.functions = functions;\n        this.instance = null;\n        this.instanceType = null;\n        this.isDynamicCall = false;\n        this.templateArguments = [];\n    }\n}\n\nexport type LookUpResult = Variable | Type | FunctionLookUpResult | ClassTemplate | null;\n\nexport function getShortName(lookupName: string): string {\n    const tokens = lookupName.split(\"::\");\n    return tokens[tokens.length - 1];\n}\n\nexport class Scope {\n    public shortName: string;\n    public fullName: string;\n    public parent: Scope;\n    public children: Scope[];\n    public map: Map<string, Symbol[]>;\n    public isCpp: boolean;\n    public isInnerScope: boolean;\n    public classType: ClassType | null;\n\n    constructor(shortName: string, parent: Scope | null, isCpp: boolean) {\n        this.shortName = shortName;\n        if (parent === null) {\n            this.parent = this;\n            this.fullName = \"\";\n        } else {\n            this.parent = parent;\n            this.fullName = this.parent.fullName + \"::\" + this.shortName;\n        }\n        this.children = [];\n        this.map = new Map<string, Symbol[]>();\n        this.isCpp = isCpp;\n        this.isInnerScope = false;\n        this.classType = null;\n    }\n\n    public getScopeOfLookupName(lookupName: string): Scope | null {\n        if (lookupName.slice(0, 2) === \"::\") {\n            lookupName = lookupName.slice(2);\n        }\n        const tokens = lookupName.split(\"::\");\n        if (tokens.length === 1) {\n            return this;\n        } else {\n            for (const scope of this.children) {\n                if (scope.shortName === tokens[0]) {\n                    return scope.getScopeOfLookupName(tokens.slice(1).join(\"::\"));\n                }\n            }\n            return null;\n        }\n    }\n\n    public mergeSymbolInScope(shortName: string, newItem: Symbol, node: Node): void {\n        const oldItems = this.map.get(shortName);\n        if (!oldItems) {\n            this.map.set(shortName, [newItem]);\n            return;\n        }\n        const oldItem = oldItems[0];\n        if (oldItem instanceof OverloadSymbol) {\n            if (!(newItem instanceof OverloadSymbol)) {\n                throw new SyntaxError(`${shortName} has been declared as function`\n                    + `but a ${newItem.constructor.name} found`, node);\n            }\n            for (let i = 0; i < oldItems.length; i++) {\n                const x = oldItems[i] as OverloadSymbol;\n                if (x.getFullName() === newItem.getFullName()) {\n                    // TODO:: full check compatible?\n                    if (x.isDefine() && !newItem.isDefine()) {\n                        return;\n                    } else if (x.isDefine() && newItem.isDefine()) {\n                        throw new SyntaxError(`redefine of ${shortName}`, node);\n                    } else if (!x.isDefine() && newItem.isDefine()) {\n                        // hack access control\n                        if (newItem.accessControl === AccessControl.Unknown) {\n                            newItem.accessControl = x.accessControl;\n                        }\n                        oldItems[i] = newItem;\n                        return;\n                    } else if (!x.isDefine() && !newItem.isDefine()) {\n                        return;\n                    }\n                }\n            }\n            oldItems.push(newItem);\n            return;\n        } else {\n            if (oldItem instanceof Variable) {\n                if (newItem.isDefine() && oldItem.isDefine()) {\n                    throw new SyntaxError(`redefine of ${shortName}`, node);\n                }\n                if (newItem instanceof Variable) {\n                    if (oldItem.type.equals(newItem.type)\n                        && oldItem.fullName === newItem.fullName) {\n                        if (newItem.isDefine()) {\n                            if (newItem.accessControl === AccessControl.Unknown) {\n                                newItem.accessControl = oldItem.accessControl;\n                            }\n                            oldItems[0] = newItem;\n                        }\n                        return;\n                    } else {\n                        throw new SyntaxError(`conflict declaration of ${shortName}`, node);\n                    }\n                } else {\n                    throw new SyntaxError(`${shortName} has been declared as variable`\n                        + `but a ${newItem.constructor.name} found`, node);\n                }\n            } else if (oldItem instanceof Type) {\n                if (newItem instanceof Type) {\n                    if (oldItem.equals(newItem)) {\n                        return;\n                    } else {\n                        throw new SyntaxError(`conflict declaration of ${shortName}`, node);\n                    }\n                } else {\n                    throw new SyntaxError(`${shortName} has been declared as type`\n                        + `but a ${newItem.constructor.name} found`, node);\n                }\n            } else if (oldItem instanceof ClassTemplate) {\n                if (newItem.isDefine() && oldItem.isDefine()) {\n                    throw new SyntaxError(`redefine of ${shortName}`, node);\n                }\n                if (newItem instanceof ClassTemplate) {\n                    if (oldItem.templateParams.length !== newItem.templateParams.length) {\n                        throw new SyntaxError(`conflict declaration of ${shortName}`, node);\n                    }\n                    for (let i = 0; i < oldItem.templateParams.length; i++) {\n                        if (!oldItem.templateParams[i].type.equals(newItem.templateParams[i].type)) {\n                            throw new SyntaxError(`conflict declaration of ${shortName}`, node);\n                        }\n                    }\n                    if (newItem.isDefine()) {\n                        oldItems[0] = newItem;\n                    }\n                    return;\n                } else {\n                    throw new SyntaxError(`${shortName} has been declared as class template`\n                        + `but a ${newItem.constructor.name} found`, node);\n                }\n            }\n        }\n        throw new InternalError(`assertCompatible()`);\n    }\n\n    public lookupInScope(anyName: string): Symbol[] | null {\n        if (anyName.slice(0, 2) === \"::\") {\n            throw new InternalError(`public lookupInScope(anyName: string){`);\n        }\n        const itemScope = this.getScopeOfLookupName(anyName);\n        const shortName = getShortName(anyName);\n        if (itemScope) {\n            return itemScope.map.get(shortName) || null;\n        }\n        return null;\n    }\n}\n\nexport interface ScopeContext {\n    scope: Scope;\n    activeScopes: Scope[];\n}\n\nexport class ScopeManager {\n\n    public isCpp: boolean;\n\n    public root: Scope;\n    public currentContext: ScopeContext;\n    public contextStack: ScopeContext[];\n\n    public scopeId: number;\n    public tmpVarId: number;\n\n    constructor(isCpp: boolean) {\n        this.isCpp = isCpp;\n        this.root = new Scope(\"\", null, isCpp);\n        this.scopeId = 0;\n        this.tmpVarId = 0;\n        this.contextStack = [];\n        this.currentContext = {\n            scope: this.root,\n            activeScopes: [this.root],\n        };\n    }\n\n    public allocTmpVarName() {\n        return \"$__\" + this.tmpVarId++;\n    }\n\n    public getFullName(anyName: string): string {\n        const isFullLookup = anyName.slice(0, 2) === \"::\";\n        if (isFullLookup) {\n            return anyName;\n        }\n        for (let i = this.currentContext.activeScopes.length - 1; i >= 0; i--) {\n            const scope = this.currentContext.activeScopes[i];\n            const itemScope = scope.getScopeOfLookupName(anyName);\n            const shortName = getShortName(anyName);\n            if (itemScope && itemScope.map.has(shortName)) {\n                return itemScope.fullName + \"::\" + shortName;\n            }\n        }\n        return this.currentContext.scope.fullName + \"::\" + anyName;\n    }\n\n    public lookupFunction(anyName: string): LookUpResult {\n        const scopes = anyName.slice(0, 2) === \"::\" ? [this.root] : this.currentContext.activeScopes;\n        const realName = anyName.slice(0, 2) === \"::\" ? anyName.slice(2) : anyName;\n        const shortName = getShortName(realName).split(\"@\")[0];\n        const isWithSignature = getShortName(realName).includes(\"@\");\n        const nameMap = new Set<string>();\n        const result = [] as Array<FunctionTemplate | FunctionEntity>;\n        for (let i = scopes.length - 1; i >= 0; i--) {\n            const scope = scopes[i];\n            const subScope = scope.getScopeOfLookupName(realName);\n            if (subScope) {\n                const item = subScope.map.get(shortName);\n                if (item) {\n                    for (const subItem of item) {\n                        if (subItem instanceof FunctionTemplate || subItem instanceof FunctionEntity) {\n                            if (!nameMap.has(subItem.shortName) && !isWithSignature ||\n                                subItem.getFullName() === subScope.fullName + \"::\" + getShortName(realName)) {\n                                nameMap.add(subItem.shortName);\n                                result.push(subItem);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return new FunctionLookUpResult(result);\n    }\n\n    public lookup(anyName: string): LookUpResult {\n        const scopes = anyName.slice(0, 2) === \"::\" ? [this.root] : this.currentContext.activeScopes;\n        const realName = anyName.slice(0, 2) === \"::\" ? anyName.slice(2) : anyName;\n        for (let i = scopes.length - 1; i >= 0; i--) {\n            const item = this.currentContext.activeScopes[i].lookupInScope(realName);\n            if (item) {\n                const item0 = item[0];\n                if (item0 instanceof OverloadSymbol) {\n                    return this.lookupFunction(anyName);\n                } else {\n                    return item0 as LookUpResult;\n                }\n            }\n        }\n        return null;\n    }\n\n    public declare(lookupName: string, symbol: Symbol, node: Node) {\n        const isRestrictLookup = lookupName.includes(\"::\");\n        const isFullLookup = lookupName.slice(0, 2) === \"::\";\n        if ( isFullLookup ) {\n            const restrictLookupName = lookupName.slice(2);\n            const scope = this.root.getScopeOfLookupName(restrictLookupName);\n            if (!scope) {\n                throw new SyntaxError(`unresolved name ${lookupName}`, node);\n            }\n            const itemScope = scope.getScopeOfLookupName(restrictLookupName);\n            const shortName = getShortName(restrictLookupName);\n            if (itemScope && itemScope.map.has(shortName)) {\n                scope.mergeSymbolInScope(shortName, symbol, node);\n                return;\n            }\n            throw new SyntaxError(`unresolved name ${lookupName}`, node);\n        } else if (isRestrictLookup) {\n            for (const scope of this.currentContext.activeScopes) {\n                const itemScope = scope.getScopeOfLookupName(lookupName);\n                const shortName = getShortName(lookupName);\n                if (itemScope && itemScope.map.has(shortName)) {\n                    scope.mergeSymbolInScope(shortName, symbol, node);\n                    return;\n                }\n            }\n            throw new SyntaxError(`unresolved name ${lookupName}`, node);\n        } else {\n            this.currentContext.scope.mergeSymbolInScope(lookupName, symbol, node);\n        }\n    }\n\n    public define(lookupName: string, symbol: Symbol, node: Node) {\n        const isRestrictLookup = lookupName.includes(\"::\");\n        const isFullLookup = lookupName.slice(0, 2) === \"::\";\n        if ( isFullLookup ) {\n            const restrictLookupName = lookupName.slice(2);\n            const scope = this.root.getScopeOfLookupName(restrictLookupName);\n            if (!scope) {\n                throw new SyntaxError(`unresolved name ${lookupName}`, node);\n            }\n            const itemScope = scope.getScopeOfLookupName(restrictLookupName);\n            const shortName = getShortName(restrictLookupName);\n            if (itemScope && itemScope.map.has(shortName)) {\n                scope.mergeSymbolInScope(shortName, symbol, node);\n                return;\n            }\n            throw new SyntaxError(`unresolved name ${lookupName}`, node);\n        } else if (isRestrictLookup) {\n            for (const scope of this.currentContext.activeScopes) {\n                const itemScope = scope.getScopeOfLookupName(lookupName);\n                const shortName = getShortName(lookupName);\n                if (itemScope && itemScope.map.has(shortName)) {\n                    scope.mergeSymbolInScope(shortName, symbol, node);\n                    return;\n                }\n            }\n            throw new SyntaxError(`unresolved name ${lookupName}`, node);\n        } else {\n            this.currentContext.scope.mergeSymbolInScope(lookupName, symbol, node);\n        }\n    }\n\n    public enterScope(anyName: string) {\n        this.contextStack.push(this.currentContext);\n        const fullName = this.getFullName(anyName);\n        const scope = this.root.getScopeOfLookupName(fullName);\n        if (!scope) {\n            throw new InternalError(`the scope of ${fullName} is not exist`);\n        }\n        let activeScopes = [] as Scope[];\n        for (let item = scope; item !== this.root; item = item.parent) {\n            activeScopes.push(item);\n        }\n        activeScopes.push(this.root);\n        activeScopes = activeScopes.reverse();\n        const oldScope = scope.children.filter((x) => x.fullName === fullName);\n        if (oldScope.length) {\n            activeScopes.push(oldScope[0]);\n            this.currentContext = {\n                scope: oldScope[0],\n                activeScopes,\n            };\n        } else {\n            const newScope = new Scope(getShortName(fullName), scope, this.isCpp);\n            scope.children.push(newScope);\n            activeScopes.push(newScope);\n            this.currentContext = {\n                scope: newScope,\n                activeScopes,\n            };\n        }\n    }\n\n    public enterSavedScope(scopeContext: ScopeContext) {\n        this.contextStack.push(this.currentContext);\n        this.currentContext = scopeContext;\n    }\n\n    public exitScope() {\n        if (this.contextStack.length === 0) {\n            throw new InternalError(`this.contextStack.length === 0`);\n        }\n        this.currentContext = this.contextStack.pop()!;\n    }\n\n    // 1. for inner scope of compound statement\n    // 2. for define scope of template\n    public enterUnnamedScope(anonymous: boolean) {\n        const newScope = new Scope(\"$\" + this.scopeId++ , this.currentContext.scope, this.isCpp);\n        if (anonymous) {\n            newScope.fullName = this.currentContext.scope.fullName;\n        }\n        newScope.isInnerScope = true;\n        this.currentContext.scope.children.push(newScope);\n        this.contextStack.push(this.currentContext);\n        const activeScopes = this.currentContext.activeScopes.map((x) => x);\n        activeScopes.push(newScope);\n        this.currentContext = {\n            scope: newScope,\n            activeScopes,\n        };\n    }\n\n    public detachCurrentScope() {\n        // remove temp scope\n        const parent = this.currentContext.scope.parent;\n        for (let i = 0; i < parent.children.length; i++) {\n            if (parent.children[i] === this.currentContext.scope) {\n                for (let j = i; j < parent.children.length - 1; j++) {\n                    parent.children[j] = parent.children[j + 1];\n                }\n                break;\n            }\n        }\n        parent.children.pop();\n    }\n\n    public isRoot() {\n        return this.currentContext.scope === this.root;\n    }\n\n    public activeScopes(scopes: Scope[]) {\n        const nameSet = new Set<string>(this.currentContext.activeScopes.map((x) => x.fullName));\n        const newScopes = scopes.filter((x) => x.isInnerScope || !nameSet.has(x.fullName));\n        const oldScopes = this.currentContext.activeScopes\n            .filter((x) => x.fullName !== this.currentContext.scope.fullName);\n        this.currentContext.activeScopes = [\n            ...oldScopes, ...newScopes, this.currentContext.scope,\n        ];\n    }\n\n    public getOldOverloadSymbol(fullName: string): OverloadSymbol | null {\n        const oldItem = this.lookup(fullName.split(\"@\")[0]);\n        if (oldItem && oldItem instanceof FunctionLookUpResult) {\n            const items = oldItem.functions.filter((x) => x.fullName === fullName);\n            if (items.length) { return items[0]; }\n        }\n        return null;\n    }\n}\n","import {InternalError} from \"../../common/error\";\nimport {FunctionTemplate} from \"../../common/template\";\nimport {Type} from \"../../type\";\nimport {ArrayType, LeftReferenceType, PointerType, ReferenceType, RightReferenceType} from \"../../type/compound_type\";\nimport {FunctionType} from \"../../type/function_type\";\nimport {TemplateParameterPlaceHolderType} from \"../../type/template_type\";\nimport {EvaluatedTemplateArgument} from \"./template_argument\";\n\nexport function deduceFunctionTypeOfTemplate(type: Type,\n                                             params: EvaluatedTemplateArgument[]): Type {\n    if (type instanceof FunctionType) {\n        const result = new FunctionType(deduceFunctionTypeOfTemplate(type.returnType, params),\n            type.parameterTypes.map((x) => deduceFunctionTypeOfTemplate(x, params)), type.variableArguments);\n        result.cppFunctionType = type.cppFunctionType;\n        result.referenceClass = type.referenceClass;\n        result.isVirtual = type.isVirtual;\n        return result;\n    } else if (type instanceof PointerType) {\n        return new PointerType(deduceFunctionTypeOfTemplate(type.elementType, params));\n    } else if (type instanceof RightReferenceType) {\n        return new RightReferenceType(deduceFunctionTypeOfTemplate(type.elementType, params));\n    } else if (type instanceof LeftReferenceType) {\n        return new LeftReferenceType(deduceFunctionTypeOfTemplate(type.elementType, params));\n    } else if (type instanceof ArrayType) {\n        return new ArrayType(deduceFunctionTypeOfTemplate(type.elementType, params), type.size);\n    } else if (type instanceof TemplateParameterPlaceHolderType) {\n        const arg = params[type.index];\n        if (arg === null) {\n            throw new InternalError(`deduceFunctionTypeOfTemplate()`);\n        } else if (arg instanceof Type) {\n            return arg;\n        } else {\n            throw new InternalError(`deduceFunctionTypeOfTemplate()`);\n        }\n    } else {\n        return type;\n    }\n}\n\nexport function deduceFunctionTemplateParameters(functionTemplate: FunctionTemplate,\n                                                 functionType: FunctionType,\n                                                 args: EvaluatedTemplateArgument[],\n                                                 weakMatch: boolean)\n    : EvaluatedTemplateArgument[] | null {\n    if (args.length > functionTemplate.templateParams.length) {\n        return null;\n    }\n    const params = functionType.parameterTypes.filter(() => true);\n    if (functionTemplate.functionConfig.functionType.parameterTypes.length !== params.length) {\n        if (!weakMatch) {\n            return null;\n        } else {\n            if (params.length > functionTemplate.functionConfig.functionType.parameterTypes.length) {\n                return null;\n            }\n            for (let i = params.length; i < functionTemplate.functionConfig.functionType.parameterTypes.length; i++) {\n                if (functionTemplate.functionConfig.parameterInits[i] !== null) {\n                    params.push(functionTemplate.functionConfig.functionType.parameterTypes[i]);\n                }\n            }\n        }\n    }\n    // 1.build default table\n    const templateParametersTable: Array<EvaluatedTemplateArgument|null> = [];\n    for (let i = 0; i < functionTemplate.templateParams.length; i++) {\n        templateParametersTable.push(null);\n    }\n    for (let i = 0; i < args.length; i++) {\n        templateParametersTable[i] = args[i];\n    }\n    try {\n        for (let i = 0; i < params.length; i++) {\n            tryMatchTemplateType(templateParametersTable,\n                functionTemplate.functionConfig.functionType.parameterTypes[i],\n                params[i],\n                weakMatch);\n        }\n    } catch (e) {\n        return null;\n    }\n    for (let i = 0; i < functionTemplate.templateParams.length; i++) {\n        if (templateParametersTable[i] === null) {\n            if (functionTemplate.templateParams[i].init !== null) {\n                templateParametersTable[i] = functionTemplate.templateParams[i].init;\n            } else {\n                return null;\n            }\n        }\n    }\n    return templateParametersTable as EvaluatedTemplateArgument[];\n}\n\nexport function tryMatchTemplateType(table: Array<EvaluatedTemplateArgument|null>,\n                                     templateType: Type,\n                                     instanceType: Type,\n                                     weakMatch: boolean) {\n    if (templateType instanceof FunctionType) {\n        if (!(instanceType instanceof FunctionType)) {\n            throw {};\n        }\n        if (instanceType.parameterTypes.length !== templateType.parameterTypes.length) {\n            throw {};\n        }\n        tryMatchTemplateType(table, templateType.returnType, instanceType.returnType, weakMatch);\n        for (let i = 0; i < templateType.parameterTypes.length; i++) {\n            tryMatchTemplateType(table, templateType.parameterTypes[i], instanceType.parameterTypes[i], weakMatch);\n        }\n    } else if (templateType instanceof PointerType) {\n        if (instanceType instanceof PointerType) {\n            tryMatchTemplateType(table, templateType.elementType, instanceType.elementType, weakMatch);\n        } else {\n            throw {};\n        }\n    } else if (templateType instanceof ReferenceType) {\n        if (instanceType instanceof ReferenceType) {\n            tryMatchTemplateType(table, templateType.elementType, instanceType.elementType, weakMatch);\n        } else {\n            throw {};\n        }\n    } else if (templateType instanceof ArrayType) {\n        if (instanceType instanceof ArrayType) {\n            tryMatchTemplateType(table, templateType.elementType, instanceType.elementType, weakMatch);\n        } else {\n            throw {};\n        }\n    } else if (templateType instanceof TemplateParameterPlaceHolderType) {\n        const arg = table[templateType.index];\n        if (arg === null) {\n            table[templateType.index] = instanceType;\n        } else if (arg instanceof Type) {\n            if (instanceType instanceof TemplateParameterPlaceHolderType) {\n                if (templateType.index !== instanceType.index) {\n                    throw {};\n                }\n            } else {\n                if (weakMatch) {\n                    if (!arg.compatWith(instanceType)) {\n                        throw {};\n                    }\n                } else {\n                    if (!arg.equals(instanceType)) {\n                        throw {};\n                    }\n                }\n            }\n        } else {\n            throw {};\n        }\n    } else {\n        if (weakMatch) {\n            if (!templateType.compatWith(instanceType)) {\n                throw {};\n            }\n        } else {\n            if (!templateType.equals(instanceType)) {\n                throw {};\n            }\n        }\n    }\n}\n","import {InternalError, SyntaxError} from \"../../common/error\";\nimport {ClassDirective, Node, SourceLocation} from \"../../common/node\";\nimport {AddressType, FunctionEntity, Variable} from \"../../common/symbol\";\nimport {FunctionTemplate} from \"../../common/template\";\nimport {AccessControl, Type} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {FunctionType, UnresolvedFunctionOverloadType} from \"../../type/function_type\";\nimport {CompileContext} from \"../context\";\nimport {Declarator} from \"../declaration/declarator\";\nimport {SpecifierList} from \"../declaration/specifier_list\";\nimport {defineFunction, FunctionConfig} from \"../function/function\";\nimport {EvaluatedTemplateArgument} from \"./template_argument\";\nimport {deduceFunctionTemplateParameters, deduceFunctionTypeOfTemplate} from \"./template_deduce\";\n\nexport class FunctionTemplateInstantiation extends ClassDirective {\n    public specifiers: SpecifierList;\n    public declarator: Declarator;\n\n    constructor(location: SourceLocation, specifiers: SpecifierList, declarator: Declarator) {\n        super(location);\n        this.specifiers = specifiers;\n        this.declarator = declarator;\n    }\n\n    public declare(ctx: CompileContext, classType: ClassType): void {\n        throw new InternalError(`todo`);\n    }\n\n    public codegen(ctx: CompileContext): void {\n        const name = this.declarator.getNameRequired();\n        const lookupType = name.deduceType(ctx);\n        const functionType = this.declarator.getType(ctx, this.specifiers.getType(ctx));\n        if (!(lookupType instanceof UnresolvedFunctionOverloadType) || !(functionType instanceof FunctionType)) {\n            throw new SyntaxError(`${name.getLookupName(ctx)} is not a function template`, this);\n        }\n        const lookupResult = lookupType.functionLookupResult;\n        for (const item of lookupResult.functions) {\n            if (item instanceof FunctionTemplate) {\n                const params = deduceFunctionTemplateParameters(item, functionType,\n                    lookupResult.templateArguments, false);\n                if (params !== null) {\n                    // match_successful point;\n                    instantiateFunctionTemplate(ctx, item, params, this);\n                    return;\n                }\n            }\n        }\n        throw new SyntaxError(`no matched function template`, this);\n    }\n\n}\n\nexport function instantiateFunctionTemplate(ctx: CompileContext,\n                                            funcTemplate: FunctionTemplate,\n                                            args: EvaluatedTemplateArgument[],\n                                            node: Node) {\n    const type = deduceFunctionTypeOfTemplate(funcTemplate.functionConfig.functionType, args) as FunctionType;\n    const signature = args.map((x) => x.toString()).join(\",\");\n    const instanceName = funcTemplate.shortName + \"@\" + signature;\n    const longInstanceName = instanceName + \"@\" + type.toMangledName();\n    ctx.scopeManager.enterSavedScope(funcTemplate.scopeContext);\n    funcTemplate.instanceMap.set(signature, new FunctionEntity(\n        longInstanceName + \"@\" + type.toMangledName(),\n        ctx.scopeManager.getFullName(longInstanceName),\n        ctx.fileName, type,\n        funcTemplate.functionConfig.parameterInits, false, true,\n        AccessControl.Public, [],\n    ));\n    ctx.scopeManager.enterUnnamedScope(true);\n    for (let i = 0; i < args.length; i++) {\n        const name = funcTemplate.templateParams[i].name;\n        const arg = args[i];\n        if (arg instanceof Type) {\n            ctx.scopeManager.define(name, arg, node);\n        } else {\n            ctx.scopeManager.define(name, new Variable(\n                name, ctx.scopeManager.getFullName(name), ctx.fileName,\n                funcTemplate.templateParams[i].type, AddressType.CONSTANT, arg,\n                AccessControl.Public,\n            ), node);\n        }\n    }\n    let funcBody = funcTemplate.functionBody.body.body;\n    const spec = funcTemplate.specializationMap.get(signature);\n    if (spec) {\n        funcBody = spec.body.body;\n    }\n    type.isTemplateInstance = true;\n    const functionConfig: FunctionConfig = {\n        name: instanceName,\n        functionType: type,\n        parameterNames: funcTemplate.functionConfig.parameterNames,\n        parameterInits: funcTemplate.functionConfig.parameterInits,\n        isLibCall: funcTemplate.functionConfig.isLibCall,\n        accessControl: funcTemplate.functionConfig.accessControl,\n    };\n    defineFunction(ctx, functionConfig, funcBody,\n        [...funcTemplate.scopeContext.activeScopes,\n            ctx.scopeManager.currentContext.scope],\n        node);\n    ctx.scopeManager.currentContext.scope.children.map((scope) =>\n        ctx.scopeManager.currentContext.scope.parent.children.push(scope));\n    ctx.scopeManager.detachCurrentScope();\n    ctx.scopeManager.exitScope();\n    ctx.scopeManager.exitScope();\n}\n","/**\n *  @file cpp language function overloader\n *  @author zcy <zurl@live.com>\n *  Created at 21/07/2018\n */\nimport {SyntaxError} from \"../common/error\";\nimport {Node} from \"../common/node\";\nimport {FunctionEntity} from \"../common/symbol\";\nimport {FunctionTemplate} from \"../common/template\";\nimport {Type} from \"../type\";\nimport {ClassType} from \"../type/class_type\";\nimport {PointerType, ReferenceType} from \"../type/compound_type\";\nimport {FunctionType} from \"../type/function_type\";\nimport {PrimitiveTypes} from \"../type/primitive_type\";\nimport {CompileContext} from \"./context\";\nimport {FunctionLookUpResult} from \"./scope\";\nimport {instantiateFunctionTemplate} from \"./template/function_template_instantiation\";\nimport {deduceFunctionTemplateParameters} from \"./template/template_deduce\";\n\nexport function doStrictTypeMatch(dst: Type, src: Type): boolean {\n    if (dst instanceof ReferenceType) {\n        dst = dst.elementType;\n    }\n    if (src instanceof ReferenceType) {\n        src = src.elementType;\n    }\n    return dst.equals(src);\n}\n\nexport function doWeakTypeMatch(dst: Type, src: Type): boolean {\n    if (dst instanceof ReferenceType) {\n        dst = dst.elementType;\n    }\n    if (src instanceof ReferenceType) {\n        src = src.elementType;\n    }\n    return dst.compatWith(src);\n}\n\nexport function doFunctionFilter(func: FunctionEntity, argus: Type[],\n                                 funcs: FunctionLookUpResult,\n                                 matcher: (dst: Type, src: Type) => boolean): boolean {\n    if (func.type.isMemberFunction()) {\n        const first = func.type.parameterTypes[0];\n        if (funcs.instanceType === null || !(first instanceof PointerType)) {\n            return false;\n        }\n        return first.elementType.compatWith(funcs.instanceType) &&\n            func.type.parameterTypes.slice(1).every((t, i) => matcher(t, argus[i]));\n    } else {\n        return func.type.parameterTypes.every((t, i) => matcher(t, argus[i]));\n    }\n}\n\nexport function removeDuplicatedFunctions(funcs: FunctionEntity[]): FunctionEntity[] {\n    const s = new Set<string>();\n    const result = [] as FunctionEntity[];\n    for (const func of funcs) {\n        if (!s.has(func.fullName)) {\n            result.push(func);\n            s.add(func.fullName);\n        }\n    }\n    return result;\n}\n\nexport function doFunctionOverloadResolution(ctx: CompileContext,\n                                             funcs: FunctionLookUpResult,\n                                             argus: Type[], node: Node): FunctionEntity {\n    // 1. filter parameter number\n\n    // 1.1 lookup instance template function\n    const signatureBase = funcs.templateArguments.map((x) => x.toString()).join(\",\");\n    const t0 = [] as FunctionEntity[];\n    const templates = [] as FunctionTemplate[];\n    for (const func of funcs.functions) {\n        if (func instanceof FunctionTemplate) {\n            templates.push(func);\n            for (const funcIns of func.instanceMap.keys()) {\n                if (funcs.templateArguments.length === 0\n                    || funcIns.startsWith(signatureBase)) {\n                    t0.push(func.instanceMap.get(funcIns)!);\n                }\n            }\n        }\n    }\n    const t1 = funcs.functions.filter((x) => !(x instanceof FunctionTemplate)) as FunctionEntity[];\n    // make template after normal\n\n    const t2 = t1.concat(t0);\n    const f0 = t2.filter((func) =>\n        (func.type.isMemberFunction() && func.type.parameterTypes.length === argus.length + 1)\n        || (!func.type.isMemberFunction() && func.type.parameterTypes.length === argus.length)\n        || func.type.variableArguments,\n    );\n    const f1 = removeDuplicatedFunctions(f0);\n\n    // 2. strong type match\n\n    const f2 = f1.filter((func) => doFunctionFilter(func, argus, funcs, doStrictTypeMatch));\n\n    if (f2.length >= 1) {\n        if (f2.length > 1) {\n            ctx.raiseWarning(`call for ${funcs.functions[0].shortName} is ambiguous`, node);\n        }\n        return f2[0];\n    }\n\n    // 3. weak type match\n\n    const g0 = f1.filter((func) => !func.type.isTemplateInstance);\n    const f3 = g0.filter((func) => doFunctionFilter(func, argus, funcs, doWeakTypeMatch));\n\n    if (f3.length >= 1) {\n        if (f3.length > 1) {\n            ctx.raiseWarning(`call for ${funcs.functions[0].shortName} is ambiguous`, node);\n        }\n        return f3[0];\n    }\n\n    // 4. var arguments\n\n    const f4 = f1.filter((x) => x.type.variableArguments);\n\n    // TODO:: not match the c++ standard\n    if (f4.length >= 1) {\n        if (f4.length > 1) {\n            ctx.raiseWarning(`call for ${funcs.functions[0].shortName} is ambiguous`, node);\n        }\n        return f4[0];\n    }\n\n    // 5. passive template instance\\\n    const templateArgus = funcs.instanceType ? [new PointerType(funcs.instanceType), ...argus] : argus;\n    for (const item of templates) {\n        const mockFunctionType = new FunctionType(PrimitiveTypes.void, templateArgus, false);\n        const params = deduceFunctionTemplateParameters(item, mockFunctionType, funcs.templateArguments, true);\n        if (params !== null) {\n            const signature = params.map((x) => x.toString()).join(\",\");\n            if (!item.instanceMap.get(signature)) {\n                // apply instance creation\n                instantiateFunctionTemplate(ctx, item, params, node);\n                return item.instanceMap.get(signature)!;\n            }\n        }\n    }\n\n    throw new SyntaxError(`no matching function for ${funcs.functions[0].shortName.split(\"@\")[0]}`, node);\n}\n\nexport function isFunctionExists(ctx: CompileContext, name: string, argus: Type[],\n                                 instanceType: ClassType | null = null): boolean {\n    const lookupResult = ctx.scopeManager.lookup(name);\n\n    if ( !(lookupResult instanceof FunctionLookUpResult)) { return false; }\n    try {\n        lookupResult.instanceType = instanceType;\n        doFunctionOverloadResolution(ctx, lookupResult, argus, {} as Node);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 14/07/2018\n */\nimport {InternalError, SyntaxError, TypeError} from \"../common/error\";\nimport {Node} from \"../common/node\";\nimport {AddressType} from \"../common/symbol\";\nimport {Type} from \"../type\";\nimport {ClassType} from \"../type/class_type\";\nimport {ArrayType, LeftReferenceType, PointerType, ReferenceType} from \"../type/compound_type\";\nimport {FunctionType, UnresolvedFunctionOverloadType} from \"../type/function_type\";\nimport {\n    ArithmeticType,\n    FloatingType,\n    FloatType, Int64Type,\n    IntegerType,\n    PrimitiveTypes,\n    UnsignedInt64Type, UnsignedIntegerType,\n} from \"../type/primitive_type\";\nimport {WAddressHolder} from \"./address\";\nimport {CompileContext} from \"./context\";\nimport {ExpressionResult} from \"./expression/expression\";\nimport {doFunctionOverloadResolution} from \"./overload\";\nimport {getTypeConvertOpe, WConst, WCovertOperation, WExpression, WGetFunctionAddress} from \"../wasm\";\n\nexport function arithmeticDeduce(left: ArithmeticType, right: ArithmeticType): ArithmeticType {\n    if (left instanceof FloatingType || right instanceof FloatingType) {\n        return PrimitiveTypes.double;\n    }\n    if (left instanceof UnsignedInt64Type || right instanceof UnsignedInt64Type) {\n        return PrimitiveTypes.uint64;\n    }\n    if (left instanceof Int64Type || right instanceof Int64Type) {\n        return PrimitiveTypes.int64;\n    }\n    if (left instanceof UnsignedIntegerType || right instanceof UnsignedIntegerType) {\n        return PrimitiveTypes.uint32;\n    }\n    return PrimitiveTypes.int32;\n}\n\nexport function doTypeTransfrom(type: Type): Type {\n    // array to pointer transform\n    if (type instanceof ArrayType) {\n        type = new PointerType(type.elementType);\n    }\n\n    if (type instanceof ReferenceType) {\n        type = type.elementType;\n    }\n    // func to pointer transform\n    // TODO::\n\n    return type;\n}\n\nexport function doReferenceTransform(ctx: CompileContext, left: ExpressionResult,\n                                     node: Node) {\n\n    if ( left.type instanceof LeftReferenceType ) {\n        if ( !left.isLeft || !(left.expr instanceof WAddressHolder)) {\n            left.type = left.type.elementType;\n            left.expr = new WAddressHolder(left.expr, AddressType.RVALUE, node.location);\n        } else {\n            left.type = left.type.elementType;\n            left.expr = new WAddressHolder(left.expr.createLoad(ctx, PrimitiveTypes.uint32),\n                AddressType.RVALUE, node.location);\n        }\n    }\n    return left;\n}\n\nexport function doValueTransform(ctx: CompileContext, expr: ExpressionResult,\n                                 node: Node, toReference = false): ExpressionResult {\n\n    if ( !expr.isLeft && expr.type instanceof LeftReferenceType) {\n        throw new InternalError(`LeftReferenceType could not be rvalue`);\n    }\n\n    // left value transform\n    if (expr.isLeft) {\n        expr.isLeft = false;\n\n        if ( expr.type instanceof LeftReferenceType && !(expr.expr instanceof WAddressHolder) ) {\n            expr.type = expr.type.elementType;\n            expr.expr = new WAddressHolder(expr.expr, AddressType.RVALUE, node.location);\n        }\n\n        if ( !(expr.expr instanceof WAddressHolder)) {\n            throw new InternalError(`if( !(expr.expr instanceof WAddressHolder)) {`);\n        }\n\n        if (expr.type instanceof ClassType && !toReference) {\n            throw new SyntaxError(`you should not convert a class to rvalue`, node);\n        }\n\n        if ( expr.type instanceof ArrayType ) {\n            if ( toReference ) {\n                throw new SyntaxError(`no reference to array`, node);\n            }\n            expr.type = new PointerType(expr.type.elementType);\n            expr.expr = expr.expr.createLoadAddress(ctx);\n        } else if ( expr.type instanceof LeftReferenceType) {\n            if ( toReference ) {\n                expr.expr = expr.expr.createLoad(ctx, PrimitiveTypes.uint32);\n            } else {\n                expr.type = expr.type.elementType;\n                expr.expr = new WAddressHolder(expr.expr.createLoad(ctx, PrimitiveTypes.uint32),\n                    AddressType.RVALUE, node.location).createLoad(ctx, expr.type);\n            }\n        } else {\n            if ( toReference ) {\n                expr.type = new LeftReferenceType(expr.type);\n                expr.expr = expr.expr.createLoadAddress(ctx);\n            } else {\n                expr.expr = expr.expr.createLoad(ctx, expr.type);\n            }\n        }\n    }\n\n    // array to pointer transform\n    if (expr.type instanceof ArrayType) {\n        expr.type = new PointerType(expr.type.elementType);\n    }\n\n    // func to pointer transform\n    // TODO::\n\n    return expr;\n}\n\nexport function doConversion(ctx: CompileContext, dstType: Type, src: ExpressionResult,\n                             node: Node, force: boolean = false, toReference: boolean = false): WExpression {\n\n    const shouldToReference = toReference && (dstType instanceof LeftReferenceType);\n    src = doValueTransform(ctx, src, node, shouldToReference);\n\n    // to remove??\n    if ( src.type instanceof UnresolvedFunctionOverloadType) {\n        if ( dstType instanceof PointerType && dstType.elementType instanceof FunctionType) {\n            const item = doFunctionOverloadResolution(ctx, src.type.functionLookupResult,\n                dstType.elementType.parameterTypes, node);\n            return new WGetFunctionAddress(item.fullName, node.location);\n        }\n        throw new SyntaxError(`unsupport function name`, node);\n    }\n\n    if ( dstType instanceof LeftReferenceType && src.type instanceof LeftReferenceType) {\n        if ( dstType.equals(src.type)) {\n            return src.expr;\n        }\n    }\n\n    if (dstType instanceof ArrayType) {\n        dstType = new PointerType(dstType.elementType);\n    }\n\n    // arithmetic conversion\n    if (dstType instanceof ArithmeticType && src.type instanceof ArithmeticType) {\n        const srcWType = src.type.toWType();\n        const dstWType = dstType.toWType();\n        const ope = getTypeConvertOpe(srcWType, dstWType);\n        if ( ope !== null ) {\n            return new WCovertOperation(srcWType, dstWType, src.expr, ope, src.expr.location);\n        } else {\n            return src.expr;\n        }\n    }\n\n    // pointer conversion\n\n    if (dstType instanceof PointerType && src.type instanceof PointerType) {\n        const dstElem = dstType.elementType;\n        const srcElem = src.type.elementType;\n        if ( dstElem.equals(PrimitiveTypes.void) || srcElem.equals(dstElem)) {\n            return src.expr;\n        }\n        if ( dstElem instanceof ClassType && srcElem instanceof ClassType ) {\n            // son to parent;\n            if ( srcElem.isSubClassOf(dstElem) ) {\n                return src.expr;\n            }\n        }\n    }\n\n    // 0 to pointer\n\n    if (dstType instanceof PointerType && src.type instanceof IntegerType) {\n        src.expr = src.expr.fold();\n        if ( src.expr instanceof WConst && parseInt(src.expr.constant) === 0) {\n            return src.expr;\n        }\n    }\n\n    if (force) {\n        // [Force] Integer to Pointer\n        if ((dstType instanceof PointerType || dstType instanceof IntegerType)\n            && (src.type instanceof PointerType || src.type instanceof IntegerType)) {\n            return src.expr;\n        }\n\n        // any pointer to any pointer\n        if (dstType instanceof PointerType && src.type instanceof PointerType) {\n            return src.expr;\n        }\n    }\n\n    throw new TypeError(`unsupport convert from ${src.type} to ${dstType}`, node);\n}\n\nexport function getInStackSize(size: number): number {\n    if ( size % 4 === 0) { return size; }\n    return size + 4 - (size % 4);\n}\n\nexport function doValuePromote(ctx: CompileContext, src: ExpressionResult, node: Node): ExpressionResult {\n    src = doValueTransform(ctx, src, node, false);\n    if ( src.type instanceof IntegerType && src.type.length < 4 ) {\n        src.type = PrimitiveTypes.int32;\n    }\n    if ( src.type instanceof FloatType ) {\n        src.expr = doConversion(ctx, PrimitiveTypes.double, src, node);\n        src.type = PrimitiveTypes.double;\n    }\n    return src;\n}\n\nexport function doTypePromote(ctx: CompileContext, src: Type, node: Node): Type {\n    if (src instanceof ArrayType) {\n        src = new PointerType(src.elementType);\n    }\n    if ( src instanceof IntegerType && src.length < 4 ) {\n        src = PrimitiveTypes.int32;\n    }\n    if ( src instanceof FloatType ) {\n        src = PrimitiveTypes.double;\n    }\n    return src;\n}\n","import * as Long from \"long\";\nimport {InternalError, SyntaxError} from \"../../common/error\";\nimport {Node, SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {\n    ArithmeticType, CharType, DoubleType,\n    FloatType, Int16Type,\n    Int32Type,\n    Int64Type,\n    PrimitiveTypes, UnsignedCharType, UnsignedInt16Type,\n    UnsignedInt32Type,\n    UnsignedInt64Type,\n} from \"../../type/primitive_type\";\nimport {WConst, WDrop, WExpression, WExprStatement} from \"../../wasm\";\nimport {CompileContext} from \"../context\";\n\nexport interface ExpressionResult {\n    type: Type;\n    expr: WExpression;\n    isLeft: boolean;\n}\n\nexport abstract class Expression extends Node {\n\n    constructor(location: SourceLocation) {\n        super(location);\n    }\n\n    public abstract codegen(ctx: CompileContext): ExpressionResult;\n\n    public abstract deduceType(ctx: CompileContext): Type;\n\n    public evaluate(ctx: CompileContext): string {\n        const expr = this.codegen(ctx);\n        if (!(expr.type instanceof ArithmeticType)) {\n            throw new SyntaxError(`illegal template parameter`, this);\n        }\n        const wexpr = expr.expr.fold();\n        if (!(wexpr instanceof WConst)) {\n            throw new SyntaxError(`template parameter must be static value`, this);\n        }\n        return wexpr.constant;\n    }\n}\n\nexport function recycleExpressionResult(ctx: CompileContext, node: Node, expr: ExpressionResult) {\n    if (expr.isLeft && expr.expr.isPure()) {\n        return;\n    }\n    if (expr.type.equals(PrimitiveTypes.void)) {\n        ctx.submitStatement(new WExprStatement(expr.expr.fold(), node.location));\n    } else {\n        ctx.submitStatement(new WDrop(expr.expr.fold(), node.location));\n    }\n}\n\nexport function doVarInit(ctx: CompileContext, leftType: Type, rightType: Type,\n                          leftValue: number, rightValue: string, node: Node) {\n    // charptr, int, double\n    // arraybuffer is small endian, exchange required\n    if (leftType instanceof UnsignedCharType) {\n        ctx.memory.data.setUint8(leftValue, parseInt(rightValue));\n    } else if (leftType instanceof CharType) {\n        ctx.memory.data.setInt8(leftValue, parseInt(rightValue));\n    } else if (leftType instanceof UnsignedInt16Type) {\n        ctx.memory.data.setUint16(leftValue, parseInt(rightValue), true);\n    } else if (leftType instanceof UnsignedInt32Type) {\n        ctx.memory.data.setUint32(leftValue, parseInt(rightValue), true);\n    } else if (leftType instanceof UnsignedInt64Type) {\n        ctx.memory.data.setUint32(leftValue, Long.fromString(rightValue).low, true);\n        ctx.memory.data.setUint32(leftValue + 4, Long.fromString(rightValue).low, true);\n    } else if (leftType instanceof Int16Type) {\n        ctx.memory.data.setInt16(leftValue, parseInt(rightValue), true);\n    } else if (leftType instanceof Int32Type) {\n        ctx.memory.data.setInt32(leftValue, parseInt(rightValue), true);\n    } else if (leftType instanceof Int64Type) {\n        ctx.memory.data.setInt32(leftValue, Long.fromString(rightValue).low);\n        ctx.memory.data.setInt32(leftValue + 4, Long.fromString(rightValue).high, true);\n    } else if (leftType instanceof FloatType) {\n        ctx.memory.data.setFloat32(leftValue, parseFloat(rightValue), true);\n    } else if (leftType instanceof DoubleType) {\n        ctx.memory.data.setFloat64(leftValue, parseFloat(rightValue), true);\n    } else {\n        throw new InternalError(`unsupport type assignment`);\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Expression} from \"./expression\";\n\nexport abstract class Constant extends Expression {\n    constructor(location: SourceLocation) {\n        super(location);\n    }\n}\n","import * as Long from \"long\";\nimport {EmptyLocation, SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {WConst} from \"../../wasm\";\nimport {CompileContext} from \"../context\";\nimport {Constant} from \"./constant\";\nimport {ExpressionResult} from \"./expression\";\n\nexport class IntegerConstant extends Constant {\n\n    public static ZeroConstant: Constant;\n\n    public static OneConstant: Constant;\n\n    public static NegOneConstant: Constant;\n\n    public static fromNumber(location: SourceLocation, number: number) {\n        return new IntegerConstant(\n            location,\n            10,\n            Long.fromInt(number),\n            number.toString(),\n            null,\n        );\n    }\n\n    public base: number;\n    public value: Long;\n    public raw: string;\n    public suffix: string | null;\n\n    constructor(location: SourceLocation, base: number, value: Long, raw: string, suffix: string | null) {\n        super(location);\n        this.base = base;\n        this.value = value;\n        this.raw = raw;\n        this.suffix = suffix;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        const type = this.deduceType(ctx);\n        return {\n            type,\n            expr: new WConst(type.toWType(), this.raw, this.location),\n            isLeft: false,\n        };\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        let type = PrimitiveTypes.int32;\n        if (this.suffix) {\n            if (this.suffix.toUpperCase().indexOf(\"U\") !== -1) {\n                if (this.suffix.toUpperCase().indexOf(\"LL\") !== -1) {\n                    type = PrimitiveTypes.uint64;\n                } else {\n                    type = PrimitiveTypes.uint32;\n                }\n            } else {\n                if (this.suffix.toUpperCase().indexOf(\"LL\") !== -1) {\n                    type = PrimitiveTypes.int64;\n                } else {\n                    type = PrimitiveTypes.int32;\n                }\n            }\n        }\n        return type;\n    }\n}\n\nIntegerConstant.ZeroConstant = IntegerConstant.fromNumber(EmptyLocation, 0);\n\nIntegerConstant.OneConstant = IntegerConstant.fromNumber(EmptyLocation, 1);\n\nIntegerConstant.NegOneConstant = IntegerConstant.fromNumber(EmptyLocation, -1);\n","import {SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {CompileContext} from \"../context\";\nimport {Expression, ExpressionResult} from \"./expression\";\n\nexport class AnonymousExpression extends Expression {\n    public expr: ExpressionResult;\n\n    constructor(location: SourceLocation, expr: ExpressionResult) {\n        super(location);\n        this.expr = expr;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        return this.expr;\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        return this.expr.type;\n    }\n}\n\nexport class AnonymousCastExpression extends Expression {\n    public expr: Expression;\n    public type: Type;\n\n    constructor(location: SourceLocation, expr: Expression, type: Type) {\n        super(location);\n        this.expr = expr;\n        this.type = type;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        const result = this.expr.codegen(ctx);\n        result.type = this.type;\n        return result;\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        return this.type;\n    }\n\n}\n","import * as Long from \"long\";\nimport {InternalError, SyntaxError, TypeError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {AddressType, FunctionEntity} from \"../../common/symbol\";\nimport {Type} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {ArrayType, PointerType} from \"../../type/compound_type\";\nimport {CppFunctionType, FunctionType, UnresolvedFunctionOverloadType} from \"../../type/function_type\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {\n    I32Binary,\n    WBinaryOperation, WCall,\n    WCallIndirect,\n    WConst,\n    WExpression, WFakeExpression,\n    WGetGlobal, WLoad, WMemoryLocation,\n    WSetGlobal,\n    WStatement,\n    WType,\n} from \"../../wasm\";\nimport {WAddressHolder} from \"../address\";\nimport {MemberExpression} from \"../class/member_expression\";\nimport {CompileContext} from \"../context\";\nimport {doConversion, doTypePromote, doValuePromote, getInStackSize} from \"../conversion\";\nimport {AnonymousExpression} from \"../expression/anonymous_expression\";\nimport {Expression, ExpressionResult} from \"../expression/expression\";\nimport {Identifier} from \"../expression/identifier\";\nimport {IntegerConstant} from \"../expression/integer_constant\";\nimport {UnaryExpression} from \"../expression/unary_expression\";\nimport {doFunctionOverloadResolution, isFunctionExists} from \"../overload\";\n\nexport class CallExpression extends Expression {\n    public callee: Expression;\n    public arguments: Expression[];\n\n    constructor(location: SourceLocation, callee: Expression, myArguments: Expression[]) {\n        super(location);\n        this.callee = callee;\n        this.arguments = myArguments;\n    }\n\n    public getTargetFunction(ctx: CompileContext): FunctionType | FunctionEntity {\n        let calleeType = this.callee.deduceType(ctx);\n\n        if (calleeType instanceof ClassType) {\n            this.callee = new MemberExpression(this.location, this.callee, false,\n                Identifier.fromString(this.location, \"#()\"));\n            calleeType = this.callee.deduceType(ctx);\n        }\n\n        if (calleeType instanceof PointerType && calleeType.elementType instanceof FunctionType) {\n            return calleeType.elementType;\n        }\n\n        if (!(calleeType instanceof UnresolvedFunctionOverloadType)) {\n            throw new TypeError(`the callee is not function`, this);\n        }\n        const lookUpResult = calleeType.functionLookupResult;\n\n        const funcs = lookUpResult.functions.filter((x) => x instanceof FunctionEntity) as FunctionEntity[];\n        let entity: FunctionEntity | null = funcs.length === 0 ? null : funcs[0]!;\n\n        if ( ctx.isCpp() ) {\n            entity = doFunctionOverloadResolution(ctx, lookUpResult,\n                this.arguments.map((x) => x.deduceType(ctx)), this);\n        }\n\n        if (entity === null ) {\n            throw new SyntaxError(`no matching function for ${lookUpResult.functions[0].shortName}`, this);\n        }\n\n        return entity;\n    }\n\n    public generateFunctionBody(ctx: CompileContext, targetFunction: FunctionType | FunctionEntity,\n                                thisPtrs: ExpressionResult[]): [WExpression[], WStatement[]] {\n        const funcType = targetFunction instanceof FunctionEntity ? targetFunction.type : targetFunction;\n        let stackSize = 0;\n        const arguExprTypes = [...thisPtrs.map((x) => x.type), ... this.arguments.map((x) => x.deduceType(ctx))];\n        if (funcType.variableArguments) {\n            for (let i = arguExprTypes.length - 1; i > funcType.parameterTypes.length - 1; i--) {\n                const src = arguExprTypes[i];\n                if (src instanceof ClassType) {\n                    throw new SyntaxError(`class type could not be variable arguments`, this);\n                }\n                const newSrc = doTypePromote(ctx, src, this);\n                stackSize += getInStackSize(newSrc.length);\n            }\n        }\n        for (let i = funcType.parameterTypes.length - 1; i >= 0; i--) {\n            let dstType = funcType.parameterTypes[i];\n            if (dstType instanceof ArrayType) {\n                dstType = new PointerType(dstType.elementType);\n            }\n            if (dstType instanceof ClassType) {\n                stackSize += getInStackSize(dstType.length);\n            } else {\n                if (funcType.variableArguments) {\n                    stackSize += getInStackSize(dstType.length);\n                }\n            }\n        }\n        // compute finish\n\n        ctx.memory.currentState.stackPtr -= stackSize;\n        const arguExprs = [...thisPtrs, ... this.arguments.map((x) => x.codegen(ctx))];\n        ctx.memory.currentState.stackPtr += stackSize;\n\n        if (targetFunction instanceof FunctionEntity && funcType.parameterTypes.length > arguExprs.length) {\n            // could be default parameters\n            for (let i = arguExprs.length; i < funcType.parameterTypes.length; i++) {\n                const init = targetFunction.parameterInits[i];\n                if (init !== null) {\n                    arguExprs.push({\n                        type: funcType.parameterTypes[i],\n                        expr: new WConst(funcType.parameterTypes[i].toWType(),\n                            init, this.location),\n                        isLeft: false,\n                    });\n                } else {\n                    throw new SyntaxError(`function call parameters number mismatch`, this);\n                }\n            }\n        }\n\n        const argus: WExpression[] = [];\n        let stackOffset = ctx.memory.currentState.stackPtr;\n\n        if (funcType.variableArguments) {\n            for (let i = arguExprs.length - 1; i > funcType.parameterTypes.length - 1; i--) {\n                const src = arguExprs[i];\n                if (src.type instanceof ClassType) {\n                    throw new SyntaxError(`class type could not be variable arguments`, this);\n                }\n                const newSrc = doValuePromote(ctx, src, this);\n                stackOffset -= getInStackSize(newSrc.type.length);\n                argus.push(new WFakeExpression(\n                    new WAddressHolder(stackOffset, AddressType.GLOBAL_SP, this.location)\n                        .createStore(ctx, newSrc.type, newSrc.expr, true)\n                    , this.location));\n            }\n            // argus.push(new WConst(WType.u32, this.arguments.length.toString()));\n        } else {\n            if (funcType.parameterTypes.length < this.arguments.length) {\n                throw new SyntaxError(`function call parameters number mismatch`, this);\n            }\n        }\n\n        for (let i = funcType.parameterTypes.length - 1; i >= 0; i--) {\n            let dstType = funcType.parameterTypes[i];\n            if (dstType instanceof ArrayType) {\n                dstType = new PointerType(dstType.elementType);\n            }\n            const src = arguExprs[i];\n            if (dstType instanceof ClassType) {\n                const rightType = src.type;\n                const leftPtrType = new PointerType(dstType);\n                stackOffset -= getInStackSize(dstType.length);\n                const left = new AnonymousExpression(this.location, {\n                    type: leftPtrType,\n                    isLeft: false,\n                    expr: new WAddressHolder(stackOffset, AddressType.GLOBAL_SP, this.location)\n                        .createLoadAddress(ctx),\n                });\n                const right = new AnonymousExpression(this.location, src);\n                const fullName = dstType.fullName + \"::#\" + dstType.shortName;\n                let expr: ExpressionResult;\n                if (isFunctionExists(ctx, fullName, [leftPtrType, rightType], null)) {\n                    expr = new CallExpression(this.location,\n                        Identifier.fromString(this.location, fullName),\n                        [left, right]).codegen(ctx);\n                } else {\n                    const len = dstType.length;\n                    expr = new CallExpression(this.location, Identifier.fromString(this.location, \"::memcpy\"), [\n                        new UnaryExpression(this.location, \"&\", left),\n                        new UnaryExpression(this.location, \"&\", right),\n                        new IntegerConstant(this.location, 10, Long.fromInt(len), len.toString(), null),\n                    ]).codegen(ctx);\n                }\n                argus.push(expr.expr);\n            } else {\n                const srcExpr = doConversion(ctx, dstType, src, this, false, true).fold();\n                if (funcType.variableArguments) {\n                    stackOffset -= getInStackSize(dstType.length);\n                    argus.push(new WFakeExpression(\n                        new WAddressHolder(stackOffset, AddressType.GLOBAL_SP, this.location)\n                            .createStore(ctx, src.type, srcExpr, true)\n                        , this.location));\n                } else {\n                    argus.push(srcExpr);\n                }\n            }\n        }\n        argus.reverse();    // wasm call standard => push $0 first\n\n        const afterStatements: WStatement[] = [];\n\n        if (stackOffset !== 0) {\n            argus.push(new WFakeExpression(new WSetGlobal(WType.u32, \"$sp\",\n                new WBinaryOperation(I32Binary.add,\n                    new WGetGlobal(WType.u32, \"$sp\", this.location),\n                    new WConst(WType.i32, stackOffset.toString(), this.location),\n                    this.location), this.location), this.location));\n            afterStatements.push(new WFakeExpression(new WSetGlobal(WType.u32, \"$sp\",\n                new WBinaryOperation(I32Binary.sub,\n                    new WGetGlobal(WType.u32, \"$sp\", this.location),\n                    new WConst(WType.i32, stackOffset.toString(), this.location),\n                    this.location), this.location), this.location));\n\n        }\n\n        return [argus, afterStatements];\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        const targetFunction = this.getTargetFunction(ctx);\n        const funcType = targetFunction instanceof FunctionEntity ? targetFunction.type : targetFunction;\n        const callee = this.callee.codegen(ctx);\n        const thisPtrs: ExpressionResult[] = [];\n        let VCallExpr: WExpression | null = null;\n        if (targetFunction instanceof FunctionEntity && targetFunction.type.isMemberFunction()) {\n            if (!(callee.type instanceof UnresolvedFunctionOverloadType)) {\n                throw new InternalError(`callee.type instanceof UnresolvedFunctionOverloadType`);\n            }\n            const lookUpResult = callee.type.functionLookupResult;\n            if (lookUpResult.instance === null || lookUpResult.instanceType === null) {\n                throw new SyntaxError(`call a member function must bind a object`, this);\n            }\n            thisPtrs.push({\n                expr: lookUpResult.instance.createLoadAddress(ctx),\n                type: new PointerType(lookUpResult.instanceType),\n                isLeft: false,\n            });\n            if (targetFunction.type.isVirtual && lookUpResult.isDynamicCall) {\n                const vcallSigature =\n                    targetFunction.type.cppFunctionType === CppFunctionType.Destructor ? \"~\" :\n                        targetFunction.shortName.split(\"@\")[0] + \"@\" + targetFunction.type.parameterTypes\n                            .slice(1).map((x) => x.toString()).join(\",\");\n\n                const ret = lookUpResult.instanceType.getVCallInfo(vcallSigature);\n                if ( ret === null) {\n                    throw new SyntaxError(`${targetFunction.shortName} is not a virtual function`, this);\n                }\n                const [vPtrOffset, vFuncOffset] = ret;\n                const vTableExpr = new WLoad(WType.i32, new WBinaryOperation(\n                    I32Binary.add,\n                    lookUpResult.instance.createLoadAddress(ctx),\n                    new WConst(WType.i32, vPtrOffset.toString(), this.location),\n                    this.location), WMemoryLocation.RAW, this.location);\n                VCallExpr = new WLoad(WType.i32, new WBinaryOperation(\n                    I32Binary.add,\n                    vTableExpr,\n                    new WConst(WType.i32, vFuncOffset.toString(), this.location),\n                    this.location), WMemoryLocation.RAW, this.location);\n            }\n        }\n\n        const [argus, afterStatements] = this.generateFunctionBody(ctx, targetFunction, thisPtrs);\n\n        let funcExpr: WExpression;\n\n        if (VCallExpr !== null) {\n            ctx.requiredWASMFuncTypes.add(funcType.toWASMEncoding()); // require by wasm\n            funcExpr = new WCallIndirect(VCallExpr as WExpression,\n                funcType.toWASMEncoding(), argus, afterStatements, this.location);\n        } else {\n            if (targetFunction instanceof FunctionEntity) {\n                funcExpr = new WCall(targetFunction.fullName, argus, afterStatements, this.location);\n            } else {\n                callee.type = PrimitiveTypes.int32;\n                ctx.requiredWASMFuncTypes.add(funcType.toWASMEncoding()); // require by wasm\n                funcExpr = new WCallIndirect(doConversion(ctx, PrimitiveTypes.int32, callee, this),\n                    funcType.toWASMEncoding(), argus, afterStatements, this.location);\n            }\n        }\n\n        if (funcType.returnType instanceof ClassType) {\n            return {\n                type: funcType.returnType,\n                expr: new WAddressHolder(\n                    funcExpr,\n                    AddressType.RVALUE,\n                    this.location),\n                isLeft: true,\n            };\n        } else {\n            return {\n                type: funcType.returnType,\n                expr: funcExpr,\n                isLeft: false,\n            };\n        }\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        const targetFunction = this.getTargetFunction(ctx);\n        if (targetFunction instanceof FunctionEntity) {\n            return targetFunction.type.returnType;\n        } else {\n            return targetFunction.returnType;\n        }\n    }\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 21/07/2018\n */\nimport {InternalError} from \"../common/error\";\nimport {Node} from \"../common/node\";\nimport {ClassType} from \"../type/class_type\";\nimport {LeftReferenceType, ReferenceType} from \"../type/compound_type\";\nimport {PrimitiveTypes} from \"../type/primitive_type\";\nimport {WAddressHolder} from \"./address\";\nimport {CompileContext} from \"./context\";\nimport {ExpressionResult} from \"./expression/expression\";\nimport {FunctionLookUpResult} from \"./scope\";\n\nexport function doReferenceBinding(ctx: CompileContext, dst: ExpressionResult,\n                                   src: ExpressionResult, node: Node) {\n    if (dst.expr instanceof FunctionLookUpResult\n        || src.expr instanceof FunctionLookUpResult) {\n        throw new InternalError(`unsupport function name`);\n    }\n\n    if ( !(dst.type instanceof LeftReferenceType)) {\n        throw new InternalError(`you could only bind to a reference`);\n    }\n\n    if (!(dst.isLeft) || !(dst.expr instanceof WAddressHolder)) {\n        throw new InternalError(`the reference is not a left value`);\n    }\n\n    if ( src.type instanceof ReferenceType ) {\n\n        const sr = src.type.elementType;\n        const dr = dst.type.elementType;\n\n        if ( sr instanceof ClassType && dr instanceof ClassType) {\n            if ( !sr.isSubClassOf(dr) ) {\n                throw new InternalError(`could not convert from ${src.type} to ${dst.type}`);\n            }\n        } else {\n            if ( !src.type.elementType.equals(dst.type.elementType)) {\n                throw new InternalError(`could not convert from ${src.type} to ${dst.type}`);\n            }\n        }\n\n        if (src.expr instanceof WAddressHolder) {\n            src.expr = src.expr.createLoad(ctx, src.type);\n        }\n\n        ctx.submitStatement(dst.expr.createStore(ctx, PrimitiveTypes.uint32,\n            src.expr));\n    } else {\n        const sr = src.type;\n        const dr = dst.type.elementType;\n\n        if ( sr instanceof ClassType && dr instanceof ClassType) {\n            if ( !sr.isSubClassOf(dr) ) {\n                throw new InternalError(`could not convert from ${src.type} to ${dst.type}`);\n            }\n        } else {\n            if ( !src.type.equals(dst.type.elementType)) {\n                throw new InternalError(`could not convert from ${src.type} to ${dst.type}`);\n            }\n        }\n        if (!src.isLeft || !(src.expr instanceof WAddressHolder)) {\n            throw new InternalError(`you could only bind to a left value`);\n        }\n\n        ctx.submitStatement(dst.expr.createStore(ctx, PrimitiveTypes.uint32,\n            src.expr.createLoadAddress(ctx)));\n    }\n\n}\n","import {InternalError, SyntaxError, TypeError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {PointerType} from \"../../type/compound_type\";\nimport {ArithmeticType, IntegerType, PrimitiveTypes} from \"../../type/primitive_type\";\nimport {BinaryOperator, getOpFromStr, I32Binary, WBinaryOperation, WConst, WType} from \"../../wasm\";\nimport {MemberExpression} from \"../class/member_expression\";\nimport {CompileContext} from \"../context\";\nimport {arithmeticDeduce, doConversion, doTypeTransfrom, doValueTransform} from \"../conversion\";\nimport {CallExpression} from \"../function/call_expression\";\nimport {Expression, ExpressionResult, recycleExpressionResult} from \"./expression\";\nimport {Identifier} from \"./identifier\";\nexport class BinaryExpression extends Expression {\n    public operator: string;\n    // + - * / % & | && || < > <= >= == !=\n    public left: Expression;\n    public right: Expression;\n\n    constructor(location: SourceLocation, operator: string, left: Expression, right: Expression) {\n        super(location);\n        if (typeof operator[1] === \"undefined\") { // HACK: for rule '&'!'&' this will receive [\"&\", undefined]\n            this.operator = operator[0];\n        } else {\n            this.operator = operator;\n        }\n        this.left = left;\n        this.right = right;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n\n        if (this.operator === \",\") {\n            recycleExpressionResult(ctx, this, this.left.codegen(ctx));\n            return this.right.codegen(ctx);\n        }\n\n        const leftType = this.left.deduceType(ctx);\n        const rightType = this.right.deduceType(ctx);\n\n        if (leftType instanceof ClassType) {\n            return new CallExpression(this.location,\n                new MemberExpression(this.location, this.left, false,\n                    Identifier.fromString(this.location, \"#\" + this.operator)),\n                [this.right]).codegen(ctx);\n        }\n\n        if (rightType instanceof ClassType) {\n            throw new SyntaxError(`current not support right overload`, this);\n        }\n\n        let left = this.left.codegen(ctx);\n        let right = this.right.codegen(ctx);\n\n        const dstType = this.deduceType(ctx);\n        const op = getOpFromStr(this.operator, dstType.toWType());\n\n        if (op === null) {\n            throw new InternalError(`unsupport op ${this.operator}`);\n        }\n\n        if (dstType instanceof PointerType) {\n            if (left.type instanceof IntegerType) {\n                left = doValueTransform(ctx, left, this);\n                left = {\n                    type: dstType,\n                    isLeft: false,\n                    expr: new WBinaryOperation(I32Binary.mul, left.expr,\n                        new WConst(WType.u32, dstType.elementType.length.toString(), this.location), this.location),\n                };\n            } else if (right.type instanceof IntegerType) {\n                right = doValueTransform(ctx, right, this);\n                right = {\n                    type: dstType,\n                    isLeft: false,\n                    expr: new WBinaryOperation(I32Binary.mul, right.expr,\n                        new WConst(WType.u32, dstType.elementType.length.toString(), this.location), this.location),\n                };\n            }\n        }\n\n        let leftExpr = doConversion(ctx, dstType, left, this);\n        let rightExpr = doConversion(ctx, dstType, right, this);\n\n        if (this.operator === \"&&\" || this.operator === \"||\") {\n            leftExpr = new WBinaryOperation(I32Binary.ne, leftExpr,\n                new WConst(WType.i32, \"0\", this.location), this.location);\n            rightExpr = new WBinaryOperation(I32Binary.ne, rightExpr,\n                new WConst(WType.i32, \"0\", this.location), this.location);\n        }\n\n        return {\n            type: dstType,\n            isLeft: false,\n            expr: new WBinaryOperation(\n                op as BinaryOperator,\n                leftExpr,\n                rightExpr,\n                this.location,\n            ),\n        };\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        const left = doTypeTransfrom(this.left.deduceType(ctx));\n        const right = doTypeTransfrom(this.right.deduceType(ctx));\n\n        if (left instanceof ClassType) {\n            return new CallExpression(this.location,\n                new MemberExpression(this.location, this.left, false,\n                    Identifier.fromString(this.location, \"#\" + this.operator)),\n                [this.right]).deduceType(ctx);\n        }\n\n        if (\"+-*%/\".includes(this.operator)) {\n            if (left instanceof ArithmeticType && right instanceof ArithmeticType) {\n                return arithmeticDeduce(left, right);\n            } else if (left instanceof PointerType || right instanceof PointerType) {\n                if (left instanceof PointerType && right instanceof PointerType) {\n                    throw new TypeError(`could not apply ope on two pointer`, this);\n                }\n                if (left instanceof PointerType) {\n                    if (!(right instanceof IntegerType)) {\n                        throw new TypeError(`could not apply ${right.toString()} to pointer`, this);\n                    }\n                    return left;\n                } else if (right instanceof PointerType) {\n                    if (!(left instanceof IntegerType)) {\n                        throw new TypeError(`could not apply ${left.toString()} to pointer`, this);\n                    }\n                    if (this.operator === \"-\") {\n                        throw new TypeError(`could - a pointer`, this);\n                    }\n                    return right;\n                } else {\n                    throw new TypeError(`bad operator on pointer`, this);\n                }\n            } else {\n                throw new TypeError(`could not apply ${this.operator} on ${left.toString()}`\n                    + ` and ${right.toString()}`, this);\n            }\n        } else if ([\">=\", \"<=\", \">\", \"<\", \"==\", \"!=\"].includes(this.operator)) {\n            if (left instanceof ArithmeticType && right instanceof ArithmeticType) {\n                return PrimitiveTypes.bool;\n            }\n            if (left instanceof PointerType && right instanceof PointerType) {\n                return PrimitiveTypes.bool;\n            }\n            throw new TypeError(`unsupport relation compute`, this);\n        } else if ([\"&&\", \"||\"].includes(this.operator)) {\n            return PrimitiveTypes.bool;\n        } else if ([\"&\", \"|\", \"^\", \">>\", \"<<\"].includes(this.operator)) {\n            if ( !( left instanceof IntegerType && right instanceof IntegerType)) {\n                throw new TypeError(`binary operator could only be applied on integer`, this);\n            }\n            return PrimitiveTypes.int32;\n        } else if (this.operator === \",\") {\n            return this.right.deduceType(ctx);\n        }\n        throw new InternalError(`no impl at BinaryExpression()`);\n    }\n\n}\n","import * as Long from \"long\";\nimport {SyntaxError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {AddressType} from \"../../common/symbol\";\nimport {Type} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {ArrayType, LeftReferenceType, PointerType} from \"../../type/compound_type\";\nimport {CharType, FloatingType, IntegerType} from \"../../type/primitive_type\";\nimport {WConst, WGetAddress, WMemoryLocation} from \"../../wasm\";\nimport {WAddressHolder} from \"../address\";\nimport {MemberExpression} from \"../class/member_expression\";\nimport {CompileContext} from \"../context\";\nimport {doConversion, doReferenceTransform} from \"../conversion\";\nimport {CallExpression} from \"../function/call_expression\";\nimport {isFunctionExists} from \"../overload\";\nimport {doReferenceBinding} from \"../reference\";\nimport {BinaryExpression} from \"./binary_expression\";\nimport {doVarInit, Expression, ExpressionResult} from \"./expression\";\nimport {Identifier} from \"./identifier\";\nimport {IntegerConstant} from \"./integer_constant\";\nimport {UnaryExpression} from \"./unary_expression\";\n\nconst __charptr = new PointerType(new CharType());\nconst __ccharptr = new PointerType(new CharType());\n\nexport class AssignmentExpression extends Expression {\n    public operator: string;\n    public left: Expression;\n    public right: Expression;\n    public isInitExpr: boolean;\n\n    constructor(location: SourceLocation, operator: string, left: Expression, right: Expression) {\n        super(location);\n        this.operator = operator;\n        this.left = left;\n        this.right = right;\n        this.isInitExpr = false;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        if (this.operator !== \"=\") {\n            const ope = this.operator.split(\"=\")[0];\n            this.operator = \"=\";\n            this.right = new BinaryExpression(this.location,\n                ope,\n                this.left,\n                this.right);\n        }\n\n        const leftType = this.left.deduceType(ctx);\n        const rightType = this.right.deduceType(ctx);\n\n        if (leftType instanceof ClassType) {\n            const fullName = leftType.fullName + \"::#=\";\n            if (isFunctionExists(ctx, fullName, [rightType], leftType)) {\n                return new CallExpression(this.location,\n                    new MemberExpression(this.location, this.left, false,\n                        Identifier.fromString(this.location, \"#=\")),\n                    [\n                        this.right]).codegen(ctx);\n            } else {\n                // totally wrong fuck itself\n                if (rightType.equals(leftType)) {\n                    const len = leftType.length;\n                    return new CallExpression(this.location, Identifier.fromString(this.location, \"::memcpy\"), [\n                        new UnaryExpression(this.location, \"&\", this.left),\n                        new UnaryExpression(this.location, \"&\", this.right),\n                        new IntegerConstant(this.location, 10, Long.fromInt(len), len.toString(), null),\n                    ]).codegen(ctx);\n                } else {\n                    const ctorName = leftType.fullName + \"::#\" + leftType.shortName;\n                    const callee = Identifier.fromString(this.location, ctorName);\n                    return new CallExpression(this.location, callee, [\n                        new UnaryExpression(this.location, \"&\", this.left),\n                        this.right,\n                    ]).codegen(ctx);\n                }\n            }\n        }\n\n        let left = this.left.codegen(ctx);\n        const right = this.right.codegen(ctx);\n\n        // reference binding\n        if (this.isInitExpr && left.type instanceof LeftReferenceType) {\n            doReferenceBinding(ctx, left, right, this);\n            return left;\n        }\n\n        left = doReferenceTransform(ctx, left, this);\n\n        if (!left.isLeft || !(left.expr instanceof WAddressHolder)) {\n            throw new SyntaxError(`could not assign to a right value`, this);\n        }\n\n        if (left.type instanceof ArrayType) {\n            throw new SyntaxError(`unsupport array assignment`, this);\n        }\n\n        // 对于初始化表达式 支持常量初始化到data段\n        if (this.isInitExpr && this.left instanceof Identifier &&\n            left.expr.type === AddressType.MEMORY_DATA) {\n            // int & float\n            if (right.expr instanceof WConst &&\n                (right.type instanceof IntegerType || right.type instanceof FloatingType)) {\n                doVarInit(ctx, left.type, right.type, left.expr.place as number,\n                    right.expr.constant, this);\n                return left;\n            }\n            // const char\n            if (right.expr instanceof WGetAddress &&\n                right.expr.form === WMemoryLocation.DATA &&\n                right.type.equals(__ccharptr)) {\n                if (!(left.type.equals(__charptr)) && !(left.type.equals(__ccharptr))) {\n                    throw new SyntaxError(`unsupport init from ${left.type} to ${right.type}`, this);\n                }\n                ctx.memory.data.setUint32(left.expr.place as number, right.expr.offset, true);\n                return left;\n            }\n        }\n\n        /*\n        if (!this.isInitExpr && left.type.isConst) {\n            throw new SyntaxError(`could not assign to const variable`, this);\n        }\n        */\n\n        ctx.submitStatement(left.expr.createStore(ctx, left.type,\n            doConversion(ctx, left.type, right, this).fold()));\n\n        return left;\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        return this.left.deduceType(ctx);\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {CompileContext} from \"../context\";\nimport {BinaryExpression} from \"./binary_expression\";\nimport {Expression, ExpressionResult} from \"./expression\";\nimport {UnaryExpression} from \"./unary_expression\";\nimport {ClassType} from \"../../type/class_type\";\nimport {CallExpression} from \"../function/call_expression\";\nimport {MemberExpression} from \"../class/member_expression\";\nimport {Identifier} from \"./identifier\";\n\nexport class SubscriptExpression extends Expression {\n    public array: Expression;\n    public subscript: Expression;\n    public unaryExpr: UnaryExpression;\n\n    constructor(location: SourceLocation, array: Expression, subscript: Expression) {\n        super(location);\n        this.array = array;\n        this.subscript = subscript;\n        this.unaryExpr = new UnaryExpression(\n            this.location,\n            \"*\",\n            new BinaryExpression(\n                this.location,\n                \"+\",\n                this.array,\n                this.subscript,\n            ),\n        );\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        const leftType = this.array.deduceType(ctx);\n\n        if (leftType instanceof ClassType) {\n            const item = ctx.scopeManager.lookup(\n                leftType.fullName + \"::#[]\",\n            );\n            if (item != null) {\n                return new CallExpression(this.location,\n                    new MemberExpression(this.location, this.array, false,\n                        Identifier.fromString(this.location, \"#[]\")),\n                    [this.subscript]).codegen(ctx);\n            }\n        }\n\n        return this.unaryExpr.codegen(ctx);\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        const leftType = this.array.deduceType(ctx);\n\n        if (leftType instanceof ClassType) {\n            const item = ctx.scopeManager.lookup(\n                leftType.fullName + \"::#[]\",\n            );\n            if (item != null) {\n                return new CallExpression(this.location,\n                    new MemberExpression(this.location, this.array, false,\n                        Identifier.fromString(this.location, \"#[]\")),\n                    [this.subscript]).deduceType(ctx);\n            }\n        }\n\n        return this.unaryExpr.deduceType(ctx);\n    }\n\n}\n","import {InternalError, SyntaxError, TypeError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {ArrayType, LeftReferenceType, PointerType, ReferenceType} from \"../../type/compound_type\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {I32Unary, WConst, WType, WUnaryOperation} from \"../../wasm\";\nimport {WAddressHolder} from \"../address\";\nimport {MemberExpression} from \"../class/member_expression\";\nimport {CompileContext} from \"../context\";\nimport {doConversion, doReferenceTransform, doTypeTransfrom, doValueTransform} from \"../conversion\";\nimport {CallExpression} from \"../function/call_expression\";\nimport {AssignmentExpression} from \"./assignment_expression\";\nimport {BinaryExpression} from \"./binary_expression\";\nimport {Expression, ExpressionResult} from \"./expression\";\nimport {Identifier} from \"./identifier\";\nimport {IntegerConstant} from \"./integer_constant\";\nimport {SubscriptExpression} from \"./subscript_expression\";\n\nexport class UnaryExpression extends Expression {\n    public operator: string; // ++, --, sizeof, *, +, -, !, ~\n    public operand: Expression;\n\n    constructor(location: SourceLocation, operator: string, operand: Expression) {\n        super(location);\n        this.operator = operator;\n        this.operand = operand;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        if (this.operator === \"sizeof\") {\n            return {\n                type: PrimitiveTypes.uint32,\n                expr: new WConst(WType.u32,\n                    this.operand.deduceType(ctx).length.toString(),\n                    this.location,\n                ),\n                isLeft: false,\n            };\n        }\n\n        const leftType = this.operand.deduceType(ctx);\n\n        if (leftType instanceof ClassType) {\n            const item = ctx.scopeManager.lookup(\n                leftType.fullName + \"::#\" + this.operator,\n            );\n            if (item != null) {\n                return new CallExpression(this.location,\n                    new MemberExpression(this.location, this.operand, false,\n                        Identifier.fromString(this.location, \"#\" + this.operator)),\n                    []).codegen(ctx);\n            }\n        }\n\n        if (this.operator === \"++\" || this.operator === \"--\") {\n            return new AssignmentExpression(this.location,\n                \"=\",\n                this.operand,\n                new BinaryExpression(this.location,\n                    this.operator.charAt(0),\n                    this.operand,\n                    IntegerConstant.OneConstant))\n                .codegen(ctx);\n        }\n        if (this.operator === \"&\") {\n            if (this.operand instanceof SubscriptExpression) {\n                return new BinaryExpression(this.location, \"+\",\n                    this.operand.array, this.operand.subscript).codegen(ctx);\n            } else if (this.operand instanceof UnaryExpression && this.operand.operator === \"*\") {\n                return this.operand.operand.codegen(ctx);\n            }\n        }\n        let expr = this.operand.codegen(ctx);\n        if (this.operator === \"*\") {\n            if (expr.type instanceof ReferenceType) {\n                expr = doReferenceTransform(ctx, expr, this);\n            }\n            if (expr.type instanceof PointerType) {\n                return {\n                    isLeft: true,\n                    type: new LeftReferenceType(expr.type.elementType),\n                    expr: expr.expr,\n                };\n            } else {\n                throw new SyntaxError(`you could not apply * on ${expr.type.toString()} `, this);\n            }\n        } else if (this.operator === \"&\") {\n            if (!expr.isLeft || !(expr.expr instanceof WAddressHolder)) {\n                throw new SyntaxError(`you could not get address of a right value `, this);\n            }\n            if (expr.type instanceof ArrayType) {\n                expr.type = expr.type.elementType;\n            }\n            return {\n                isLeft: false,\n                type: new PointerType(expr.type),\n                expr: expr.expr.createLoadAddress(ctx),\n            };\n        } else if (this.operator === \"+\") {\n            return doValueTransform(ctx, this.operand.codegen(ctx), this);\n        } else if (this.operator === \"-\") {\n            return new BinaryExpression(this.location, \"-\",\n                IntegerConstant.ZeroConstant,\n                this.operand,\n            ).codegen(ctx);\n        } else if (this.operator === \"!\") {\n            const value = doConversion(ctx, PrimitiveTypes.int32, this.operand.codegen(ctx), this);\n            return {\n                type: PrimitiveTypes.int32,\n                isLeft: false,\n                expr: new WUnaryOperation(I32Unary.eqz, value, this.location),\n            };\n        } else if (this.operator === \"~\") {\n            return new BinaryExpression(this.location, \"^\",\n                IntegerConstant.NegOneConstant,\n                this.operand,\n            ).codegen(ctx);\n        } else {\n            throw new InternalError(`no_impl at unary ope=${this.operator}`);\n        }\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        if ( this.operator === \"sizeof\") {\n            return PrimitiveTypes.uint32;\n        } else if ( this.operator === \"++\" || this.operator === \"--\") {\n            return new BinaryExpression(this.location,\n                this.operator.charAt(0),\n                this.operand,\n                IntegerConstant.OneConstant)\n                .deduceType(ctx);\n        }\n\n        const leftType = this.operand.deduceType(ctx);\n\n        if (leftType instanceof ClassType) {\n            const item = ctx.scopeManager.lookup(\n                leftType.fullName + \"::#\" + this.operator,\n            );\n            if (item != null) {\n                return new CallExpression(this.location,\n                    new MemberExpression(this.location, this.operand, false,\n                        Identifier.fromString(this.location, \"#\" + this.operator)),\n                    []).deduceType(ctx);\n            }\n        }\n\n        const itemType = doTypeTransfrom(leftType);\n        if (this.operator === \"*\") {\n            if (itemType instanceof PointerType || itemType instanceof ArrayType) {\n                return itemType.elementType;\n            } else if (itemType instanceof LeftReferenceType\n                && (itemType.elementType instanceof PointerType\n                    || itemType.elementType instanceof ArrayType)) {\n                return itemType.elementType.elementType;\n            } else {\n                throw new TypeError(`could not apply * on ${itemType.toString()}`, this);\n            }\n        } else if (this.operator === \"&\") {\n            return new PointerType(itemType);\n        } else if (this.operator === \"!\" || this.operator === \"~\") {\n            return PrimitiveTypes.int32;\n        } else if (this.operator === \"+\" || this.operator === \"-\") {\n            return this.operand.deduceType(ctx);\n        } else {\n            throw new InternalError(`no imple at UnaryExpression().deduce`);\n        }\n    }\n\n}\n","import {InternalError, SyntaxError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Variable} from \"../../common/symbol\";\nimport {Type} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {LeftReferenceType, ReferenceType} from \"../../type/compound_type\";\nimport {UnresolvedFunctionOverloadType} from \"../../type/function_type\";\nimport {WConst, WType} from \"../../wasm\";\nimport {WAddressHolder} from \"../address\";\nimport {CompileContext} from \"../context\";\nimport {doReferenceTransform} from \"../conversion\";\nimport {Expression, ExpressionResult} from \"../expression/expression\";\nimport {Identifier} from \"../expression/identifier\";\nimport {UnaryExpression} from \"../expression/unary_expression\";\nimport {FunctionLookUpResult} from \"../scope\";\n\nexport class MemberExpression extends Expression {\n    public object: Expression;\n    public pointed: boolean;\n    public member: Identifier;\n    public forceDynamic: boolean;\n\n    constructor(location: SourceLocation, object: Expression, pointed: boolean, member: Identifier) {\n        super(location);\n        this.object = object;\n        this.pointed = pointed;\n        this.member = member;\n        this.forceDynamic = false;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n\n        const memberName = this.member.getPlainName(ctx);\n\n        let left = this.pointed ?\n            new UnaryExpression(this.location, \"*\", this.object).codegen(ctx)\n            : this.object.codegen(ctx);\n\n        const isRef = left.type instanceof ReferenceType;\n\n        left = doReferenceTransform(ctx, left, this);\n\n        if (!(left.isLeft && left.expr instanceof WAddressHolder)) {\n            throw new InternalError(`unsupport rvalue of member expression`);\n        }\n\n        if (!(left.type instanceof ClassType)) {\n            throw new SyntaxError(`only struct/class could be get member`, this);\n        }\n\n        const item = left.type.getMember(ctx, memberName);\n\n        if ( item === null ) {\n            throw new SyntaxError(`name ${this.member.getLookupName(ctx)} is not on class `\n                + `${left.type.shortName}`, this);\n        } else if (item instanceof Variable) {\n            // static field\n            return {\n                type: item.type,\n                expr: new WAddressHolder(item.location, item.addressType, this.location),\n                isLeft: true,\n            };\n        } else if (item instanceof FunctionLookUpResult) {\n            item.instance = left.expr;\n            item.instanceType = left.type;\n            if (this.pointed || isRef) {\n                if ( memberName.includes(\"~\") ) {\n                    item.isDynamicCall = this.forceDynamic;\n                } else {\n                    item.isDynamicCall = true;\n                }\n            }\n            return {\n                type: new UnresolvedFunctionOverloadType(item),\n                expr: new WConst(WType.any, \"0\", this.location),\n                isLeft: false,\n            };\n        } else {\n            return {\n                isLeft: true,\n                type: item.type,\n                expr: left.expr.makeOffset(item.startOffset),\n            };\n        }\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n\n        const memberName = this.member.getPlainName(ctx);\n\n        const left = this.pointed ?\n            new UnaryExpression(this.location, \"*\", this.object).deduceType(ctx)\n            : this.object.deduceType(ctx);\n\n        const isRef = left instanceof ReferenceType;\n        let rawType = left;\n        if ( rawType instanceof LeftReferenceType) {\n            rawType = rawType.elementType;\n        }\n        if ( !(rawType instanceof ClassType)) {\n            throw new SyntaxError(`only struct/class could be get member`, this);\n        }\n        const item = rawType.getMember(ctx, memberName);\n\n        if ( item === null ) {\n            throw new SyntaxError(`name ${this.member.getLookupName(ctx)} is not on class ${rawType.shortName}`, this);\n        } else if (item instanceof Variable) {\n            // static field\n            return item.type;\n        } else if (item instanceof FunctionLookUpResult) {\n            item.instanceType = rawType;\n            if (this.pointed || isRef) {\n                if ( memberName.includes(\"~\") ) {\n                    item.isDynamicCall = this.forceDynamic;\n                } else {\n                    item.isDynamicCall = true;\n                }\n            }\n            return new UnresolvedFunctionOverloadType(item);\n        } else {\n            return item.type;\n        }\n    }\n}\n","import {InternalError, SyntaxError} from \"../../common/error\";\nimport {ClassDirective, Node, SourceLocation} from \"../../common/node\";\nimport {AddressType, Variable} from \"../../common/symbol\";\nimport {ClassTemplate, FunctionTemplate} from \"../../common/template\";\nimport {AccessControl, Type} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {ClassSpecifier} from \"../class/class_specifier\";\nimport {CompileContext} from \"../context\";\nimport {EvaluatedTemplateArgument} from \"./template_argument\";\n\nexport class ClassTemplateInstantiation extends ClassDirective {\n    public specifier: ClassSpecifier;\n\n    constructor(location: SourceLocation, specifier: ClassSpecifier) {\n        super(location);\n        this.specifier = specifier;\n    }\n\n    public codegen(ctx: CompileContext): void {\n        const name = this.specifier.identifier;\n        const lookupName = name.getLookupName(ctx);\n        const classTemplate = ctx.scopeManager.lookup(lookupName);\n        if (!(classTemplate instanceof ClassTemplate)) {\n            throw new SyntaxError(`${lookupName} is not a class template`, this);\n        }\n        const args = name.fillInBlank(ctx, name.getLastID().args, classTemplate);\n        const signature = \"<\" + args.map((x) => x.toString).join(\",\") + \">\";\n        const classInstance = ctx.scopeManager.lookup(classTemplate.fullName + signature);\n        if (!classInstance) {\n            instantiateClassTemplate(ctx, classTemplate, args, this);\n        }\n    }\n\n    public declare(ctx: CompileContext, classType: ClassType): void {\n        throw new InternalError(`todo`);\n    }\n\n}\n\nexport function instantiateClassTemplate(ctx: CompileContext,\n                                         classTemplate: ClassTemplate,\n                                         args: EvaluatedTemplateArgument[],\n                                         node: Node): ClassType {\n    const signature = args.map((x) => x.toString()).join(\",\");\n\n    ctx.scopeManager.enterSavedScope(classTemplate.scopeContext);\n    ctx.scopeManager.enterUnnamedScope(true);\n    for (let i = 0; i < args.length; i++) {\n        const name = classTemplate.templateParams[i].name;\n        const arg = args[i];\n        if (arg instanceof Type) {\n            ctx.scopeManager.define(name, arg, node);\n        } else {\n            ctx.scopeManager.define(name, new Variable(\n                name, ctx.scopeManager.getFullName(name), ctx.fileName,\n                classTemplate.templateParams[i].type, AddressType.CONSTANT, arg,\n                AccessControl.Public,\n            ), node);\n        }\n    }\n    let body = classTemplate.classBody;\n    const spec = classTemplate.specializationMap.get(signature);\n    if (spec) {\n        body = spec;\n    }\n\n    // === hack name ===\n    const oldName = body.identifier.name[body.identifier.name.length - 1].name;\n    body.identifier.name[body.identifier.name.length - 1].name += \"<\" + signature + \">\";\n    const instanceName = body.identifier.getShortName(ctx);\n    const classType = body.codegen(ctx);\n    body.identifier.name[body.identifier.name.length - 1].name = oldName;\n\n    ctx.scopeManager.currentContext.scope.children.map((scope) =>\n        ctx.scopeManager.currentContext.scope.parent.children.push(scope));\n    ctx.scopeManager.detachCurrentScope();\n    ctx.scopeManager.exitScope();\n    ctx.scopeManager.define(instanceName, classType, node);\n    ctx.scopeManager.exitScope();\n    return classType;\n}\n","import {InternalError, SyntaxError} from \"../../common/error\";\nimport {Node, SourceLocation} from \"../../common/node\";\nimport {FunctionEntity, Variable} from \"../../common/symbol\";\nimport {ClassTemplate, FunctionTemplate} from \"../../common/template\";\nimport {Type} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {CppFunctionType, UnresolvedFunctionOverloadType} from \"../../type/function_type\";\nimport {WConst, WType} from \"../../wasm\";\nimport {WAddressHolder} from \"../address\";\nimport {MemberExpression} from \"../class/member_expression\";\nimport {CompileContext} from \"../context\";\nimport {FunctionLookUpResult, LookUpResult} from \"../scope\";\nimport {instantiateClassTemplate} from \"../template/class_template_instantiation\";\nimport {TemplateArgument} from \"../template/template_argument\";\nimport {Expression, ExpressionResult} from \"./expression\";\n\nexport enum IDType {\n    ID,\n    TYPE,\n    T_FUNC,\n    T_FUNC_INS,\n    T_CLASS,\n    T_CLASS_INS,\n}\n\nexport class SingleIdentifier extends Node {\n\n    public static fromString(location: SourceLocation, str: string) {\n        return new SingleIdentifier(\n            location, str, IDType.ID, [],\n        );\n    }\n    public name: string;\n    public type: IDType;\n    public args: TemplateArgument[];\n\n    constructor(location: SourceLocation, name: string, type: IDType, args: TemplateArgument[]) {\n        super(location);\n        this.name = name;\n        this.type = type;\n        this.args = args;\n    }\n\n    public clone(): SingleIdentifier {\n        return new SingleIdentifier(this.location, this.name, this.type, this.args);\n    }\n}\n\nexport class Identifier extends Expression {\n\n    public static emptyIdentifier: Identifier;\n\n    public static fromString(location: SourceLocation, str: string) {\n        return new Identifier(location, [new SingleIdentifier(\n            location, str, IDType.ID, [],\n        )], false);\n    }\n\n    public name: SingleIdentifier[];\n    public isFullName: boolean;\n\n    constructor(location: SourceLocation, name: SingleIdentifier[], isFullName: boolean) {\n        super(location);\n        this.name = name;\n        this.isFullName = isFullName;\n    }\n\n    public getLastID(): SingleIdentifier {\n        return this.name[this.name.length - 1];\n    }\n\n    public getType(): IDType {\n        return this.getLastID().type;\n    }\n\n    public clone(): Identifier {\n        return new Identifier(this.location, this.name.map((x) => x.clone()), this.isFullName);\n    }\n\n    public getPlainName(ctx: CompileContext): string {\n        if (!(this.name.length === 1 && (this.name[0].type === IDType.ID || this.name[0].type === IDType.TYPE))) {\n            throw new SyntaxError(`${this.getLookupName(ctx)} is not a valid identifier`, this);\n        }\n        return this.getShortName(ctx);\n    }\n\n    public getShortName(ctx: CompileContext): string {\n        return this.getLastID().name;\n    }\n\n    public getFullName(ctx: CompileContext): string {\n        if (this.isFullName) {\n            return this.getLookupName(ctx);\n        } else {\n            return ctx.scopeManager.getFullName(this.getLookupName(ctx));\n        }\n    }\n\n    public fillInBlank(ctx: CompileContext, args: TemplateArgument[],\n                       template: FunctionTemplate | ClassTemplate) {\n        const templateArguments = args.map((x) => x.evaluate(ctx));\n        while (templateArguments.length < template.templateParams.length) {\n            const init = template.templateParams[templateArguments.length].init;\n            if (init !== null) {\n                templateArguments.push(init);\n            } else {\n                throw new SyntaxError(`template number mismatch of template ${template.shortName}`, this);\n            }\n        }\n        return templateArguments;\n    }\n\n    public getLookupName(ctx: CompileContext): string {\n        let fullName = \"\";\n        if (this.isFullName) {\n            fullName += \"::\";\n        }\n        for (let i = 0; i < this.name.length; i++) {\n            if (i !== 0) {\n                fullName += \"::\";\n            }\n            fullName += this.name[i].name;\n            if (i !== this.name.length - 1 &&\n                (this.name[i].type === IDType.T_FUNC_INS || this.name[i].type === IDType.T_CLASS_INS)) {\n                const templateName = new Identifier(this.location, this.name.slice(0, i + 1), this.isFullName)\n                    .getLookupName(ctx);\n                const templateItem = ctx.scopeManager.lookup(templateName);\n                if (!templateItem) {\n                    throw new SyntaxError(`undefined template name ${fullName}`, this);\n                }\n                if (this.name[i].type === IDType.T_FUNC_INS) {\n                    throw new SyntaxError(`illegal function template name ${fullName}`, this);\n                } else {\n                    if (!(templateItem instanceof ClassTemplate)) {\n                        throw new SyntaxError(`${fullName} is not class template name`, this);\n                    }\n                    const templateArguments = this.fillInBlank(ctx, this.name[i].args, templateItem);\n                    const realName = templateName + \"<\" + templateArguments.join(\",\") + \">\";\n                    const item = ctx.scopeManager.lookup(realName);\n                    if (!item) {\n                        instantiateClassTemplate(ctx, templateItem, templateArguments, this);\n                    }\n                    fullName = realName;\n                }\n            }\n        }\n        return fullName;\n    }\n\n    public tryLookupImplicitThis(ctx: CompileContext): MemberExpression {\n        const thisPtr = ctx.scopeManager.lookup(\"this\");\n        if (thisPtr !== null) {\n            try {\n                return new MemberExpression(this.location, Identifier.fromString(this.location, \"this\"),\n                    true, this);\n            } catch (e) {\n                throw new SyntaxError(`Unresolve Name ${this.getLookupName(ctx)}`, this);\n            }\n        } else {\n            throw new SyntaxError(`Unresolve Name ${this.getLookupName(ctx)}`, this);\n        }\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        const lookupName = this.getLookupName(ctx);\n        let rawItem = ctx.scopeManager.lookup(lookupName);\n        rawItem = this.filterMemberFunction(rawItem);\n        if (!rawItem) {\n            return this.tryLookupImplicitThis(ctx).codegen(ctx);\n        } else if (rawItem instanceof Variable) {\n            return {\n                type: rawItem.type,\n                expr: new WAddressHolder(rawItem.location, rawItem.addressType, this.location),\n                isLeft: true,\n            };\n        } else if (rawItem instanceof FunctionLookUpResult) {\n            return {\n                type: new UnresolvedFunctionOverloadType(rawItem),\n                expr: new WConst(WType.any, \"0\", this.location),\n                isLeft: false,\n            };\n        } else {\n            throw new SyntaxError(`name ${lookupName} is a ${rawItem.constructor.name}`, this);\n        }\n    }\n\n    public filterMemberFunction(rawItem: LookUpResult): LookUpResult{\n        if (rawItem && rawItem instanceof FunctionLookUpResult) {\n            rawItem.functions = rawItem.functions.filter(\n                (x) =>\n                    !(x instanceof FunctionEntity && x.type.cppFunctionType === CppFunctionType.MemberFunction));\n            if (rawItem.functions.length === 0) {\n                rawItem = null;\n            }\n        }\n        return rawItem;\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        const lookupName = this.getLookupName(ctx);\n        let rawItem = ctx.scopeManager.lookup(lookupName);\n        // fix: member fucntion could not be search here\n        rawItem = this.filterMemberFunction(rawItem);\n        if (!rawItem) {\n            return this.tryLookupImplicitThis(ctx).deduceType(ctx);\n        }\n        if (this.getLastID().type === IDType.ID) {\n            if (rawItem instanceof Variable) {\n                return rawItem.type;\n            } else if (rawItem instanceof FunctionLookUpResult) {\n                return new UnresolvedFunctionOverloadType(rawItem);\n            } else {\n                throw new SyntaxError(`name ${lookupName} should be variable`\n                    + ` but it is a ${rawItem.constructor.name}`, this);\n            }\n        } else if (this.getLastID().type === IDType.TYPE) {\n            if (rawItem instanceof Type) {\n                return rawItem;\n            } else {\n                throw new SyntaxError(`name ${lookupName} should be type`\n                    + ` but it is a ${rawItem.constructor.name}`, this);\n            }\n        } else if (this.getLastID().type === IDType.T_FUNC) {\n            throw new SyntaxError(`name ${lookupName} is a function template`, this);\n        } else if (this.getLastID().type === IDType.T_FUNC_INS) {\n            if (rawItem instanceof FunctionLookUpResult) {\n                rawItem.templateArguments = this.getLastID().args.map((arg) => arg.evaluate(ctx));\n                return new UnresolvedFunctionOverloadType(rawItem);\n            } else {\n                throw new SyntaxError(`name ${lookupName} should be template function`\n                    + ` but it is a ${rawItem.constructor.name}`, this);\n            }\n        } else if (this.getLastID().type === IDType.T_CLASS) {\n            throw new SyntaxError(`name ${lookupName} is a class template`, this);\n        } else if (this.getLastID().type === IDType.T_CLASS_INS) {\n            if (rawItem instanceof ClassTemplate) {\n                const templateArguments = this.fillInBlank(ctx, this.getLastID().args, rawItem);\n                const realName = lookupName + \"<\" + templateArguments.join(\",\") + \">\";\n                const item = ctx.scopeManager.lookup(realName);\n                if (!item) {\n                    return instantiateClassTemplate(ctx, rawItem, templateArguments, this);\n                }\n                if (!(item instanceof ClassType)) {\n                    throw new SyntaxError(`name ${lookupName} should be class template`\n                        + ` but it is a ${rawItem.constructor.name}`, this);\n                }\n                return item;\n            } else {\n                throw new SyntaxError(`name ${lookupName} should be template function`\n                    + ` but it is a ${rawItem.constructor.name}`, this);\n            }\n        }\n        throw new InternalError(`unreachable`);\n    }\n}\n","import {InternalError} from \"../../common/error\";\nimport {Node} from \"../../common/node\";\nimport {Variable} from \"../../common/symbol\";\nimport {ClassType} from \"../../type/class_type\";\nimport {CompileContext} from \"../context\";\nimport {recycleExpressionResult} from \"../expression/expression\";\nimport {Identifier} from \"../expression/identifier\";\nimport {CallExpression} from \"../function/call_expression\";\nimport {MemberExpression} from \"./member_expression\";\n\nexport function triggerDestructor(ctx: CompileContext, obj: Variable, node: Node) {\n    const classType = obj.type;\n    if (!(classType instanceof ClassType)) {\n        throw new InternalError(`triggerDestructor()`);\n    }\n    const fullName = classType.fullName + \"::~\" + classType.shortName;\n    const dtor = ctx.scopeManager.lookup(fullName);\n    if (dtor === null) {\n        return;\n    }\n    recycleExpressionResult(ctx, node,\n        new CallExpression(node.location,\n            new MemberExpression(node.location, Identifier.fromString(node.location, obj.shortName),\n                false, Identifier.fromString(node.location, \"~\" + classType.shortName)), [],\n        ).codegen(ctx));\n\n}\n\nexport function triggerAllDestructor(ctx: CompileContext, node: Node) {\n    for (const item of ctx.scopeManager.currentContext.scope.map.values()) {\n        const x = item[0];\n        if (x instanceof Variable && x.type instanceof ClassType) {\n            triggerDestructor(ctx, x, node);\n        }\n    }\n}\n","import {Directive, SourceLocation} from \"../../common/node\";\n\nexport abstract class Statement extends Directive {\n    protected constructor(location: SourceLocation) {\n        super(location);\n    }\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {ClassType} from \"../../type/class_type\";\nimport {LeftReferenceType, ReferenceType} from \"../../type/compound_type\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {WGetLocal, WReturn, WSetGlobal, WType} from \"../../wasm\";\nimport {WAddressHolder} from \"../address\";\nimport {triggerAllDestructor} from \"../class/destructor\";\nimport {CompileContext} from \"../context\";\nimport {doConversion, doReferenceTransform} from \"../conversion\";\nimport {Expression} from \"../expression/expression\";\nimport {Statement} from \"../statement/statement\";\n\nexport class ReturnStatement extends Statement {\n    public argument: Expression | null;\n\n    constructor(location: SourceLocation, argument: Expression | null) {\n        super(location);\n        this.argument = argument;\n    }\n\n    public codegen(ctx: CompileContext): void {\n        if (ctx.currentFuncContext.currentFunction === null) {\n            throw new SyntaxError(`return outside function`, this);\n        }\n        // $sp = sp\n        triggerAllDestructor(ctx, this);\n\n        ctx.submitStatement(\n            new WSetGlobal(WType.u32, \"$sp\",\n                new WGetLocal(WType.u32, ctx.currentFuncContext.currentFunction.$sp, this.location), this.location));\n\n        if (this.argument !== null) {\n            const returnType = ctx.currentFuncContext.currentFunction.type.returnType;\n            if (returnType.equals(PrimitiveTypes.void)) {\n                throw new SyntaxError(`return type mismatch`, this);\n            }\n            let expr = this.argument.codegen(ctx);\n            if (returnType instanceof ClassType || returnType instanceof ReferenceType) {\n                if (expr.type instanceof LeftReferenceType) {\n                    expr = doReferenceTransform(ctx, expr, this);\n                }\n                if (!(expr.isLeft) || !(expr.expr instanceof WAddressHolder)) {\n                    throw new SyntaxError(`return a rvalue of reference`, this);\n                }\n                ctx.submitStatement(new WReturn(expr.expr.createLoadAddress(ctx), this.location));\n            } else {\n                expr.expr = doConversion(ctx, ctx.currentFuncContext.currentFunction.type.returnType, expr, this);\n                ctx.submitStatement(new WReturn(expr.expr.fold(), this.location));\n            }\n        } else {\n            if (!ctx.currentFuncContext.currentFunction.type.returnType.equals(PrimitiveTypes.void)) {\n                throw new SyntaxError(`return type mismatch`, this);\n            }\n            ctx.submitStatement(new WReturn(null, this.location));\n        }\n    }\n\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {Directive, Node} from \"../../common/node\";\nimport {AddressType, FunctionEntity, Variable} from \"../../common/symbol\";\nimport {AccessControl} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {ArrayType} from \"../../type/compound_type\";\nimport {FunctionType} from \"../../type/function_type\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {\n    getNativeType,\n    I32Binary,\n    WBinaryOperation,\n    WBlock,\n    WConst,\n    WFunction, WFunctionType, WGetGlobal, WGetLocal,\n    WIfElseBlock,\n    WLoop,\n    WReturn, WSetGlobal, WSetLocal, WStatement,\n    WType,\n} from \"../../wasm\";\nimport {CompileContext} from \"../context\";\nimport {getInStackSize} from \"../conversion\";\nimport {IntegerConstant} from \"../expression/integer_constant\";\nimport {getShortName, Scope} from \"../scope\";\nimport {ReturnStatement} from \"./return_statement\";\n\nexport interface FunctionConfig {\n    name: string;\n    functionType: FunctionType;\n    parameterNames: string[];\n    parameterInits: Array<string | null>;\n    accessControl: AccessControl;\n    isLibCall: boolean;\n}\n\nexport function createFunctionEntity(ctx: CompileContext, config: FunctionConfig, isDefine: boolean): FunctionEntity {\n    const baseName = getShortName(config.name);\n    const shortName = baseName + \"@\" + config.functionType.toMangledName();\n    const fullName = ctx.scopeManager.currentContext.scope.fullName + \"::\" + shortName;\n    return new FunctionEntity(shortName, fullName, ctx.fileName,\n        config.functionType, config.parameterInits, config.isLibCall, isDefine, config.accessControl,\n        ctx.scopeManager.currentContext.activeScopes);\n}\n\nexport function declareFunction(ctx: CompileContext, config: FunctionConfig, node: Node) {\n    const functionEntity = createFunctionEntity(ctx, config, false);\n    if (config.isLibCall) {\n        functionEntity.shortName = functionEntity.shortName.split(\"@\")[0];\n        functionEntity.fullName = functionEntity.fullName.split(\"@\")[0]; // libcall no overload\n        const returnTypes: WType[] = [];\n        const parametersTypes: WType[] = [];\n        for (let i = functionEntity.type.parameterTypes.length - 1; i >= 0; i--) {\n            const paramType = functionEntity.type.parameterTypes[i];\n            if (!(paramType instanceof ClassType || paramType instanceof ArrayType ||\n                (functionEntity.type.variableArguments\n                    && i === functionEntity.type.parameterTypes.length - 1))) {\n                parametersTypes.push(paramType.toWType());\n            }\n        }\n        const returnType = functionEntity.type.returnType;\n        if (!returnType.equals(PrimitiveTypes.void)) {\n            if (returnType instanceof ClassType || returnType instanceof ArrayType) {\n                returnTypes.push(WType.i32);\n            } else {\n                returnTypes.push(getNativeType(returnType.toWType()));\n            }\n        }\n        if (!ctx.scopeManager.lookup(functionEntity.fullName)) {\n            ctx.imports.push({\n                name: functionEntity.fullName,\n                type: new WFunctionType(returnTypes, parametersTypes, node.location),\n            });\n        }\n    }\n    ctx.scopeManager.declare(config.name, functionEntity, node);\n}\n\nexport function defineFunction(ctx: CompileContext, config: FunctionConfig,\n                               body: Directive[], activeScopes: Scope[], node: Node) {\n\n    if (config.parameterInits.length !== config.parameterNames.length\n        || config.parameterNames.length !== config.functionType.parameterTypes.length) {\n        throw new SyntaxError(`parameter length mismatch`, node);\n    }\n    const functionEntity = createFunctionEntity(ctx, config, true);\n\n    // find out the active scopes when declare\n\n    ctx.scopeManager.define(config.name, functionEntity, node);\n    ctx.enterFunction(functionEntity);\n    ctx.scopeManager.activeScopes(activeScopes);\n\n    // alloc parameters\n\n    const returnWTypes: WType[] = [];\n    const parameterWTypes: WType[] = [];\n\n    let stackParameterNow = 0;\n    for (let i = functionEntity.type.parameterTypes.length - 1; i >= 0; i--) {\n        const type = functionEntity.type.parameterTypes[i];\n        const paramName = config.parameterNames[i];\n        if (!paramName) {\n            throw new SyntaxError(`unnamed parameter`, node);\n        }\n        if (type instanceof ClassType || (functionEntity.type.variableArguments)) {\n            ctx.scopeManager.define(paramName, new Variable(\n                paramName, ctx.scopeManager.getFullName(paramName), ctx.fileName,\n                type, AddressType.STACK, stackParameterNow, config.accessControl,\n            ), node);\n            stackParameterNow += getInStackSize(type.length);\n        }\n    }\n    for (let i = 0; i < functionEntity.type.parameterTypes.length; i++) {\n        const type = functionEntity.type.parameterTypes[i];\n        const paramName = config.parameterNames[i];\n        if (!paramName) {\n            throw new SyntaxError(`unnamed parameter`, node);\n        }\n        if (!(type instanceof ClassType || (functionEntity.type.variableArguments))) {\n            parameterWTypes.push(type.toWType());\n            ctx.scopeManager.define(paramName, new Variable(\n                paramName, ctx.scopeManager.getFullName(paramName), ctx.fileName,\n                type, AddressType.LOCAL, ctx.memory.allocLocal(type.toWType(), true),\n                AccessControl.Public,\n            ), node);\n        }\n    }\n\n    const returnType = functionEntity.type.returnType;\n\n    if (!returnType.equals(PrimitiveTypes.void)) {\n        if (returnType instanceof ClassType || returnType instanceof ArrayType) {\n            returnWTypes.push(WType.i32);\n        } else {\n            returnWTypes.push(getNativeType(returnType.toWType()));\n        }\n    }\n\n    // register sp & bp\n    // TODO:: could optimize it out, if offset = 0\n    functionEntity.$sp = ctx.memory.allocLocal(WType.u32);\n\n    // bp = $sp\n    ctx.submitStatement(\n        new WSetLocal(WType.u32, functionEntity.$sp,\n            new WGetGlobal(WType.u32, \"$sp\", node.location), node.location));\n\n    // $sp = $sp - 0\n    const offsetNode = new WConst(WType.i32, \"0\", node.location);\n    ctx.submitStatement(\n        new WSetGlobal(WType.u32, \"$sp\",\n            new WBinaryOperation(I32Binary.add,\n                new WGetLocal(WType.u32, functionEntity.$sp, node.location),\n                offsetNode, node.location), node.location));\n\n    body.map((item) => item.codegen(ctx));\n\n    offsetNode.constant = ctx.memory.currentState.stackPtr.toString();\n\n    const bodyStatements = ctx.getStatementContainer();\n\n    if (!functionEntity.type.returnType.equals(PrimitiveTypes.void)) {\n        let curBlk: WStatement[] = bodyStatements;\n        while (curBlk.length > 0\n        && curBlk[curBlk.length - 1] instanceof WBlock\n        || curBlk[curBlk.length - 1] instanceof WIfElseBlock\n        || curBlk[curBlk.length - 1] instanceof WLoop) {\n            const item = curBlk[curBlk.length - 1];\n            if (item instanceof WBlock || item instanceof WLoop) {\n                curBlk = item.body;\n            } else if (item instanceof WIfElseBlock) {\n                if (item.alternative === null) {\n                    throw new SyntaxError(`not all path of function contains return in `\n                        + `${functionEntity.fullName}`, node);\n                } else {\n                    curBlk = item.alternative;\n                }\n            } else {\n                throw new SyntaxError(`not all path of function contains return in ${functionEntity.fullName}`, node);\n            }\n        }\n        if (curBlk.length === 0 || !(curBlk[curBlk.length - 1] instanceof WReturn)) {\n            throw new SyntaxError(`not all path of function contains return in ${functionEntity.fullName}`, node);\n        }\n        if (bodyStatements.length > 0 && bodyStatements[bodyStatements.length - 1] instanceof WIfElseBlock) {\n            // should do auto injection A FAKE RETURN;\n            new ReturnStatement(node.location, IntegerConstant.ZeroConstant).codegen(ctx);\n        }\n    }\n    const local = ctx.memory.currentState.localTypes;\n    ctx.exitFunction();\n    ctx.submitFunction(new WFunction(\n        functionEntity.fullName,\n        config.functionType.toDisplayString(functionEntity.shortName),\n        returnWTypes,\n        parameterWTypes,\n        local, // TODO:: add local\n        bodyStatements,\n        node.location,\n    ));\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 15/06/2018\n */\nimport {Node} from \"../common/node\";\nimport {AccessControl, Type} from \"../type\";\nimport {PointerType} from \"../type/compound_type\";\nimport {FunctionType} from \"../type/function_type\";\nimport {PrimitiveTypes} from \"../type/primitive_type\";\nimport {CompileContext} from \"./context\";\nimport {TranslationUnit} from \"./declaration/translation_unit\";\nimport {declareFunction} from \"./function/function\";\n\nfunction declareSystemFunction(ctx: CompileContext, name: string, returnType: Type,\n                               parameterType: Type[], node: Node) {\n    declareFunction(ctx, {\n        name,\n        functionType: new FunctionType(returnType, parameterType, false),\n        parameterInits: parameterType.map((x) => null),\n        parameterNames: parameterType.map((x) => \"\"),\n        accessControl: AccessControl.Public,\n        isLibCall: true,\n    }, node);\n}\n\nexport function codegen(root: TranslationUnit, ctx: CompileContext) {\n    const voidT = PrimitiveTypes.void;\n    const voidPtrT = new PointerType(PrimitiveTypes.void);\n    // c++ runtime require memcpy & malloc & free & malloc_array\n    if ( ctx.isCpp() ) {\n        declareSystemFunction(ctx, \"memcpy\", voidT, [voidPtrT, voidPtrT, PrimitiveTypes.uint32], root);\n        declareSystemFunction(ctx, \"memset\", voidT, [voidPtrT, PrimitiveTypes.int32, PrimitiveTypes.uint32], root);\n        declareSystemFunction(ctx, \"malloc\", voidPtrT, [PrimitiveTypes.uint32], root);\n        declareSystemFunction(ctx, \"malloc_array\", voidPtrT, [PrimitiveTypes.uint32, PrimitiveTypes.uint32], root);\n        declareSystemFunction(ctx, \"free\", voidT, [voidPtrT], root);\n    }\n    root.codegen(ctx);\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 16/06/2018\n */\nimport {WType} from \"../wasm\";\n\nexport interface FunctionMemoryState {\n    stackPtr: number;\n    localPtr: number;\n    localTypes: WType[];\n}\n\nexport class MemoryLayout {\n    public states: FunctionMemoryState[];\n    public currentState: FunctionMemoryState;\n    public dataPtr: number;\n    public bssPtr: number;\n    public data: DataView;\n    public dataBuffer: ArrayBuffer;\n    public stringMap: Map<string, number>;\n\n    public MEMORY_$SP: number;\n    public MEMORY_$BP: number;\n\n    constructor(dataSize: number) {\n        this.dataPtr = 0;\n        this.bssPtr = 0;\n        this.dataBuffer = new ArrayBuffer(dataSize);\n        this.data = new DataView(this.dataBuffer);\n        this.stringMap = new Map<string, number>();\n        this.MEMORY_$BP = 0;\n        this.MEMORY_$SP = 0;\n        this.currentState = {\n            stackPtr: 0,\n            localPtr: 0,\n            localTypes: [],\n        };\n        this.states = [];\n    }\n\n    public allocData(size: number): number {\n        const result = this.dataPtr;\n        this.dataPtr += size;\n        return result;\n    }\n\n    public allocBss(size: number): number {\n        const result = this.bssPtr;\n        this.bssPtr += size;\n        return result;\n    }\n\n    public allocLocal(type: WType, param: boolean = false): number {\n        if ( !param ) {\n            this.currentState.localTypes.push(type);\n        }\n        return this.currentState.localPtr++;\n    }\n\n    public allocStack(size: number): number {\n        if ( size % 4 !== 0 ) {\n            size += 4 - (size % 4);     // align to 4;\n        }\n        this.currentState.stackPtr -= size;\n        return this.currentState.stackPtr;\n    }\n\n    public allocString(str: string): number {\n        const item = this.stringMap.get(str)!;\n        if ( item !== undefined) { return item; }\n        const addr = this.allocData(str.length + 1);\n        this.setDataString(addr, str);\n        this.stringMap.set(str, addr);\n        return addr;\n    }\n\n    public setDataString(offset: number, value: string) {\n        for (let i = 0; i < value.length; i ++) {\n            this.data.setUint8(offset + i, value.charCodeAt(i));\n        }\n        this.data.setUint8(offset + value.length, 0);\n    }\n\n    // interrupt safe\n    public enterFunction() {\n        this.states.push(this.currentState);\n        this.currentState = {\n            stackPtr: 0,\n            localPtr: 0,\n            localTypes: [],\n        };\n    }\n\n    // interrupt safe\n    public exitFunction() {\n        this.currentState = this.states.pop()!;\n    }\n\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 15/06/2018\n */\nimport {SourceMapGenerator} from \"source-map\";\nimport {InternalError} from \"../common/error\";\nimport {Node} from \"../common/node\";\nimport {CompiledObject, ImportSymbol} from \"../common/object\";\nimport {AddressType, FunctionEntity, Variable} from \"../common/symbol\";\nimport {AccessControl, Type} from \"../type\";\nimport {WFunction, WExpression, WStatement} from \"../wasm\";\nimport {triggerAllDestructor} from \"./class/destructor\";\nimport {MemoryLayout} from \"./memory\";\nimport {ScopeManager} from \"./scope\";\n\nexport interface CompileOptions {\n    debug?: boolean;\n    isCpp?: boolean;\n}\n\nexport interface CaseContext {\n    statements: WStatement[];\n    value: WExpression | null;\n}\n\nexport interface SwitchContext {\n    cases: CaseContext[];\n}\nexport interface FuncContext {\n    statementContainer: WStatement[];\n    blockLevel: number;\n    switchContext: SwitchContext | null;\n    breakStack: number[];\n    continueStack: number[];\n    currentFunction: FunctionEntity | null;\n}\n\nexport class CompileContext {\n\n    // meta data\n    public fileName: string;\n    public options: CompileOptions;\n\n    // global shared\n    public memory: MemoryLayout;\n    public functionMap: Map<string, FunctionEntity>;\n    public scopeManager: ScopeManager;\n    public requiredWASMFuncTypes: Set<string>;\n    public functions: WFunction[];\n    public imports: ImportSymbol[];\n\n    // function internal\n    public funcContexts: FuncContext[];\n    public currentFuncContext: FuncContext;\n\n    // debug\n    public source?: string;\n    public sourceMap?: SourceMapGenerator;\n\n    constructor(fileName: string, compileOptions: CompileOptions = {},\n                source?: string, sourceMap?: SourceMapGenerator) {\n        this.scopeManager = new ScopeManager(!!compileOptions.isCpp);\n        this.functionMap = new Map<string, FunctionEntity>();\n        this.memory = new MemoryLayout(1000);\n        this.options = compileOptions;\n        this.fileName = fileName;\n        this.sourceMap = sourceMap;\n        this.source = source;\n        this.functions = [];\n        this.imports = [];\n        this.currentFuncContext = {\n            statementContainer: [],\n            switchContext: null,\n            breakStack: [],\n            continueStack: [],\n            blockLevel: 0,\n            currentFunction: null,\n        };\n        this.funcContexts = [];\n        this.requiredWASMFuncTypes = new Set<string>();\n    }\n\n    public isCpp(): boolean {\n        return !!this.options.isCpp;\n    }\n\n    public enterFunction(functionEntity: FunctionEntity) {\n        this.functionMap.set(functionEntity.shortName, functionEntity);\n        this.scopeManager.enterScope(functionEntity.fullName);\n        this.memory.enterFunction();\n        this.funcContexts.push(this.currentFuncContext);\n        this.currentFuncContext = {\n            statementContainer: [],\n            switchContext: null,\n            breakStack: [],\n            continueStack: [],\n            blockLevel: 0,\n            currentFunction: functionEntity,\n        };\n    }\n\n    public exitFunction() {\n        if (this.funcContexts.length <= 0) {\n            throw new InternalError(`this.currentFunction==null`);\n        }\n        this.memory.exitFunction();\n        this.scopeManager.exitScope();\n        this.currentFuncContext = this.funcContexts.pop()!;\n    }\n\n    public enterScope() {\n        this.scopeManager.enterUnnamedScope(false);\n    }\n\n    public exitScope(node: Node) {\n        triggerAllDestructor(this, node);\n        this.scopeManager.exitScope();\n    }\n\n    public setStatementContainer(constainer: WStatement[]) {\n        this.currentFuncContext.statementContainer = constainer;\n    }\n\n    public getStatementContainer(): WStatement[] {\n        return this.currentFuncContext.statementContainer;\n    }\n\n    public submitStatement(statement: WStatement) {\n        this.currentFuncContext.statementContainer.push(statement);\n    }\n\n    public submitFunction(func: WFunction) {\n        this.functions.push(func);\n    }\n\n    public raiseWarning(content: string, node: Node) {\n        console.log(\"[Warning]: \" + content);\n    }\n\n    public toCompiledObject(): CompiledObject {\n        return {\n            fileName: this.fileName,\n            dataSize: this.memory.dataPtr,\n            functions: this.functions,\n            imports: this.imports,\n            exports: [], // TODO:: exports\n            data: this.memory.dataBuffer,\n            globalStatements: this.currentFuncContext.statementContainer,\n            source: this.source,\n            sourceMap: this.sourceMap,\n            requiredWASMFuncTypes: this.requiredWASMFuncTypes,\n            scope: this.scopeManager.root,\n        };\n    }\n\n    public allocTmpVar(type: Type, node: Node): [string, Variable] {\n        const varName = this.scopeManager.allocTmpVarName();\n        const varEntity = new Variable(varName, varName, node.location.fileName, type,\n            AddressType.STACK, this.memory.allocStack(type.length), AccessControl.Public);\n        this.scopeManager.define(varName, varEntity, node);\n        return [varName, varEntity];\n    }\n}\n","/* tslint:disable */\nexport const Headers = new Map<string, string>([[\"arduino.h\",\"\\n#ifndef _ARDUINO_H\\n#define _ARDUINO_H\\n\\n#define HIGH 1\\n#define LOW  0\\n\\n#define INPUT 0\\n#define OUTPUT 1\\n#define INPUT_PULLUP 2\\n\\n#define PI 3.1415926535897932384626433832795\\n#define HALF_PI 1.5707963267948966192313216916398\\n#define TWO_PI 6.283185307179586476925286766559\\n#define DEG_TO_RAD 0.017453292519943295769236907684886\\n#define RAD_TO_DEG 57.295779513082320876798154814105\\n#define EULER 2.718281828459045235360287471352\\n\\n#define SERIAL  0\\n#define DISPLAY 1\\n\\n#define LSBFIRST 0\\n#define MSBFIRST 1\\n\\n#define CHANGE 1\\n#define FALLING 2\\n#define RISING 3\\n\\nstatic const int A0 = 100;\\nstatic const int A1 = 101;\\nstatic const int A2 = 102;\\nstatic const int A3 = 103;\\nstatic const int A4 = 104;\\nstatic const int A5 = 105;\\n\\n#endif\\n\\n__libcall void pinMode(int pin, int mode);\\n__libcall void digitalWrite(int pin, int state);\\n\"],[\"assert.h\",\"#ifndef _ASSERT_H\\n#define _ASSERT_H\\n\\n#ifdef NDEBUG\\n#define assert(EX)\\n#else\\n#define assert(EX) (void)((EX) || (__assert (#EX, __FILE__, __LINE__),0))\\n#endif\\n\\nvoid __assert (const char *msg, const char *file, int line);\\n\\n#endif\"],[\"ctype.h\",\"#ifndef _CTYPE_H\\n#define _CTYPE_H\\n\\n__libcall int isalnum(int);\\n__libcall int isalpha(int);\\n__libcall int isblank(int);\\n__libcall int iscntrl(int);\\n__libcall int isdigit(int);\\n__libcall int isgraph(int);\\n__libcall int islower(int);\\n__libcall int isprint(int);\\n__libcall int ispunct(int);\\n__libcall int isspace(int);\\n__libcall int isupper(int);\\n__libcall int isxdigit(int);\\n__libcall int tolower(int);\\n__libcall int toupper(int);\\n\\n#undef\"],[\"limit.h\",\"#ifndef _LIMIT_H\\n#define _LIMIT_H\\n\\n#define CHAR_BIT 8\\n#define SCHAR_MIN -128\\n#define SCHAR_MAX 127\\n#define UCHAR_MAX 255\\n#define CHAR_MIN 0\\n#define CHAR_MAX 255\\n#define MB_LEN_MAX 1\\n#define SHRT_MIN  -32768\\n#define SHRT_MAX  32767\\n#define USHRT_MAX 65535\\n#define INT_MIN  -2147483648\\n#define INT_MAX  2147483647\\n#define UINT_MAX 4294967296U\\n#define LONG_MIN -2147483648\\n#define LONG_MAX 2147483647\\n#define ULONG_MAX 4294967296U\\n#define LLONG_MIN -9223372036854775807LL\\n#define LLONG_MAX 9223372036854775808LL\\n#define ULLONG_MAX 18446744073709551616\\n\\n#endif\"],[\"math.h\",\"#ifndef _MATH_H\\n#define _MATH_H\\n\\n__libcall double cos(double);\\n__libcall double sin(double);\\n__libcall double tan(double);\\n__libcall double acos(double);\\n__libcall double asin(double);\\n__libcall double atan(double);\\n__libcall double atan2(double, double);\\n\\n__libcall double cosh(double);\\n__libcall double sinh(double);\\n__libcall double tanh(double);\\n__libcall double acosh(double);\\n__libcall double asinh(double);\\n__libcall double atanh(double);\\n\\n__libcall double cbrt(double);\\n__libcall double ceil(double);\\n__libcall double exp(double);\\n__libcall double expm1(double);\\n__libcall double fabs(double);\\n__libcall double floor(double);\\n__libcall double fmax(double, double);\\n__libcall double fmin(double, double);\\n//__libcall double fmod(double, double);\\n__libcall double hypot(double, double);\\n__libcall double log(double);\\n__libcall double log10(double);\\n__libcall double log1p(double);\\n__libcall double log2(double);\\n__libcall double logb(double);\\n__libcall double pow(double, double);\\n__libcall double round(double);\\n__libcall double sinh(double);\\n__libcall double sqrt(double);\\n__libcall double trunc(double);\\n\\n#endif\"],[\"stdarg.h\",\"#ifndef _STDARG_H\\n#define _STDARG_H\\n\\ntypedef void* va_list;\\n#define va_start(ptr,arg) (ptr) = &(arg) + sizeof(arg) + 4\\n#define va_arg(ptr,type) ((ptr) += sizeof(type), *((type *)(ptr - sizeof(type))))\\n#define va_end(ptr) (ptr) = 0;\\n\\n#endif\"],[\"stdio.h\",\"#ifndef _STDIO_H\\n#define _STDIO_H\\n\\n__libcall void dump_stack_info();\\n\\n\\n__libcall int scanf(const char * format, ...);\\n__libcall int printf(const char * format, ...);\\n__libcall int getchar();\\nint puts(const char * str);\\n\\n#endif\"],[\"stdlib.h\",\"#ifndef _STDLIB_H\\n#define _STDLIB_H\\n\\n__libcall void *malloc(unsigned int num_bytes);\\n__libcall void *memset(void * ptr, int ch, unsigned int num_bytes);\\n__libcall void free(void * ptr);\\n__libcall void srand( unsigned seed ):\\n__libcall int rand():\\n\\n#endif\"],[\"string.h\",\"#ifndef _STRING_H\\n#define _STRING_H\\n\\ntypedef unsigned int size_t;\\n__libcall int    memcmp(const void *, const void *, size_t);\\n__libcall void*  memcpy(void *, const void *, size_t);\\n__libcall void*  memset(void *, int, size_t);\\n__libcall void*  memmove(void *, const void *, size_t);\\n\\n__libcall char*  strcpy(char *, const char *);\\n__libcall int    strcmp(const char *, const char *);\\n__libcall char*  strcat(char *, const char *);\\n__libcall size_t strlen(const char *);\\n__libcall char*  strchr(const char *, int);\\n__libcall char*  strncat(char *, const char *, size_t);\\n__libcall int    strncmp(const char *, const char *, size_t);\\n__libcall char*  strncpy(char *, const char *, size_t);\\n\\n/*\\n__libcall void*  memccpy(void *, const void *, int, size_t);\\n__libcall void*  memchr(const void *, int, size_t);\\n__libcall int    strcoll(const char *, const char *);\\n__libcall size_t strcspn(const char *, const char *);\\n__libcall char*  strdup(const char *);\\n__libcall char*  strerror(int);\\n__libcall char*  strpbrk(const char *, const char *);\\n__libcall char*  strrchr(const char *, int);\\n__libcall size_t strspn(const char *, const char *);\\n__libcall char*  strstr(const char *, const char *);\\n__libcall char*  strtok(char *, const char *);\\n__libcall char*  strtok_r(char *, const char *, char **);\\n__libcall size_t strxfrm(char *, const char *, size_t);\\n*/\\n\\n#endif\"],[\"syscall.h\",\"#ifndef _SYSCALL_H\\n#define _SYSCALL_H\\n\\n__libcall int write(unsigned int fd, void * buffer, unsigned int size);\\n__libcall int read(unsigned int fd, void * buffer, unsigned int size);\\n__libcall void memcpy(void * dst, void * src, unsigned int size);\\n__libcall void * malloc(unsigned int size);\\n__libcall void free(void * ptr);\\n__libcall void * malloc_array(unsigned int element_size, unsigned int length);\\n__libcall void __print_stack();\\n#endif\"],[\"time.h\",\"#ifndef _TIME_H\\n#define _TIME_H\\n\\n__libcall int time(void * time_ptr);\\n\\n#endif\"]]);\nexport const Impls = new Map<string, string>([[\"assert.cpp\",\"#include <stdio.h>\\n\\nvoid __assert (const char *msg, const char *file, int line){\\n    //printf(\\\"assert failed in %s#%d: %s\\\", file, line, msg);\\n    //exit(255);\\n}\"]]);\n","import {Runtime} from \"../runtime/runtime\";\n\n// implementation of standard C lib \"math.h\"\n\nfunction _(text: string) {\n    return function(this: Runtime, x: number): number {\n        return (Math as any)[text](x);\n    };\n}\nfunction __(text: string) {\n    return function(this: Runtime, x: number, y: number): number {\n        return (Math as any)[text](x, y);\n    };\n}\n\nexport const abs = _(\"abs\");\nexport const cos = _(\"cos\");\nexport const sin = _(\"sin\");\nexport const tan = _(\"tan\");\nexport const acos = _(\"acos\");\nexport const asin = _(\"asin\");\nexport const atan = _(\"atan\");\n\nexport const cosh = _(\"cosh\");\nexport const sinh = _(\"sinh\");\nexport const tanh = _(\"tanh\");\nexport const acosh = _(\"acosh\");\nexport const asinh = _(\"asinh\");\nexport const atanh = _(\"atanh\");\n\nexport const cbrt = _(\"cbrt\");\nexport const ceil = _(\"ceil\");\nexport const exp = _(\"exp\");\nexport const expm1 = _(\"expm1\");\nexport const fabs = _(\"abs\");\nexport const floor = _(\"floor\");\nexport const log = _(\"log\");\nexport const log10 = _(\"log10\");\nexport const log1p = _(\"log1p\");\nexport const log2 = _(\"log2\");\nexport const logb = _(\"logb\");\nexport const round = _(\"round\");\nexport const sqrt = _(\"sqrt\");\nexport const trunc = _(\"trunc\");\nexport const atan2 = __(\"atan2\");\nexport const pow = __(\"pow\");\nexport const fmax = __(\"max\");\nexport const fmin = __(\"min\");\nexport const hypot = __(\"pow\");\n","import * as Long from \"long\";\nimport {Runtime} from \"../runtime/runtime\";\n\nconst printfBuffer = new ArrayBuffer(1000);\nconst printfView = new DataView(printfBuffer);\n\nfunction vprintf(this: Runtime) {\n    let sp = this.sp;\n    let formatptr = this.memory.getUint32(sp, true);\n    sp += 4;\n    let chr = this.memory.getUint8(formatptr);\n    let size = 0;\n    while ( chr !== 0) {\n        if ( chr === \"%\".charCodeAt(0)) {\n            formatptr ++;\n            let chr2 = String.fromCharCode(this.memory.getUint8(formatptr));\n            let intPart = 0, floatPart = 0, isFloat = false;\n            if ( chr2 === \".\" || (\n                chr2.charCodeAt(0) >= \"0\".charCodeAt(0) &&\n                chr2.charCodeAt(0) <= \"9\".charCodeAt(0))) {\n                while ( chr2 === \".\" || (\n                    chr2.charCodeAt(0) >= \"0\".charCodeAt(0) &&\n                    chr2.charCodeAt(0) <= \"9\".charCodeAt(0))) {\n                    if ( chr2 === \".\") {\n                        isFloat = true;\n                    } else if ( isFloat ) {\n                        floatPart = floatPart * 10 + (+chr2);\n                    } else {\n                        intPart = intPart * 10 + (+chr2);\n                    }\n                    formatptr ++;\n                    chr2 = String.fromCharCode(this.memory.getUint8(formatptr));\n                }\n            }\n            let isLong = false;\n            if ( chr2 === \"l\") {\n                isLong = true;\n                formatptr++;\n                chr2 = String.fromCharCode(this.memory.getUint8(formatptr));\n            }\n            if (chr2 === \"%\") {\n                printfView.setUint8(size, \"%\".charCodeAt(0));\n                size ++;\n            } else if (chr2 === \"d\" || chr2 === \"i\" || chr2 === \"u\" ||\n                chr2 === \"X\" || chr2 === \"x\" || chr2 === \"o\"\n                || chr2 === \"p\" || chr2 === \"n\") {\n                let str: string;\n                if (chr2 === \"u\" || chr2 === \"X\" || chr2 === \"x\" || chr2 === \"o\"\n                    || chr2 === \"p\") {\n                    let radix = 10;\n                    if (chr2 === \"X\" || chr2 === \"x\" || chr2 === \"p\") {\n                        radix = 16;\n                    } else if (chr2 === \"o\") {\n                        radix = 8;\n                    }\n                    if (!isLong) {\n                        str = this.memory.getUint32(sp, true).toString(radix);\n                        sp += 4;\n                    } else {\n                        const low = this.memory.getUint32(sp, true);\n                        const high = this.memory.getUint32(sp + 4, true);\n                        str = Long.fromBits(low, high).toString(radix);\n                        sp += 8;\n                    }\n                } else {\n                    if (!isLong) {\n                        str = this.memory.getInt32(sp, true).toString();\n                        sp += 4;\n                    } else {\n                        const low = this.memory.getUint32(sp, true);\n                        const high = this.memory.getInt32(sp + 4, true);\n                        str = Long.fromBits(low, high).toString();\n                        sp += 8;\n                    }\n                }\n                if (chr2 === \"n\") {\n                    str = \"\";\n                }\n                for (let j = 0; j < str.length; j++) {\n                    printfView.setUint8(size, str.charCodeAt(j));\n                    size++;\n                }\n            } else if (chr2 === \"s\") {\n                let strptr = this.memory.getInt32(sp, true);\n                sp += 4;\n                let strchr = this.memory.getUint8(strptr);\n                while (strchr !== 0) {\n                    printfView.setUint8(size, strchr);\n                    size ++;\n                    strptr++;\n                    strchr = this.memory.getUint8(strptr);\n                }\n            } else if (chr2 === \"f\") {\n                let str: string;\n                str = this.memory.getFloat64(sp, true).toString();\n                sp += 8;\n                if ( floatPart !== 0) {\n                    const tokens = str.split(\".\");\n                    if (tokens.length >= 2) {\n                        tokens[1] = tokens[1].substr(0, floatPart);\n                    }\n                    str = tokens.join(\".\");\n                }\n                for (let j = 0; j < str.length; j++) {\n                    printfView.setUint8(size, str.charCodeAt(j));\n                    size++;\n                }\n            } else {\n                printfView.setUint8(size, \"%\".charCodeAt(0));\n                size++;\n                printfView.setUint8(size, chr2.charCodeAt(0));\n                size ++;\n            }\n        } else {\n            printfView.setUint8(size, chr);\n            size ++;\n        }\n        formatptr ++;\n        chr = this.memory.getUint8(formatptr);\n    }\n    return size;\n}\n\nexport function printf(this: Runtime): number {\n    const size = vprintf.apply(this);\n    const file = this.files[1];\n    return file.write(printfBuffer.slice(0, size));\n}\n\nexport function sprintf(this: Runtime): number {\n    const strptr = this.memory.getUint32(this.sp, true);\n    this.sp += 4;\n    const size = vprintf.apply(this);\n    this.sp -= 4;\n    for (let i = 0; i < size; i++) {\n        this.memory.setUint8(strptr + i, printfView.getUint8(i));\n    }\n    return size;\n}\n\nconst inputBuffer = new ArrayBuffer(10);\nconst inputView = new DataView(inputBuffer);\n\nexport function getchar(this: Runtime): number {\n    if ( this.files[0].read(inputBuffer, 0, 1) === 0 ) {\n        return -1;\n    }\n    return inputView.getUint8(0);\n}\n\nconst CC_0 = \"0\".charCodeAt(0);\nconst CC_9 = \"9\".charCodeAt(0);\nconst CC_S = \" \".charCodeAt(0);\nconst CC_TAB = \"\\t\".charCodeAt(0);\nconst CC_NL = \"\\n\".charCodeAt(0);\nconst CC_L = \"-\".charCodeAt(0);\nconst CC_P = \".\".charCodeAt(0);\n\nexport function scanf(this: Runtime): number {\n    let result = 0;\n    let sp = this.sp;\n    let formatptr = this.memory.getUint32(sp, true);\n    sp += 4;\n    let chr = this.memory.getUint8(formatptr);\n    while ( chr !== 0) {\n        if ( chr === \"%\".charCodeAt(0)) {\n            formatptr ++;\n            let chr2 = String.fromCharCode(this.memory.getUint8(formatptr));\n            let isLong = false;\n            if ( chr2 === \"l\") {\n                isLong = true;\n                formatptr++;\n                chr2 = String.fromCharCode(this.memory.getUint8(formatptr));\n            }\n            if (chr2 === \"d\" || chr2 === \"i\" || chr2 === \"u\") {\n                const controlCH = chr2;\n                let val = Long.fromNumber(0);\n                let isNeg = 0;\n                let ch = getchar.apply(this), last = 0;\n                while (ch !== -1 && !(ch >= CC_0 && ch <= CC_9)) {\n                    last = ch;\n                    ch = getchar.apply(this);\n                }\n                if ( last === CC_L) {\n                    isNeg = 1;\n                }\n                while (ch !== -1 && ch >= CC_0 && ch <= CC_9) {\n                    val = val.mul(10).add(ch - CC_0);\n                    ch = getchar.apply(this);\n                }\n                const addr = this.memory.getInt32(sp, true);\n                sp += 4;\n                if ( isNeg ) {\n                    val = val.neg();\n                }\n                if (controlCH === \"u\") {\n                    if ( isLong ) {\n                        this.memory.setUint32(addr, val.low, true);\n                        this.memory.setUint32(addr + 4, val.high, true);\n                    } else {\n                        this.memory.setUint32(addr, val.toNumber(), true);\n                    }\n                } else {\n                    if ( isLong ) {\n                        this.memory.setInt32(addr, val.low, true);\n                        this.memory.setUint32(addr + 4, val.high, true);\n                    } else {\n                        this.memory.setInt32(addr, val.toNumber(), true);\n                    }\n                }\n\n                result ++;\n            } else if (chr2 === \"s\") {\n                let addr = this.memory.getInt32(sp, true);\n                let ch = getchar.apply(this);\n                while ( ch !== -1 && ch !== CC_NL && ch !== CC_S\n                && ch !== CC_TAB) {\n                    this.memory.setUint8(addr++, ch);\n                    ch = getchar.apply(this);\n                }\n                result ++;\n            } else if (chr2 === \"f\") {\n                let val = 0;\n                let isNeg = 0;\n                let ch = getchar.apply(this), last = 0;\n                while (ch !== -1 && !(ch >= CC_0 && ch <= CC_9 || ch === CC_P)) {\n                    last = ch;\n                    ch = getchar.apply(this);\n                }\n                if ( last === CC_L) {\n                    isNeg = 1;\n                }\n                let havePoint = 0, base = 0.1;\n                while (ch !== -1 &&\n                ((ch >= CC_0 && ch <= CC_9) || (!havePoint && ch === CC_P))) {\n                    if (ch === CC_P) {\n                        havePoint = 1;\n                    } else {\n                        if (havePoint) {\n                            val = val + (ch - CC_0) * base;\n                            base /= 10;\n                        } else {\n                            val = val * 10 + ch - CC_0;\n                        }\n                    }\n                    ch = getchar.apply(this);\n                }\n                const addr = this.memory.getInt32(sp, true);\n                sp += 4;\n                if ( isNeg ) {\n                    val = -val;\n                }\n                if ( isLong ) {\n                    this.memory.setFloat64(addr, val, true);\n                } else {\n                    this.memory.setFloat32(addr, val, true);\n                }\n                result ++;\n            }\n        }\n        formatptr ++;\n        chr = this.memory.getUint8(formatptr);\n    }\n    return result;\n}\n","import {Runtime} from \"../runtime/runtime\";\n\n// implementation of standard C lib \"string.h\"\n\nexport function memcpy(this: Runtime, dst: number, src: number, size: number): number {\n    const subarray = this.memoryUint8Array.slice(src, src + size);\n    this.memoryUint8Array.set(subarray, dst);\n    return dst;\n}\n\nexport function memmove(this: Runtime, dst: number, src: number, size: number): number {\n\n    return dst;\n}\n\nexport function memset(this: Runtime, ptr: number, value: number, size: number): number {\n    const ch = value & 0xFF;\n    for (let i = 0; i < size; i++) {\n        this.memory.setUint8(ptr + i, ch);\n    }\n    return ptr;\n}\n\nexport function strlen(this: Runtime, ptr: number): number {\n    let ch = this.memory.getUint8(ptr);\n    let len = 0;\n    while (ch !== 0) {\n        ptr ++; len ++;\n        ch = this.memory.getUint8(ptr);\n    }\n    return len;\n}\n\nexport function strcpy(this: Runtime, dst: number, src: number): number {\n    let ddst = dst, ssrc = src;\n    let ch = this.memory.getUint8(ssrc);\n    while (ch !== 0) {\n        this.memory.setUint8(ddst, ch);\n        ssrc ++; ddst++;\n        ch = this.memory.getUint8(ssrc);\n    }\n    return dst;\n}\n\nexport function strcmp(this: Runtime, dst: number, src: number): number {\n    let lhs = this.memory.getUint8(src);\n    let rhs = this.memory.getUint8(dst);\n    while (rhs === lhs && rhs !== 0) {\n        src++;\n        dst++;\n        lhs = this.memory.getUint8(src);\n        rhs = this.memory.getUint8(dst);\n    }\n    if (lhs > rhs) {\n        return 1;\n    } else if (lhs === rhs) {\n        return 0;\n    } else {\n        return -1;\n    }\n}\n\nexport function strcat(this: Runtime, dst: number, src: number): number {\n    let ddst = dst;\n    let ch = this.memory.getUint8(ddst);\n    while (ch !== 0) {\n        ddst ++;\n        ch = this.memory.getUint8(ddst);\n    }\n    ch = this.memory.getUint8(src);\n    while (ch !== 0) {\n        this.memory.setUint8(ddst, ch);\n        ddst ++;\n        src ++;\n        ch = this.memory.getUint8(src);\n    }\n    this.memory.setUint8(ddst, 0);\n    return dst;\n}\n\nexport function strchr(this: Runtime, ptr: number, chr: number): number {\n    let ch = this.memory.getUint8(ptr);\n    while (ch !== 0) {\n        if (ch === chr) {\n            return ptr;\n        }\n        ptr ++;\n        ch = this.memory.getUint8(ptr);\n    }\n    return 0;\n}\n\nexport function strncpy(this: Runtime, dst: number, src: number, size: number): number {\n    let flag = 0;\n    for (let i = 0; i < size; i++) {\n        const ch = this.memory.getUint8(src + i);\n        if (ch === 0) {\n            flag = 1;\n        }\n        if (flag) {\n            this.memory.setUint8(dst + i, 0);\n        } else {\n            this.memory.setUint8(dst + i, ch);\n        }\n    }\n    return dst;\n}\n\nexport function strncmp(this: Runtime, dst: number, src: number, size: number): number {\n    for (let i = 0; i < size; i++) {\n        const lch = this.memory.getUint8(src + i);\n        const rch = this.memory.getUint8(src + i);\n        if (lch < rch) {\n            return -1;\n        }\n        if (rch > lch) {\n            return 1;\n        }\n    }\n    return 0;\n}","import {Runtime} from \"../runtime/runtime\";\n\nconst _a = \"a\".charCodeAt(0);\nconst _A = \"A\".charCodeAt(0);\nconst _z = \"z\".charCodeAt(0);\nconst _Z = \"Z\".charCodeAt(0);\nconst _0 = \"0\".charCodeAt(0);\nconst _9 = \"9\".charCodeAt(0);\nconst _b = \" \".charCodeAt(0);\nconst _t = \"\\t\".charCodeAt(0);\n\nexport function isdigit(this: Runtime, c: number): number {\n    if (c === -1) {\n        return 0;\n    }\n    return +(c >= _0 && c <= _9);\n}\n\nexport function islower(this: Runtime, c: number): number {\n    if (c === -1) {\n        return 0;\n    }\n    return +(c >= _a && c <= _z);\n}\n\nexport function isupper(this: Runtime, c: number): number {\n    if (c === -1) {\n        return 0;\n    }\n    return +(c >= _A && c <= _Z);\n}\n\nexport function isblank(this: Runtime, c: number): number {\n    if (c === -1) {\n        return 0;\n    }\n    return +(c === _b || c === _t);\n}\n\nexport function isspace(this: Runtime, c: number): number {\n    if (c === -1) {\n        return 0;\n    }\n    return +(c === _b || (c >= 0x09 && c <= 0x0D));\n}\n\nexport function iscntrl(this: Runtime, c: number): number {\n    if (c === -1) {\n        return 0;\n    }\n    return +(c <= 0x20 || c === 0x7F);\n}\n\nexport function isgraph(this: Runtime, c: number): number {\n    if (c === -1) {\n        return 0;\n    }\n    return +(c >= 0x21 || c <= 0x7E);\n}\n\nexport function isprint(this: Runtime, c: number): number {\n    if (c === -1) {\n        return 0;\n    }\n    return +(c >= 0x20 || c <= 0x7E);\n}\n\nexport function isalpha(this: Runtime, c: number): number {\n    return islower.call(this, c) || isupper.call(this, c);\n}\n\nexport function isalnum(this: Runtime, c: number): number {\n    return isalpha.call(this, c) || isdigit.call(this, c);\n}\n\nexport function ispunct(this: Runtime, c: number): number {\n    return isgraph.call(this, c) && (+!isalnum.call(this, c));\n}\n\nexport function isxdigit(this: Runtime, c: number): number {\n    if (c === -1) {\n        return -1;\n    }\n    return isdigit.call(this, c) || +(c >= 0x41 && c <= 0x46)\n    || +(c >= 0x5B && c <= 0x60);\n}\n\nexport function toupper(this: Runtime, c: number): number {\n    if (c === -1) {\n        return -1;\n    }\n    if (islower.call(this, c)) {\n        return c - 32;\n    }\n    return c;\n}\n\nexport function tolower(this: Runtime, c: number): number {\n    if (c === -1) {\n        return -1;\n    }\n    if (isupper.call(this, c)) {\n        return c + 32;\n    }\n    return c;\n}\n","import {Runtime} from \"../runtime/runtime\";\n\nexport function malloc(this: Runtime, size: number): number {\n    return this.heapAllocator.allocHeap(this, size);\n}\n\nexport function free(this: Runtime, ptr: number): void {\n    return this.heapAllocator.freeHeap(this, ptr);\n}\n\nexport function malloc_array(this: Runtime, element_size: number, length: number): number {\n    const ptr = this.heapAllocator.allocHeap(this, element_size * length + 4);\n    this.memory.setInt32(ptr, length, true);\n    return ptr + 4;\n}\n\nexport function srand(this: Runtime, ptr: number): void {\n    return;\n}\n\nexport function rand(this: Runtime): number {\n    return parseInt((Math.random() * 0x7FFFFFFF) + \"\");\n}\n","// class Pin\n\n// ------------ЗАЧЕМ-------------\n// этот класс описывает один пин платы\n// за счет этого появляется возможность\n// подключить все что угодно к плате\n// используя плановый NodeManager\n\n// ----------СТРУКТУРА-----------\n// пины имеют информацию о статусе\n// (вкл / выкл) или же напряжение\n// также, пины имеют поле для режимов IO\n// вход / выход\n// так как используется один массив\n// для хранения пинов\n// класс соддержит поле для типа пина\n// цифровой / аналоговый.\n\n// ------------ТИПЫ--------------\n// сейчас класс использует\n// примитивные типы данных для\n// отслеживания значений\n// позже этот класс перейдет на использование\n// типов из NodeManager\n\n// -----------MANAGER--------------\n// NodeManager будет представлять собой\n// способ соединять различные типы\n// элементов к плате\n// привет, полиморфизм.\n\n// keep it simple, stupid\n// cvtps2dq, 2024 - 1T - interpreter-core\n\nclass Pin {\n\n    private _state : number = 0;\n    private _mode : boolean = false;\n    private _type : boolean = false;\n\n    get state(): number {\n        return this._state;\n    }\n\n    set state(value: number) {\n        this._state = value;\n    }\n\n    get mode(): boolean {\n        return this._mode;\n    }\n\n    set mode(value: boolean) {\n        this._mode = value;\n    }\n\n}\n\nexport default Pin;","// arduinoBoard.ts\n\n// ----------КОНТЕКСТ-------------\n// этот класс глобальный.\n// поддерживается только один\n// экземпляр этого класса!\n\n// ----------ПОДДЕРЖКА------------\n// сейчас поддерживается только UNO.\n// этот класс описывает простую\n// модель платы Arduino,\n// с идеей симуляции в реальном времени.\n\n// keep it super simple, stupid.\n// cvtps2dq, 2024 - 1T - interpreter-core\n\nimport Pin from \"./pin\";\n\nclass ArduinoBoard {\n    digitalPins = new Array(13);\n    analogPins = new Array(6);\n    id: string = \"\";\n    constructor(id : string) {\n        this.id = id;\n        for (let i = 0; i <= 18; i++) {\n            this.digitalPins[i] = new Pin();\n        }\n        for (let i = 0; i <= 6; i++) {\n            this.analogPins[i] = new Pin();\n        }\n    }\n\n}\n\nconst arduino = new ArduinoBoard(\"global_board\");\nexport default arduino;","// Arduino.ts\n// Syscall side of the Arduino C++ layer.\n// 2024, cv2 - part of 1T LiveArduino\n\nimport {Runtime} from \"../runtime/runtime\";\nimport arduino from \"../arduino/arduinoBoard\";\n\nfunction debugPrint(text: string){\n    console.log(\"\\x1b[42mliveduino: \" + text + \"\\x1b[0m\");\n}\n\nexport function pinMode(this: Runtime, pin: number, mode: boolean): void {\n        if (pin >= 100){\n            if (pin - 100 <= 6) {\n                arduino.analogPins[pin - 100].mode = mode;\n                debugPrint(`setting analog pin ${pin - 100}, new mode: ${arduino.analogPins[pin - 100].mode ? \"output\" : \"input\"}`);\n            }\n            else {\n                debugPrint(\"This pin does not exist! Arduino UNO only has 6 analog pins!\");\n            }\n        }\n        else {\n            if (pin <= 13) {\n                arduino.digitalPins[pin].mode = mode;\n                debugPrint(`setting digital pin ${pin}, new mode: ${arduino.digitalPins[pin].mode ? \"output\" : \"input\"}`);\n            } else {\n                debugPrint(\"This pin does not exist! Arduino UNO only has 13 digital pins!\");\n            }\n        }\n}\n\nexport function digitalWrite(this: Runtime, pin: number, state: number): void {\n    if (arduino.digitalPins[pin].mode == false) {\n        console.log(`digitalWrite - pin number: ${pin}, Wrong pin mode detected! Current mode is: ${arduino.digitalPins[pin].mode ? \"output\" : \"input\"}`);\n        if (pin == 0)\n            {\n                // @ts-ignore\n                self.postMessage({ err: 0, type: \"arduino.digitalSet\", data: { setPin: \"RX0\", setVal: state, pinType: false }, id: Math.random() * 1000 });\n            }\n        else if (pin == 1) {\n            // @ts-ignore\n            self.postMessage({ err: 0, type: \"arduino.digitalSet\", data: { setPin: \"TX1\", setVal: state, pinType: false }, id: Math.random() * 1000 });\n        }\n        else\n            // @ts-ignore\n            self.postMessage({ err: 0, type: \"arduino.digitalSet\", data: { setPin: pin, setVal: state, pinType: false }, id: Math.random() * 1000 });\n        return;\n    }\n    else if (pin <= 13) {\n        arduino.digitalPins[pin].state = state;\n        console.log(`digitalWrite - pin number: ${pin}, - new value is ${arduino.digitalPins[pin].state}`);\n        if (pin == 0)\n            // @ts-ignore\n            self.postMessage({ err: 0, type: \"arduino.digitalSet\", data: { setPin: \"RX0\", setVal: state, pinType: false }, id: Math.random() * 1000 });\n        else if (pin == 1) {\n            // @ts-ignore\n            self.postMessage({ err: 0, type: \"arduino.digitalSet\", data: { setPin: \"TX1\", setVal: state, pinType: false }, id: Math.random() * 1000 });\n        }\n        else\n            // @ts-ignore\n            self.postMessage({ err: 0, type: \"arduino.digitalSet\", data: { setPin: pin, setVal: state, pinType: false }, id: Math.random() * 1000 });\n    }\n    else {\n        console.log(`digitalWrite - pin number: ${pin}, This pin does not exist! Arduino Uno only has 13 digital pins!`);\n        // @ts-ignore\n        self.postMessage({ err: 1, type: \"arduino.digitalSet\", data: { setPin: pin, setVal: state, pinType: false }, id: Math.random() * 1000 });\n    }\n\n}","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 08/07/2018\n */\nimport {Runtime} from \"../runtime/runtime\";\n\nexport function write(this: Runtime, fd: number, ptr: number, size: number): number {\n    if (fd >= this.files.length) {\n        return -1;\n    }\n    const file = this.files[fd];\n    return file.write(this.memory.buffer.slice(ptr, ptr + size));\n}\n\nexport function read(this: Runtime, fd: number, ptr: number, size: number): number {\n    if (fd >= this.files.length) {\n        return -1;\n    }\n    const file = this.files[fd];\n    return file.read(this.memory.buffer, ptr, size);\n}\n\n\nexport function dump_stack_info(this: Runtime): void {\n    console.log(\"$sp = \" + this.sp);\n}\n\nexport function time(this: Runtime, ptr: number): number {\n    return Math.round((new Date()).getTime() / 1000);\n}\n\n\nexport function __print_stack(this: Runtime) {\n    this.printStack();\n}\n\nexport * from \"./math\";\nexport * from \"./stdio\";\nexport * from \"./string\";\nexport * from \"./ctype\";\nexport * from \"./stdlib\";\nexport * from \"./arduino\"\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 02/07/2018\n */\n\nexport {Headers, Impls} from \"./library\";\nimport * as SysCall from \"./syscall\";\n\nexport const JsAPIMap: { [key: string]: Function } = {...SysCall};\n","import {OpCodes, WASMJSON, WFunctionType, WType} from \"..\";\nimport {EmptyLocation} from \"../../common/node\";\nimport {SourceMap} from \"../../common/object\";\n\n// Web-cpp WASM dumper\nfunction getIndent(x: number): string {\n    let result = \"\";\n    for (let i = 0; i < x; i++) {\n        result += \" \";\n    }\n    return result;\n}\nexport function dumpWASMJSON(json: WASMJSON, source: Map<string, SourceMap>): string {\n    let str = \"\";\n    let indent = 0;\n    let indentstr = \"\";\n    for (const func of json.functions) {\n        const sourceMap = source.get(func.fileName);\n        let nowSourceLine = func.sourceRange[0] - 1;\n        const type = WFunctionType.fromEncoding(func.type, EmptyLocation);\n        str += `func ${func.name} (param ${type.parameters.map((x) => WType[x])})`;\n        str += `(ret ${type.returnTypes.map((x) => WType[x])}) (\\n`;\n        indent += 1; indentstr = getIndent(indent);\n        str += indentstr + `(locals ${func.locals.map((x) => WType[x])})\\n`;\n        for (const ins of func.codes) {\n            if (func.fileName && sourceMap) {\n                while (nowSourceLine <= func.sourceRange[1] && nowSourceLine <= ins[2]) {\n                    str += \"# \" + sourceMap.source[nowSourceLine++] + \"\\n\";\n                }\n            }\n            const opcode = OpCodes.get(ins[0]);\n            str += indentstr + `${opcode} ${ins[1]}\\n`;\n        }\n        if (func.fileName && sourceMap) {\n            while (nowSourceLine <= func.sourceRange[1]) {\n                str += \"# \" + sourceMap.source[nowSourceLine++] + \"\\n\";\n            }\n        }\n        str += \")\\n\";\n        indent -= 1; indentstr = getIndent(indent);\n    }\n    return str;\n}\n","/// <reference path=\"../../node_modules/@types/webassembly-js-api/index.d.ts\" />\n\nimport {LinkerError} from \"../common/error\";\nimport {EmptyLocation} from \"../common/node\";\nimport {BinaryObject, CompiledObject, SourceMap} from \"../common/object\";\nimport {ImportObject} from \"../runtime/runtime\";\nimport {\n    i32, JSONEmitter,\n    u32,\n    WASMEmitter,\n    WCall,\n    WConst, WDataSegment,\n    WFunction, WGetGlobal, WGetLocal,\n    WGlobalVariable,\n    WImportFunction, WImportItem, WImportMemory,\n    WModule, WReturn, WSetGlobal,\n    WType,\n} from \"../wasm\";\nimport {dumpWASMJSON} from \"../wasm/tool/dumper\";\n\n/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 15/07/2018\n */\n\nexport interface LinkOptions {\n    debug?: boolean;\n}\n\nexport function link(fileName: string, objects: CompiledObject[], option: LinkOptions): BinaryObject {\n    const importObjects: string[] = [];\n    const imports: WImportItem[] = [];\n    const functions: WFunction[] = [];\n    const data: WDataSegment[] = [];\n    const initFuncNames: string[] = [];\n    const externVarMap = new Map<string, number>();\n    const sourceMap = new Map<string, SourceMap>();\n    const requiredFuncTypes = new Set<string>();\n\n    // 0. construct sourceMap\n    for (const object of objects) {\n        sourceMap.set(object.fileName, {\n            source: object.source!.split(\"\\n\"),\n            sourceMap: object.sourceMap!,\n            lastLine: 0,\n        });\n        Array.from(object.requiredWASMFuncTypes.keys())\n            .map((x) => requiredFuncTypes.add(x));\n    }\n\n    const entry = [];\n\n    // 1. set function dataStart && bssStart\n    let dataNow = 0;\n    for (const object of objects) {\n        for (const func of object.functions) {\n            func.dataStart = dataNow;\n            func.fileName = object.fileName;\n            if (/^::main@.*/.test(func.name)) {\n                entry.push(func.name);\n            }\n            functions.push(func);\n        }\n        data.push(new WDataSegment(dataNow, object.data.slice(0, object.dataSize), EmptyLocation));\n        const initFuncName = `$init$${object.fileName}`;\n        const initFunc = new WFunction(initFuncName, initFuncName,\n            [], [], [], object.globalStatements, EmptyLocation);\n        initFunc.dataStart = dataNow;\n        functions.push(initFunc);\n        initFuncNames.push(initFuncName);\n        dataNow += object.dataSize;\n    }\n\n    let bssNow = dataNow;\n    for (const object of objects) {\n        for (const func of object.functions) {\n            func.bssStart = bssNow;\n        }\n        bssNow += object.dataSize;\n    }\n\n    const startFunc = new WFunction(\"$start\", \"__start\", [], [], [],\n        initFuncNames.map((name) => new WCall(name, [], [], EmptyLocation)), EmptyLocation);\n    functions.push(startFunc);\n\n    // 2. build extern map\n\n    for (const object of objects) {\n        for (const symbol of object.exports) {\n            const item = externVarMap.get(symbol.name);\n            if ( item ) {\n                throw new LinkerError(`duplicated symbol of ${symbol.name}`);\n            }\n            externVarMap.set(symbol.name, symbol.location);\n        }\n    }\n\n    // 3. merge import obj\n    for (const object of objects) {\n        for (const item of object.imports) {\n            if ( !importObjects.includes(item.name)) {\n                importObjects.push(item.name);\n                imports.push(new WImportFunction(\"system\", item.name,\n                    item.type.returnTypes, item.type.parameters, EmptyLocation));\n            }\n        }\n    }\n\n    // 4. merge scope map\n\n    // Nope, we use only the main scope\n    const scope = objects[objects.length - 1].scope;\n\n    // 5. add import memory\n\n    imports.push(new WImportMemory(\"system\", \"memory\", 1, 10, EmptyLocation));\n\n    functions.push(new WFunction(\"$get_sp\", \"get_sp\", [WType.u32], [], [], [\n        new WReturn(new WGetGlobal(WType.u32,  \"$sp\", EmptyLocation), EmptyLocation),\n    ], EmptyLocation));\n\n    functions.push(new WFunction(\"$set_sp\", \"set_sp\", [], [WType.u32], [], [\n        new WSetGlobal(WType.u32,  \"$sp\", new WGetLocal(WType.u32, 0, EmptyLocation), EmptyLocation),\n    ], EmptyLocation));\n\n    if ( entry.length === 0) {\n        throw new LinkerError(`no main function found`);\n    }\n\n    if (entry.length > 1) {\n        throw new LinkerError(`multiple main function found`);\n    }\n\n    // 6. generate target code\n    const mod = new WModule({\n        functions,\n        imports,\n        exports: [\"$start\", entry[0], \"$get_sp\", \"$set_sp\"],\n        globals: [\n            new WGlobalVariable(\"$sp\", u32, new WConst(u32, \"1000\", EmptyLocation), EmptyLocation),\n        ],\n        data,\n        generateMemory: false,\n        requiredFuncTypes: Array.from(requiredFuncTypes.keys()),\n    }, EmptyLocation);\n\n    // fs.writeFileSync(\"ast.wast\", printWNode(mod), \"utf-8\");\n\n    const emitter = new WASMEmitter(externVarMap, sourceMap);\n    mod.optimize(emitter);\n    mod.emit(emitter);\n\n    const jsonEmitter = new JSONEmitter(externVarMap, sourceMap);\n    mod.optimize(jsonEmitter);\n    mod.emit(jsonEmitter);\n\n    let dumpInfo = \"\";\n    if (option.debug) {\n        // TODO::\n        dumpInfo = dumpWASMJSON(jsonEmitter.getJSON(), sourceMap);\n        console.log(dumpInfo);\n    }\n\n    const heapStart = (parseInt((bssNow + 1) / 4 as any) + 1) * 4;\n    return {\n        fileName,\n        heapStart,\n        entry: entry[0],\n        sourceMap,\n        scope,\n        binary: emitter.toArrayBuffer(),\n        json: jsonEmitter.getJSON(),\n        dumpInfo,\n    };\n}\n","\"use strict\";\n\n/* Array utilities. */\nvar arrays = {\n  range: function(start, stop) {\n    var length = stop - start,\n        result = new Array(length),\n        i, j;\n\n    for (i = 0, j = start; i < length; i++, j++) {\n      result[i] = j;\n    }\n\n    return result;\n  },\n\n  find: function(array, valueOrPredicate) {\n    var length = array.length, i;\n\n    if (typeof valueOrPredicate === \"function\") {\n      for (i = 0; i < length; i++) {\n        if (valueOrPredicate(array[i])) {\n          return array[i];\n        }\n      }\n    } else {\n      for (i = 0; i < length; i++) {\n        if (array[i] === valueOrPredicate) {\n          return array[i];\n        }\n      }\n    }\n  },\n\n  indexOf: function(array, valueOrPredicate) {\n    var length = array.length, i;\n\n    if (typeof valueOrPredicate === \"function\") {\n      for (i = 0; i < length; i++) {\n        if (valueOrPredicate(array[i])) {\n          return i;\n        }\n      }\n    } else {\n      for (i = 0; i < length; i++) {\n        if (array[i] === valueOrPredicate) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  },\n\n  contains: function(array, valueOrPredicate) {\n    return arrays.indexOf(array, valueOrPredicate) !== -1;\n  },\n\n  each: function(array, iterator) {\n    var length = array.length, i;\n\n    for (i = 0; i < length; i++) {\n      iterator(array[i], i);\n    }\n  },\n\n  map: function(array, iterator) {\n    var length = array.length,\n        result = new Array(length),\n        i;\n\n    for (i = 0; i < length; i++) {\n      result[i] = iterator(array[i], i);\n    }\n\n    return result;\n  },\n\n  pluck: function(array, key) {\n    return arrays.map(array, function (e) { return e[key]; });\n  },\n\n  every: function(array, predicate) {\n    var length = array.length, i;\n\n    for (i = 0; i < length; i++) {\n      if (!predicate(array[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  some: function(array, predicate) {\n    var length = array.length, i;\n\n    for (i = 0; i < length; i++) {\n      if (predicate(array[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n};\n\nmodule.exports = arrays;\n","\"use strict\";\n\n/* Object utilities. */\nvar objects = {\n  keys: function(object) {\n    var result = [], key;\n\n    for (key in object) {\n      if (object.hasOwnProperty(key)) {\n        result.push(key);\n      }\n    }\n\n    return result;\n  },\n\n  values: function(object) {\n    var result = [], key;\n\n    for (key in object) {\n      if (object.hasOwnProperty(key)) {\n        result.push(object[key]);\n      }\n    }\n\n    return result;\n  },\n\n  clone: function(object) {\n    var result = {}, key;\n\n    for (key in object) {\n      if (object.hasOwnProperty(key)) {\n        result[key] = object[key];\n      }\n    }\n\n    return result;\n  },\n\n  defaults: function(object, defaults) {\n    var key;\n\n    for (key in defaults) {\n      if (defaults.hasOwnProperty(key)) {\n        if (!(key in object)) {\n          object[key] = defaults[key];\n        }\n      }\n    }\n  }\n};\n\nmodule.exports = objects;\n","\"use strict\";\n\n/* Class utilities */\nvar classes = {\n  subclass: function(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n};\n\nmodule.exports = classes;\n","\"use strict\";\n\nvar classes = require(\"./utils/classes\");\n\n/* Thrown when the grammar contains an error. */\nfunction GrammarError(message, location) {\n  this.name = \"GrammarError\";\n  this.message = message;\n  this.location = location;\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, GrammarError);\n  }\n}\n\nclasses.subclass(GrammarError, Error);\n\nmodule.exports = GrammarError;\n","/* eslint-env node, amd */\n/* eslint no-unused-vars: 0 */\n\n/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { Grammar: peg$parseGrammar },\n      peg$startRuleFunction  = peg$parseGrammar,\n\n      peg$c0 = function(initializer, rules) {\n            return {\n              type:        \"grammar\",\n              initializer: extractOptional(initializer, 0),\n              rules:       extractList(rules, 0),\n              location:    location()\n            };\n          },\n      peg$c1 = function(code) {\n            return { type: \"initializer\", code: code, location: location() };\n          },\n      peg$c2 = \"=\",\n      peg$c3 = peg$literalExpectation(\"=\", false),\n      peg$c4 = function(name, displayName, expression) {\n            return {\n              type:        \"rule\",\n              name:        name,\n              expression:  displayName !== null\n                ? {\n                    type:       \"named\",\n                    name:       displayName[0],\n                    expression: expression,\n                    location:   location()\n                  }\n                : expression,\n              location:    location()\n            };\n          },\n      peg$c5 = \"/\",\n      peg$c6 = peg$literalExpectation(\"/\", false),\n      peg$c7 = function(head, tail) {\n            return tail.length > 0\n              ? {\n                  type:         \"choice\",\n                  alternatives: buildList(head, tail, 3),\n                  location:     location()\n                }\n              : head;\n          },\n      peg$c8 = function(expression, code) {\n            return code !== null\n              ? {\n                  type:       \"action\",\n                  expression: expression,\n                  code:       code[1],\n                  location:   location()\n                }\n              : expression;\n          },\n      peg$c9 = function(head, tail) {\n            return tail.length > 0\n              ? {\n                  type:     \"sequence\",\n                  elements: buildList(head, tail, 1),\n                  location: location()\n                }\n              : head;\n          },\n      peg$c10 = \":\",\n      peg$c11 = peg$literalExpectation(\":\", false),\n      peg$c12 = function(label, expression) {\n            return {\n              type:       \"labeled\",\n              label:      label,\n              expression: expression,\n              location:   location()\n            };\n          },\n      peg$c13 = function(operator, expression) {\n            return {\n              type:       OPS_TO_PREFIXED_TYPES[operator],\n              expression: expression,\n              location:   location()\n            };\n          },\n      peg$c14 = \"$\",\n      peg$c15 = peg$literalExpectation(\"$\", false),\n      peg$c16 = \"&\",\n      peg$c17 = peg$literalExpectation(\"&\", false),\n      peg$c18 = \"!\",\n      peg$c19 = peg$literalExpectation(\"!\", false),\n      peg$c20 = function(expression, operator) {\n            return {\n              type:       OPS_TO_SUFFIXED_TYPES[operator],\n              expression: expression,\n              location:   location()\n            };\n          },\n      peg$c21 = \"?\",\n      peg$c22 = peg$literalExpectation(\"?\", false),\n      peg$c23 = \"*\",\n      peg$c24 = peg$literalExpectation(\"*\", false),\n      peg$c25 = \"+\",\n      peg$c26 = peg$literalExpectation(\"+\", false),\n      peg$c27 = \"(\",\n      peg$c28 = peg$literalExpectation(\"(\", false),\n      peg$c29 = \")\",\n      peg$c30 = peg$literalExpectation(\")\", false),\n      peg$c31 = function(expression) {\n            /*\n             * The purpose of the \"group\" AST node is just to isolate label scope. We\n             * don't need to put it around nodes that can't contain any labels or\n             * nodes that already isolate label scope themselves. This leaves us with\n             * \"labeled\" and \"sequence\".\n             */\n            return expression.type === 'labeled' || expression.type === 'sequence'\n                ? { type: \"group\", expression: expression }\n                : expression;\n          },\n      peg$c32 = function(name) {\n            return { type: \"rule_ref\", name: name, location: location() };\n          },\n      peg$c33 = function(operator, code) {\n            return {\n              type:     OPS_TO_SEMANTIC_PREDICATE_TYPES[operator],\n              code:     code,\n              location: location()\n            };\n          },\n      peg$c34 = peg$anyExpectation(),\n      peg$c35 = peg$otherExpectation(\"whitespace\"),\n      peg$c36 = \"\\t\",\n      peg$c37 = peg$literalExpectation(\"\\t\", false),\n      peg$c38 = \"\\x0B\",\n      peg$c39 = peg$literalExpectation(\"\\x0B\", false),\n      peg$c40 = \"\\f\",\n      peg$c41 = peg$literalExpectation(\"\\f\", false),\n      peg$c42 = \" \",\n      peg$c43 = peg$literalExpectation(\" \", false),\n      peg$c44 = \"\\xA0\",\n      peg$c45 = peg$literalExpectation(\"\\xA0\", false),\n      peg$c46 = \"\\uFEFF\",\n      peg$c47 = peg$literalExpectation(\"\\uFEFF\", false),\n      peg$c48 = /^[\\n\\r\\u2028\\u2029]/,\n      peg$c49 = peg$classExpectation([\"\\n\", \"\\r\", \"\\u2028\", \"\\u2029\"], false, false),\n      peg$c50 = peg$otherExpectation(\"end of line\"),\n      peg$c51 = \"\\n\",\n      peg$c52 = peg$literalExpectation(\"\\n\", false),\n      peg$c53 = \"\\r\\n\",\n      peg$c54 = peg$literalExpectation(\"\\r\\n\", false),\n      peg$c55 = \"\\r\",\n      peg$c56 = peg$literalExpectation(\"\\r\", false),\n      peg$c57 = \"\\u2028\",\n      peg$c58 = peg$literalExpectation(\"\\u2028\", false),\n      peg$c59 = \"\\u2029\",\n      peg$c60 = peg$literalExpectation(\"\\u2029\", false),\n      peg$c61 = peg$otherExpectation(\"comment\"),\n      peg$c62 = \"/*\",\n      peg$c63 = peg$literalExpectation(\"/*\", false),\n      peg$c64 = \"*/\",\n      peg$c65 = peg$literalExpectation(\"*/\", false),\n      peg$c66 = \"//\",\n      peg$c67 = peg$literalExpectation(\"//\", false),\n      peg$c68 = function(name) { return name; },\n      peg$c69 = peg$otherExpectation(\"identifier\"),\n      peg$c70 = function(head, tail) { return head + tail.join(\"\"); },\n      peg$c71 = \"_\",\n      peg$c72 = peg$literalExpectation(\"_\", false),\n      peg$c73 = \"\\\\\",\n      peg$c74 = peg$literalExpectation(\"\\\\\", false),\n      peg$c75 = function(sequence) { return sequence; },\n      peg$c76 = \"\\u200C\",\n      peg$c77 = peg$literalExpectation(\"\\u200C\", false),\n      peg$c78 = \"\\u200D\",\n      peg$c79 = peg$literalExpectation(\"\\u200D\", false),\n      peg$c80 = peg$otherExpectation(\"literal\"),\n      peg$c81 = \"i\",\n      peg$c82 = peg$literalExpectation(\"i\", false),\n      peg$c83 = function(value, ignoreCase) {\n            return {\n              type:       \"literal\",\n              value:      value,\n              ignoreCase: ignoreCase !== null,\n              location:   location()\n            };\n          },\n      peg$c84 = peg$otherExpectation(\"string\"),\n      peg$c85 = \"\\\"\",\n      peg$c86 = peg$literalExpectation(\"\\\"\", false),\n      peg$c87 = function(chars) { return chars.join(\"\"); },\n      peg$c88 = \"'\",\n      peg$c89 = peg$literalExpectation(\"'\", false),\n      peg$c90 = function() { return text(); },\n      peg$c91 = peg$otherExpectation(\"character class\"),\n      peg$c92 = \"[\",\n      peg$c93 = peg$literalExpectation(\"[\", false),\n      peg$c94 = \"^\",\n      peg$c95 = peg$literalExpectation(\"^\", false),\n      peg$c96 = \"]\",\n      peg$c97 = peg$literalExpectation(\"]\", false),\n      peg$c98 = function(inverted, parts, ignoreCase) {\n            return {\n              type:       \"class\",\n              parts:      filterEmptyStrings(parts),\n              inverted:   inverted !== null,\n              ignoreCase: ignoreCase !== null,\n              location:   location()\n            };\n          },\n      peg$c99 = \"-\",\n      peg$c100 = peg$literalExpectation(\"-\", false),\n      peg$c101 = function(begin, end) {\n            if (begin.charCodeAt(0) > end.charCodeAt(0)) {\n              error(\n                \"Invalid character range: \" + text() + \".\"\n              );\n            }\n\n            return [begin, end];\n          },\n      peg$c102 = function() { return \"\"; },\n      peg$c103 = \"0\",\n      peg$c104 = peg$literalExpectation(\"0\", false),\n      peg$c105 = function() { return \"\\0\"; },\n      peg$c106 = \"b\",\n      peg$c107 = peg$literalExpectation(\"b\", false),\n      peg$c108 = function() { return \"\\b\";   },\n      peg$c109 = \"f\",\n      peg$c110 = peg$literalExpectation(\"f\", false),\n      peg$c111 = function() { return \"\\f\";   },\n      peg$c112 = \"n\",\n      peg$c113 = peg$literalExpectation(\"n\", false),\n      peg$c114 = function() { return \"\\n\";   },\n      peg$c115 = \"r\",\n      peg$c116 = peg$literalExpectation(\"r\", false),\n      peg$c117 = function() { return \"\\r\";   },\n      peg$c118 = \"t\",\n      peg$c119 = peg$literalExpectation(\"t\", false),\n      peg$c120 = function() { return \"\\t\";   },\n      peg$c121 = \"v\",\n      peg$c122 = peg$literalExpectation(\"v\", false),\n      peg$c123 = function() { return \"\\x0B\"; },\n      peg$c124 = \"x\",\n      peg$c125 = peg$literalExpectation(\"x\", false),\n      peg$c126 = \"u\",\n      peg$c127 = peg$literalExpectation(\"u\", false),\n      peg$c128 = function(digits) {\n            return String.fromCharCode(parseInt(digits, 16));\n          },\n      peg$c129 = /^[0-9]/,\n      peg$c130 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c131 = /^[0-9a-f]/i,\n      peg$c132 = peg$classExpectation([[\"0\", \"9\"], [\"a\", \"f\"]], false, true),\n      peg$c133 = \".\",\n      peg$c134 = peg$literalExpectation(\".\", false),\n      peg$c135 = function() { return { type: \"any\", location: location() }; },\n      peg$c136 = peg$otherExpectation(\"code block\"),\n      peg$c137 = \"{\",\n      peg$c138 = peg$literalExpectation(\"{\", false),\n      peg$c139 = \"}\",\n      peg$c140 = peg$literalExpectation(\"}\", false),\n      peg$c141 = function(code) { return code; },\n      peg$c142 = /^[{}]/,\n      peg$c143 = peg$classExpectation([\"{\", \"}\"], false, false),\n      peg$c144 = /^[a-z\\xB5\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137-\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148-\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C-\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA-\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9-\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC-\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF-\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F-\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0-\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB-\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE-\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0529\\u052B\\u052D\\u052F\\u0561-\\u0587\\u13F8-\\u13FD\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6-\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FC7\\u1FD0-\\u1FD3\\u1FD6-\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6-\\u1FF7\\u210A\\u210E-\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C-\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65-\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73-\\u2C74\\u2C76-\\u2C7B\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3-\\u2CE4\\u2CEC\\u2CEE\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA699\\uA69B\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA793-\\uA795\\uA797\\uA799\\uA79B\\uA79D\\uA79F\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7B5\\uA7B7\\uA7FA\\uAB30-\\uAB5A\\uAB60-\\uAB65\\uAB70-\\uABBF\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A]/,\n      peg$c145 = peg$classExpectation([[\"a\", \"z\"], \"\\xB5\", [\"\\xDF\", \"\\xF6\"], [\"\\xF8\", \"\\xFF\"], \"\\u0101\", \"\\u0103\", \"\\u0105\", \"\\u0107\", \"\\u0109\", \"\\u010B\", \"\\u010D\", \"\\u010F\", \"\\u0111\", \"\\u0113\", \"\\u0115\", \"\\u0117\", \"\\u0119\", \"\\u011B\", \"\\u011D\", \"\\u011F\", \"\\u0121\", \"\\u0123\", \"\\u0125\", \"\\u0127\", \"\\u0129\", \"\\u012B\", \"\\u012D\", \"\\u012F\", \"\\u0131\", \"\\u0133\", \"\\u0135\", [\"\\u0137\", \"\\u0138\"], \"\\u013A\", \"\\u013C\", \"\\u013E\", \"\\u0140\", \"\\u0142\", \"\\u0144\", \"\\u0146\", [\"\\u0148\", \"\\u0149\"], \"\\u014B\", \"\\u014D\", \"\\u014F\", \"\\u0151\", \"\\u0153\", \"\\u0155\", \"\\u0157\", \"\\u0159\", \"\\u015B\", \"\\u015D\", \"\\u015F\", \"\\u0161\", \"\\u0163\", \"\\u0165\", \"\\u0167\", \"\\u0169\", \"\\u016B\", \"\\u016D\", \"\\u016F\", \"\\u0171\", \"\\u0173\", \"\\u0175\", \"\\u0177\", \"\\u017A\", \"\\u017C\", [\"\\u017E\", \"\\u0180\"], \"\\u0183\", \"\\u0185\", \"\\u0188\", [\"\\u018C\", \"\\u018D\"], \"\\u0192\", \"\\u0195\", [\"\\u0199\", \"\\u019B\"], \"\\u019E\", \"\\u01A1\", \"\\u01A3\", \"\\u01A5\", \"\\u01A8\", [\"\\u01AA\", \"\\u01AB\"], \"\\u01AD\", \"\\u01B0\", \"\\u01B4\", \"\\u01B6\", [\"\\u01B9\", \"\\u01BA\"], [\"\\u01BD\", \"\\u01BF\"], \"\\u01C6\", \"\\u01C9\", \"\\u01CC\", \"\\u01CE\", \"\\u01D0\", \"\\u01D2\", \"\\u01D4\", \"\\u01D6\", \"\\u01D8\", \"\\u01DA\", [\"\\u01DC\", \"\\u01DD\"], \"\\u01DF\", \"\\u01E1\", \"\\u01E3\", \"\\u01E5\", \"\\u01E7\", \"\\u01E9\", \"\\u01EB\", \"\\u01ED\", [\"\\u01EF\", \"\\u01F0\"], \"\\u01F3\", \"\\u01F5\", \"\\u01F9\", \"\\u01FB\", \"\\u01FD\", \"\\u01FF\", \"\\u0201\", \"\\u0203\", \"\\u0205\", \"\\u0207\", \"\\u0209\", \"\\u020B\", \"\\u020D\", \"\\u020F\", \"\\u0211\", \"\\u0213\", \"\\u0215\", \"\\u0217\", \"\\u0219\", \"\\u021B\", \"\\u021D\", \"\\u021F\", \"\\u0221\", \"\\u0223\", \"\\u0225\", \"\\u0227\", \"\\u0229\", \"\\u022B\", \"\\u022D\", \"\\u022F\", \"\\u0231\", [\"\\u0233\", \"\\u0239\"], \"\\u023C\", [\"\\u023F\", \"\\u0240\"], \"\\u0242\", \"\\u0247\", \"\\u0249\", \"\\u024B\", \"\\u024D\", [\"\\u024F\", \"\\u0293\"], [\"\\u0295\", \"\\u02AF\"], \"\\u0371\", \"\\u0373\", \"\\u0377\", [\"\\u037B\", \"\\u037D\"], \"\\u0390\", [\"\\u03AC\", \"\\u03CE\"], [\"\\u03D0\", \"\\u03D1\"], [\"\\u03D5\", \"\\u03D7\"], \"\\u03D9\", \"\\u03DB\", \"\\u03DD\", \"\\u03DF\", \"\\u03E1\", \"\\u03E3\", \"\\u03E5\", \"\\u03E7\", \"\\u03E9\", \"\\u03EB\", \"\\u03ED\", [\"\\u03EF\", \"\\u03F3\"], \"\\u03F5\", \"\\u03F8\", [\"\\u03FB\", \"\\u03FC\"], [\"\\u0430\", \"\\u045F\"], \"\\u0461\", \"\\u0463\", \"\\u0465\", \"\\u0467\", \"\\u0469\", \"\\u046B\", \"\\u046D\", \"\\u046F\", \"\\u0471\", \"\\u0473\", \"\\u0475\", \"\\u0477\", \"\\u0479\", \"\\u047B\", \"\\u047D\", \"\\u047F\", \"\\u0481\", \"\\u048B\", \"\\u048D\", \"\\u048F\", \"\\u0491\", \"\\u0493\", \"\\u0495\", \"\\u0497\", \"\\u0499\", \"\\u049B\", \"\\u049D\", \"\\u049F\", \"\\u04A1\", \"\\u04A3\", \"\\u04A5\", \"\\u04A7\", \"\\u04A9\", \"\\u04AB\", \"\\u04AD\", \"\\u04AF\", \"\\u04B1\", \"\\u04B3\", \"\\u04B5\", \"\\u04B7\", \"\\u04B9\", \"\\u04BB\", \"\\u04BD\", \"\\u04BF\", \"\\u04C2\", \"\\u04C4\", \"\\u04C6\", \"\\u04C8\", \"\\u04CA\", \"\\u04CC\", [\"\\u04CE\", \"\\u04CF\"], \"\\u04D1\", \"\\u04D3\", \"\\u04D5\", \"\\u04D7\", \"\\u04D9\", \"\\u04DB\", \"\\u04DD\", \"\\u04DF\", \"\\u04E1\", \"\\u04E3\", \"\\u04E5\", \"\\u04E7\", \"\\u04E9\", \"\\u04EB\", \"\\u04ED\", \"\\u04EF\", \"\\u04F1\", \"\\u04F3\", \"\\u04F5\", \"\\u04F7\", \"\\u04F9\", \"\\u04FB\", \"\\u04FD\", \"\\u04FF\", \"\\u0501\", \"\\u0503\", \"\\u0505\", \"\\u0507\", \"\\u0509\", \"\\u050B\", \"\\u050D\", \"\\u050F\", \"\\u0511\", \"\\u0513\", \"\\u0515\", \"\\u0517\", \"\\u0519\", \"\\u051B\", \"\\u051D\", \"\\u051F\", \"\\u0521\", \"\\u0523\", \"\\u0525\", \"\\u0527\", \"\\u0529\", \"\\u052B\", \"\\u052D\", \"\\u052F\", [\"\\u0561\", \"\\u0587\"], [\"\\u13F8\", \"\\u13FD\"], [\"\\u1D00\", \"\\u1D2B\"], [\"\\u1D6B\", \"\\u1D77\"], [\"\\u1D79\", \"\\u1D9A\"], \"\\u1E01\", \"\\u1E03\", \"\\u1E05\", \"\\u1E07\", \"\\u1E09\", \"\\u1E0B\", \"\\u1E0D\", \"\\u1E0F\", \"\\u1E11\", \"\\u1E13\", \"\\u1E15\", \"\\u1E17\", \"\\u1E19\", \"\\u1E1B\", \"\\u1E1D\", \"\\u1E1F\", \"\\u1E21\", \"\\u1E23\", \"\\u1E25\", \"\\u1E27\", \"\\u1E29\", \"\\u1E2B\", \"\\u1E2D\", \"\\u1E2F\", \"\\u1E31\", \"\\u1E33\", \"\\u1E35\", \"\\u1E37\", \"\\u1E39\", \"\\u1E3B\", \"\\u1E3D\", \"\\u1E3F\", \"\\u1E41\", \"\\u1E43\", \"\\u1E45\", \"\\u1E47\", \"\\u1E49\", \"\\u1E4B\", \"\\u1E4D\", \"\\u1E4F\", \"\\u1E51\", \"\\u1E53\", \"\\u1E55\", \"\\u1E57\", \"\\u1E59\", \"\\u1E5B\", \"\\u1E5D\", \"\\u1E5F\", \"\\u1E61\", \"\\u1E63\", \"\\u1E65\", \"\\u1E67\", \"\\u1E69\", \"\\u1E6B\", \"\\u1E6D\", \"\\u1E6F\", \"\\u1E71\", \"\\u1E73\", \"\\u1E75\", \"\\u1E77\", \"\\u1E79\", \"\\u1E7B\", \"\\u1E7D\", \"\\u1E7F\", \"\\u1E81\", \"\\u1E83\", \"\\u1E85\", \"\\u1E87\", \"\\u1E89\", \"\\u1E8B\", \"\\u1E8D\", \"\\u1E8F\", \"\\u1E91\", \"\\u1E93\", [\"\\u1E95\", \"\\u1E9D\"], \"\\u1E9F\", \"\\u1EA1\", \"\\u1EA3\", \"\\u1EA5\", \"\\u1EA7\", \"\\u1EA9\", \"\\u1EAB\", \"\\u1EAD\", \"\\u1EAF\", \"\\u1EB1\", \"\\u1EB3\", \"\\u1EB5\", \"\\u1EB7\", \"\\u1EB9\", \"\\u1EBB\", \"\\u1EBD\", \"\\u1EBF\", \"\\u1EC1\", \"\\u1EC3\", \"\\u1EC5\", \"\\u1EC7\", \"\\u1EC9\", \"\\u1ECB\", \"\\u1ECD\", \"\\u1ECF\", \"\\u1ED1\", \"\\u1ED3\", \"\\u1ED5\", \"\\u1ED7\", \"\\u1ED9\", \"\\u1EDB\", \"\\u1EDD\", \"\\u1EDF\", \"\\u1EE1\", \"\\u1EE3\", \"\\u1EE5\", \"\\u1EE7\", \"\\u1EE9\", \"\\u1EEB\", \"\\u1EED\", \"\\u1EEF\", \"\\u1EF1\", \"\\u1EF3\", \"\\u1EF5\", \"\\u1EF7\", \"\\u1EF9\", \"\\u1EFB\", \"\\u1EFD\", [\"\\u1EFF\", \"\\u1F07\"], [\"\\u1F10\", \"\\u1F15\"], [\"\\u1F20\", \"\\u1F27\"], [\"\\u1F30\", \"\\u1F37\"], [\"\\u1F40\", \"\\u1F45\"], [\"\\u1F50\", \"\\u1F57\"], [\"\\u1F60\", \"\\u1F67\"], [\"\\u1F70\", \"\\u1F7D\"], [\"\\u1F80\", \"\\u1F87\"], [\"\\u1F90\", \"\\u1F97\"], [\"\\u1FA0\", \"\\u1FA7\"], [\"\\u1FB0\", \"\\u1FB4\"], [\"\\u1FB6\", \"\\u1FB7\"], \"\\u1FBE\", [\"\\u1FC2\", \"\\u1FC4\"], [\"\\u1FC6\", \"\\u1FC7\"], [\"\\u1FD0\", \"\\u1FD3\"], [\"\\u1FD6\", \"\\u1FD7\"], [\"\\u1FE0\", \"\\u1FE7\"], [\"\\u1FF2\", \"\\u1FF4\"], [\"\\u1FF6\", \"\\u1FF7\"], \"\\u210A\", [\"\\u210E\", \"\\u210F\"], \"\\u2113\", \"\\u212F\", \"\\u2134\", \"\\u2139\", [\"\\u213C\", \"\\u213D\"], [\"\\u2146\", \"\\u2149\"], \"\\u214E\", \"\\u2184\", [\"\\u2C30\", \"\\u2C5E\"], \"\\u2C61\", [\"\\u2C65\", \"\\u2C66\"], \"\\u2C68\", \"\\u2C6A\", \"\\u2C6C\", \"\\u2C71\", [\"\\u2C73\", \"\\u2C74\"], [\"\\u2C76\", \"\\u2C7B\"], \"\\u2C81\", \"\\u2C83\", \"\\u2C85\", \"\\u2C87\", \"\\u2C89\", \"\\u2C8B\", \"\\u2C8D\", \"\\u2C8F\", \"\\u2C91\", \"\\u2C93\", \"\\u2C95\", \"\\u2C97\", \"\\u2C99\", \"\\u2C9B\", \"\\u2C9D\", \"\\u2C9F\", \"\\u2CA1\", \"\\u2CA3\", \"\\u2CA5\", \"\\u2CA7\", \"\\u2CA9\", \"\\u2CAB\", \"\\u2CAD\", \"\\u2CAF\", \"\\u2CB1\", \"\\u2CB3\", \"\\u2CB5\", \"\\u2CB7\", \"\\u2CB9\", \"\\u2CBB\", \"\\u2CBD\", \"\\u2CBF\", \"\\u2CC1\", \"\\u2CC3\", \"\\u2CC5\", \"\\u2CC7\", \"\\u2CC9\", \"\\u2CCB\", \"\\u2CCD\", \"\\u2CCF\", \"\\u2CD1\", \"\\u2CD3\", \"\\u2CD5\", \"\\u2CD7\", \"\\u2CD9\", \"\\u2CDB\", \"\\u2CDD\", \"\\u2CDF\", \"\\u2CE1\", [\"\\u2CE3\", \"\\u2CE4\"], \"\\u2CEC\", \"\\u2CEE\", \"\\u2CF3\", [\"\\u2D00\", \"\\u2D25\"], \"\\u2D27\", \"\\u2D2D\", \"\\uA641\", \"\\uA643\", \"\\uA645\", \"\\uA647\", \"\\uA649\", \"\\uA64B\", \"\\uA64D\", \"\\uA64F\", \"\\uA651\", \"\\uA653\", \"\\uA655\", \"\\uA657\", \"\\uA659\", \"\\uA65B\", \"\\uA65D\", \"\\uA65F\", \"\\uA661\", \"\\uA663\", \"\\uA665\", \"\\uA667\", \"\\uA669\", \"\\uA66B\", \"\\uA66D\", \"\\uA681\", \"\\uA683\", \"\\uA685\", \"\\uA687\", \"\\uA689\", \"\\uA68B\", \"\\uA68D\", \"\\uA68F\", \"\\uA691\", \"\\uA693\", \"\\uA695\", \"\\uA697\", \"\\uA699\", \"\\uA69B\", \"\\uA723\", \"\\uA725\", \"\\uA727\", \"\\uA729\", \"\\uA72B\", \"\\uA72D\", [\"\\uA72F\", \"\\uA731\"], \"\\uA733\", \"\\uA735\", \"\\uA737\", \"\\uA739\", \"\\uA73B\", \"\\uA73D\", \"\\uA73F\", \"\\uA741\", \"\\uA743\", \"\\uA745\", \"\\uA747\", \"\\uA749\", \"\\uA74B\", \"\\uA74D\", \"\\uA74F\", \"\\uA751\", \"\\uA753\", \"\\uA755\", \"\\uA757\", \"\\uA759\", \"\\uA75B\", \"\\uA75D\", \"\\uA75F\", \"\\uA761\", \"\\uA763\", \"\\uA765\", \"\\uA767\", \"\\uA769\", \"\\uA76B\", \"\\uA76D\", \"\\uA76F\", [\"\\uA771\", \"\\uA778\"], \"\\uA77A\", \"\\uA77C\", \"\\uA77F\", \"\\uA781\", \"\\uA783\", \"\\uA785\", \"\\uA787\", \"\\uA78C\", \"\\uA78E\", \"\\uA791\", [\"\\uA793\", \"\\uA795\"], \"\\uA797\", \"\\uA799\", \"\\uA79B\", \"\\uA79D\", \"\\uA79F\", \"\\uA7A1\", \"\\uA7A3\", \"\\uA7A5\", \"\\uA7A7\", \"\\uA7A9\", \"\\uA7B5\", \"\\uA7B7\", \"\\uA7FA\", [\"\\uAB30\", \"\\uAB5A\"], [\"\\uAB60\", \"\\uAB65\"], [\"\\uAB70\", \"\\uABBF\"], [\"\\uFB00\", \"\\uFB06\"], [\"\\uFB13\", \"\\uFB17\"], [\"\\uFF41\", \"\\uFF5A\"]], false, false),\n      peg$c146 = /^[\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5-\\u06E6\\u07F4-\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C-\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D-\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA69C-\\uA69D\\uA717-\\uA71F\\uA770\\uA788\\uA7F8-\\uA7F9\\uA9CF\\uA9E6\\uAA70\\uAADD\\uAAF3-\\uAAF4\\uAB5C-\\uAB5F\\uFF70\\uFF9E-\\uFF9F]/,\n      peg$c147 = peg$classExpectation([[\"\\u02B0\", \"\\u02C1\"], [\"\\u02C6\", \"\\u02D1\"], [\"\\u02E0\", \"\\u02E4\"], \"\\u02EC\", \"\\u02EE\", \"\\u0374\", \"\\u037A\", \"\\u0559\", \"\\u0640\", [\"\\u06E5\", \"\\u06E6\"], [\"\\u07F4\", \"\\u07F5\"], \"\\u07FA\", \"\\u081A\", \"\\u0824\", \"\\u0828\", \"\\u0971\", \"\\u0E46\", \"\\u0EC6\", \"\\u10FC\", \"\\u17D7\", \"\\u1843\", \"\\u1AA7\", [\"\\u1C78\", \"\\u1C7D\"], [\"\\u1D2C\", \"\\u1D6A\"], \"\\u1D78\", [\"\\u1D9B\", \"\\u1DBF\"], \"\\u2071\", \"\\u207F\", [\"\\u2090\", \"\\u209C\"], [\"\\u2C7C\", \"\\u2C7D\"], \"\\u2D6F\", \"\\u2E2F\", \"\\u3005\", [\"\\u3031\", \"\\u3035\"], \"\\u303B\", [\"\\u309D\", \"\\u309E\"], [\"\\u30FC\", \"\\u30FE\"], \"\\uA015\", [\"\\uA4F8\", \"\\uA4FD\"], \"\\uA60C\", \"\\uA67F\", [\"\\uA69C\", \"\\uA69D\"], [\"\\uA717\", \"\\uA71F\"], \"\\uA770\", \"\\uA788\", [\"\\uA7F8\", \"\\uA7F9\"], \"\\uA9CF\", \"\\uA9E6\", \"\\uAA70\", \"\\uAADD\", [\"\\uAAF3\", \"\\uAAF4\"], [\"\\uAB5C\", \"\\uAB5F\"], \"\\uFF70\", [\"\\uFF9E\", \"\\uFF9F\"]], false, false),\n      peg$c148 = /^[\\xAA\\xBA\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E-\\u066F\\u0671-\\u06D3\\u06D5\\u06EE-\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0980\\u0985-\\u098C\\u098F-\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC-\\u09DD\\u09DF-\\u09E1\\u09F0-\\u09F1\\u0A05-\\u0A0A\\u0A0F-\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32-\\u0A33\\u0A35-\\u0A36\\u0A38-\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2-\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0-\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F-\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32-\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C-\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99-\\u0B9A\\u0B9C\\u0B9E-\\u0B9F\\u0BA3-\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60-\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0-\\u0CE1\\u0CF1-\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32-\\u0E33\\u0E40-\\u0E45\\u0E81-\\u0E82\\u0E84\\u0E87-\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA-\\u0EAB\\u0EAD-\\u0EB0\\u0EB2-\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065-\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u10FD-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE-\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5-\\u1CF6\\u2135-\\u2138\\u2D30-\\u2D67\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A-\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA78F\\uA7F7\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9E0-\\uA9E4\\uA9E7-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5-\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADC\\uAAE0-\\uAAEA\\uAAF2\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40-\\uFB41\\uFB43-\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/,\n      peg$c149 = peg$classExpectation([\"\\xAA\", \"\\xBA\", \"\\u01BB\", [\"\\u01C0\", \"\\u01C3\"], \"\\u0294\", [\"\\u05D0\", \"\\u05EA\"], [\"\\u05F0\", \"\\u05F2\"], [\"\\u0620\", \"\\u063F\"], [\"\\u0641\", \"\\u064A\"], [\"\\u066E\", \"\\u066F\"], [\"\\u0671\", \"\\u06D3\"], \"\\u06D5\", [\"\\u06EE\", \"\\u06EF\"], [\"\\u06FA\", \"\\u06FC\"], \"\\u06FF\", \"\\u0710\", [\"\\u0712\", \"\\u072F\"], [\"\\u074D\", \"\\u07A5\"], \"\\u07B1\", [\"\\u07CA\", \"\\u07EA\"], [\"\\u0800\", \"\\u0815\"], [\"\\u0840\", \"\\u0858\"], [\"\\u08A0\", \"\\u08B4\"], [\"\\u0904\", \"\\u0939\"], \"\\u093D\", \"\\u0950\", [\"\\u0958\", \"\\u0961\"], [\"\\u0972\", \"\\u0980\"], [\"\\u0985\", \"\\u098C\"], [\"\\u098F\", \"\\u0990\"], [\"\\u0993\", \"\\u09A8\"], [\"\\u09AA\", \"\\u09B0\"], \"\\u09B2\", [\"\\u09B6\", \"\\u09B9\"], \"\\u09BD\", \"\\u09CE\", [\"\\u09DC\", \"\\u09DD\"], [\"\\u09DF\", \"\\u09E1\"], [\"\\u09F0\", \"\\u09F1\"], [\"\\u0A05\", \"\\u0A0A\"], [\"\\u0A0F\", \"\\u0A10\"], [\"\\u0A13\", \"\\u0A28\"], [\"\\u0A2A\", \"\\u0A30\"], [\"\\u0A32\", \"\\u0A33\"], [\"\\u0A35\", \"\\u0A36\"], [\"\\u0A38\", \"\\u0A39\"], [\"\\u0A59\", \"\\u0A5C\"], \"\\u0A5E\", [\"\\u0A72\", \"\\u0A74\"], [\"\\u0A85\", \"\\u0A8D\"], [\"\\u0A8F\", \"\\u0A91\"], [\"\\u0A93\", \"\\u0AA8\"], [\"\\u0AAA\", \"\\u0AB0\"], [\"\\u0AB2\", \"\\u0AB3\"], [\"\\u0AB5\", \"\\u0AB9\"], \"\\u0ABD\", \"\\u0AD0\", [\"\\u0AE0\", \"\\u0AE1\"], \"\\u0AF9\", [\"\\u0B05\", \"\\u0B0C\"], [\"\\u0B0F\", \"\\u0B10\"], [\"\\u0B13\", \"\\u0B28\"], [\"\\u0B2A\", \"\\u0B30\"], [\"\\u0B32\", \"\\u0B33\"], [\"\\u0B35\", \"\\u0B39\"], \"\\u0B3D\", [\"\\u0B5C\", \"\\u0B5D\"], [\"\\u0B5F\", \"\\u0B61\"], \"\\u0B71\", \"\\u0B83\", [\"\\u0B85\", \"\\u0B8A\"], [\"\\u0B8E\", \"\\u0B90\"], [\"\\u0B92\", \"\\u0B95\"], [\"\\u0B99\", \"\\u0B9A\"], \"\\u0B9C\", [\"\\u0B9E\", \"\\u0B9F\"], [\"\\u0BA3\", \"\\u0BA4\"], [\"\\u0BA8\", \"\\u0BAA\"], [\"\\u0BAE\", \"\\u0BB9\"], \"\\u0BD0\", [\"\\u0C05\", \"\\u0C0C\"], [\"\\u0C0E\", \"\\u0C10\"], [\"\\u0C12\", \"\\u0C28\"], [\"\\u0C2A\", \"\\u0C39\"], \"\\u0C3D\", [\"\\u0C58\", \"\\u0C5A\"], [\"\\u0C60\", \"\\u0C61\"], [\"\\u0C85\", \"\\u0C8C\"], [\"\\u0C8E\", \"\\u0C90\"], [\"\\u0C92\", \"\\u0CA8\"], [\"\\u0CAA\", \"\\u0CB3\"], [\"\\u0CB5\", \"\\u0CB9\"], \"\\u0CBD\", \"\\u0CDE\", [\"\\u0CE0\", \"\\u0CE1\"], [\"\\u0CF1\", \"\\u0CF2\"], [\"\\u0D05\", \"\\u0D0C\"], [\"\\u0D0E\", \"\\u0D10\"], [\"\\u0D12\", \"\\u0D3A\"], \"\\u0D3D\", \"\\u0D4E\", [\"\\u0D5F\", \"\\u0D61\"], [\"\\u0D7A\", \"\\u0D7F\"], [\"\\u0D85\", \"\\u0D96\"], [\"\\u0D9A\", \"\\u0DB1\"], [\"\\u0DB3\", \"\\u0DBB\"], \"\\u0DBD\", [\"\\u0DC0\", \"\\u0DC6\"], [\"\\u0E01\", \"\\u0E30\"], [\"\\u0E32\", \"\\u0E33\"], [\"\\u0E40\", \"\\u0E45\"], [\"\\u0E81\", \"\\u0E82\"], \"\\u0E84\", [\"\\u0E87\", \"\\u0E88\"], \"\\u0E8A\", \"\\u0E8D\", [\"\\u0E94\", \"\\u0E97\"], [\"\\u0E99\", \"\\u0E9F\"], [\"\\u0EA1\", \"\\u0EA3\"], \"\\u0EA5\", \"\\u0EA7\", [\"\\u0EAA\", \"\\u0EAB\"], [\"\\u0EAD\", \"\\u0EB0\"], [\"\\u0EB2\", \"\\u0EB3\"], \"\\u0EBD\", [\"\\u0EC0\", \"\\u0EC4\"], [\"\\u0EDC\", \"\\u0EDF\"], \"\\u0F00\", [\"\\u0F40\", \"\\u0F47\"], [\"\\u0F49\", \"\\u0F6C\"], [\"\\u0F88\", \"\\u0F8C\"], [\"\\u1000\", \"\\u102A\"], \"\\u103F\", [\"\\u1050\", \"\\u1055\"], [\"\\u105A\", \"\\u105D\"], \"\\u1061\", [\"\\u1065\", \"\\u1066\"], [\"\\u106E\", \"\\u1070\"], [\"\\u1075\", \"\\u1081\"], \"\\u108E\", [\"\\u10D0\", \"\\u10FA\"], [\"\\u10FD\", \"\\u1248\"], [\"\\u124A\", \"\\u124D\"], [\"\\u1250\", \"\\u1256\"], \"\\u1258\", [\"\\u125A\", \"\\u125D\"], [\"\\u1260\", \"\\u1288\"], [\"\\u128A\", \"\\u128D\"], [\"\\u1290\", \"\\u12B0\"], [\"\\u12B2\", \"\\u12B5\"], [\"\\u12B8\", \"\\u12BE\"], \"\\u12C0\", [\"\\u12C2\", \"\\u12C5\"], [\"\\u12C8\", \"\\u12D6\"], [\"\\u12D8\", \"\\u1310\"], [\"\\u1312\", \"\\u1315\"], [\"\\u1318\", \"\\u135A\"], [\"\\u1380\", \"\\u138F\"], [\"\\u1401\", \"\\u166C\"], [\"\\u166F\", \"\\u167F\"], [\"\\u1681\", \"\\u169A\"], [\"\\u16A0\", \"\\u16EA\"], [\"\\u16F1\", \"\\u16F8\"], [\"\\u1700\", \"\\u170C\"], [\"\\u170E\", \"\\u1711\"], [\"\\u1720\", \"\\u1731\"], [\"\\u1740\", \"\\u1751\"], [\"\\u1760\", \"\\u176C\"], [\"\\u176E\", \"\\u1770\"], [\"\\u1780\", \"\\u17B3\"], \"\\u17DC\", [\"\\u1820\", \"\\u1842\"], [\"\\u1844\", \"\\u1877\"], [\"\\u1880\", \"\\u18A8\"], \"\\u18AA\", [\"\\u18B0\", \"\\u18F5\"], [\"\\u1900\", \"\\u191E\"], [\"\\u1950\", \"\\u196D\"], [\"\\u1970\", \"\\u1974\"], [\"\\u1980\", \"\\u19AB\"], [\"\\u19B0\", \"\\u19C9\"], [\"\\u1A00\", \"\\u1A16\"], [\"\\u1A20\", \"\\u1A54\"], [\"\\u1B05\", \"\\u1B33\"], [\"\\u1B45\", \"\\u1B4B\"], [\"\\u1B83\", \"\\u1BA0\"], [\"\\u1BAE\", \"\\u1BAF\"], [\"\\u1BBA\", \"\\u1BE5\"], [\"\\u1C00\", \"\\u1C23\"], [\"\\u1C4D\", \"\\u1C4F\"], [\"\\u1C5A\", \"\\u1C77\"], [\"\\u1CE9\", \"\\u1CEC\"], [\"\\u1CEE\", \"\\u1CF1\"], [\"\\u1CF5\", \"\\u1CF6\"], [\"\\u2135\", \"\\u2138\"], [\"\\u2D30\", \"\\u2D67\"], [\"\\u2D80\", \"\\u2D96\"], [\"\\u2DA0\", \"\\u2DA6\"], [\"\\u2DA8\", \"\\u2DAE\"], [\"\\u2DB0\", \"\\u2DB6\"], [\"\\u2DB8\", \"\\u2DBE\"], [\"\\u2DC0\", \"\\u2DC6\"], [\"\\u2DC8\", \"\\u2DCE\"], [\"\\u2DD0\", \"\\u2DD6\"], [\"\\u2DD8\", \"\\u2DDE\"], \"\\u3006\", \"\\u303C\", [\"\\u3041\", \"\\u3096\"], \"\\u309F\", [\"\\u30A1\", \"\\u30FA\"], \"\\u30FF\", [\"\\u3105\", \"\\u312D\"], [\"\\u3131\", \"\\u318E\"], [\"\\u31A0\", \"\\u31BA\"], [\"\\u31F0\", \"\\u31FF\"], [\"\\u3400\", \"\\u4DB5\"], [\"\\u4E00\", \"\\u9FD5\"], [\"\\uA000\", \"\\uA014\"], [\"\\uA016\", \"\\uA48C\"], [\"\\uA4D0\", \"\\uA4F7\"], [\"\\uA500\", \"\\uA60B\"], [\"\\uA610\", \"\\uA61F\"], [\"\\uA62A\", \"\\uA62B\"], \"\\uA66E\", [\"\\uA6A0\", \"\\uA6E5\"], \"\\uA78F\", \"\\uA7F7\", [\"\\uA7FB\", \"\\uA801\"], [\"\\uA803\", \"\\uA805\"], [\"\\uA807\", \"\\uA80A\"], [\"\\uA80C\", \"\\uA822\"], [\"\\uA840\", \"\\uA873\"], [\"\\uA882\", \"\\uA8B3\"], [\"\\uA8F2\", \"\\uA8F7\"], \"\\uA8FB\", \"\\uA8FD\", [\"\\uA90A\", \"\\uA925\"], [\"\\uA930\", \"\\uA946\"], [\"\\uA960\", \"\\uA97C\"], [\"\\uA984\", \"\\uA9B2\"], [\"\\uA9E0\", \"\\uA9E4\"], [\"\\uA9E7\", \"\\uA9EF\"], [\"\\uA9FA\", \"\\uA9FE\"], [\"\\uAA00\", \"\\uAA28\"], [\"\\uAA40\", \"\\uAA42\"], [\"\\uAA44\", \"\\uAA4B\"], [\"\\uAA60\", \"\\uAA6F\"], [\"\\uAA71\", \"\\uAA76\"], \"\\uAA7A\", [\"\\uAA7E\", \"\\uAAAF\"], \"\\uAAB1\", [\"\\uAAB5\", \"\\uAAB6\"], [\"\\uAAB9\", \"\\uAABD\"], \"\\uAAC0\", \"\\uAAC2\", [\"\\uAADB\", \"\\uAADC\"], [\"\\uAAE0\", \"\\uAAEA\"], \"\\uAAF2\", [\"\\uAB01\", \"\\uAB06\"], [\"\\uAB09\", \"\\uAB0E\"], [\"\\uAB11\", \"\\uAB16\"], [\"\\uAB20\", \"\\uAB26\"], [\"\\uAB28\", \"\\uAB2E\"], [\"\\uABC0\", \"\\uABE2\"], [\"\\uAC00\", \"\\uD7A3\"], [\"\\uD7B0\", \"\\uD7C6\"], [\"\\uD7CB\", \"\\uD7FB\"], [\"\\uF900\", \"\\uFA6D\"], [\"\\uFA70\", \"\\uFAD9\"], \"\\uFB1D\", [\"\\uFB1F\", \"\\uFB28\"], [\"\\uFB2A\", \"\\uFB36\"], [\"\\uFB38\", \"\\uFB3C\"], \"\\uFB3E\", [\"\\uFB40\", \"\\uFB41\"], [\"\\uFB43\", \"\\uFB44\"], [\"\\uFB46\", \"\\uFBB1\"], [\"\\uFBD3\", \"\\uFD3D\"], [\"\\uFD50\", \"\\uFD8F\"], [\"\\uFD92\", \"\\uFDC7\"], [\"\\uFDF0\", \"\\uFDFB\"], [\"\\uFE70\", \"\\uFE74\"], [\"\\uFE76\", \"\\uFEFC\"], [\"\\uFF66\", \"\\uFF6F\"], [\"\\uFF71\", \"\\uFF9D\"], [\"\\uFFA0\", \"\\uFFBE\"], [\"\\uFFC2\", \"\\uFFC7\"], [\"\\uFFCA\", \"\\uFFCF\"], [\"\\uFFD2\", \"\\uFFD7\"], [\"\\uFFDA\", \"\\uFFDC\"]], false, false),\n      peg$c150 = /^[\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC]/,\n      peg$c151 = peg$classExpectation([\"\\u01C5\", \"\\u01C8\", \"\\u01CB\", \"\\u01F2\", [\"\\u1F88\", \"\\u1F8F\"], [\"\\u1F98\", \"\\u1F9F\"], [\"\\u1FA8\", \"\\u1FAF\"], \"\\u1FBC\", \"\\u1FCC\", \"\\u1FFC\"], false, false),\n      peg$c152 = /^[A-Z\\xC0-\\xD6\\xD8-\\xDE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178-\\u0179\\u017B\\u017D\\u0181-\\u0182\\u0184\\u0186-\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193-\\u0194\\u0196-\\u0198\\u019C-\\u019D\\u019F-\\u01A0\\u01A2\\u01A4\\u01A6-\\u01A7\\u01A9\\u01AC\\u01AE-\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7-\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A-\\u023B\\u023D-\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9-\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0-\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0528\\u052A\\u052C\\u052E\\u0531-\\u0556\\u10A0-\\u10C5\\u10C7\\u10CD\\u13A0-\\u13F5\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E-\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\u2CF2\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA698\\uA69A\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D-\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA792\\uA796\\uA798\\uA79A\\uA79C\\uA79E\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uA7AA-\\uA7AD\\uA7B0-\\uA7B4\\uA7B6\\uFF21-\\uFF3A]/,\n      peg$c153 = peg$classExpectation([[\"A\", \"Z\"], [\"\\xC0\", \"\\xD6\"], [\"\\xD8\", \"\\xDE\"], \"\\u0100\", \"\\u0102\", \"\\u0104\", \"\\u0106\", \"\\u0108\", \"\\u010A\", \"\\u010C\", \"\\u010E\", \"\\u0110\", \"\\u0112\", \"\\u0114\", \"\\u0116\", \"\\u0118\", \"\\u011A\", \"\\u011C\", \"\\u011E\", \"\\u0120\", \"\\u0122\", \"\\u0124\", \"\\u0126\", \"\\u0128\", \"\\u012A\", \"\\u012C\", \"\\u012E\", \"\\u0130\", \"\\u0132\", \"\\u0134\", \"\\u0136\", \"\\u0139\", \"\\u013B\", \"\\u013D\", \"\\u013F\", \"\\u0141\", \"\\u0143\", \"\\u0145\", \"\\u0147\", \"\\u014A\", \"\\u014C\", \"\\u014E\", \"\\u0150\", \"\\u0152\", \"\\u0154\", \"\\u0156\", \"\\u0158\", \"\\u015A\", \"\\u015C\", \"\\u015E\", \"\\u0160\", \"\\u0162\", \"\\u0164\", \"\\u0166\", \"\\u0168\", \"\\u016A\", \"\\u016C\", \"\\u016E\", \"\\u0170\", \"\\u0172\", \"\\u0174\", \"\\u0176\", [\"\\u0178\", \"\\u0179\"], \"\\u017B\", \"\\u017D\", [\"\\u0181\", \"\\u0182\"], \"\\u0184\", [\"\\u0186\", \"\\u0187\"], [\"\\u0189\", \"\\u018B\"], [\"\\u018E\", \"\\u0191\"], [\"\\u0193\", \"\\u0194\"], [\"\\u0196\", \"\\u0198\"], [\"\\u019C\", \"\\u019D\"], [\"\\u019F\", \"\\u01A0\"], \"\\u01A2\", \"\\u01A4\", [\"\\u01A6\", \"\\u01A7\"], \"\\u01A9\", \"\\u01AC\", [\"\\u01AE\", \"\\u01AF\"], [\"\\u01B1\", \"\\u01B3\"], \"\\u01B5\", [\"\\u01B7\", \"\\u01B8\"], \"\\u01BC\", \"\\u01C4\", \"\\u01C7\", \"\\u01CA\", \"\\u01CD\", \"\\u01CF\", \"\\u01D1\", \"\\u01D3\", \"\\u01D5\", \"\\u01D7\", \"\\u01D9\", \"\\u01DB\", \"\\u01DE\", \"\\u01E0\", \"\\u01E2\", \"\\u01E4\", \"\\u01E6\", \"\\u01E8\", \"\\u01EA\", \"\\u01EC\", \"\\u01EE\", \"\\u01F1\", \"\\u01F4\", [\"\\u01F6\", \"\\u01F8\"], \"\\u01FA\", \"\\u01FC\", \"\\u01FE\", \"\\u0200\", \"\\u0202\", \"\\u0204\", \"\\u0206\", \"\\u0208\", \"\\u020A\", \"\\u020C\", \"\\u020E\", \"\\u0210\", \"\\u0212\", \"\\u0214\", \"\\u0216\", \"\\u0218\", \"\\u021A\", \"\\u021C\", \"\\u021E\", \"\\u0220\", \"\\u0222\", \"\\u0224\", \"\\u0226\", \"\\u0228\", \"\\u022A\", \"\\u022C\", \"\\u022E\", \"\\u0230\", \"\\u0232\", [\"\\u023A\", \"\\u023B\"], [\"\\u023D\", \"\\u023E\"], \"\\u0241\", [\"\\u0243\", \"\\u0246\"], \"\\u0248\", \"\\u024A\", \"\\u024C\", \"\\u024E\", \"\\u0370\", \"\\u0372\", \"\\u0376\", \"\\u037F\", \"\\u0386\", [\"\\u0388\", \"\\u038A\"], \"\\u038C\", [\"\\u038E\", \"\\u038F\"], [\"\\u0391\", \"\\u03A1\"], [\"\\u03A3\", \"\\u03AB\"], \"\\u03CF\", [\"\\u03D2\", \"\\u03D4\"], \"\\u03D8\", \"\\u03DA\", \"\\u03DC\", \"\\u03DE\", \"\\u03E0\", \"\\u03E2\", \"\\u03E4\", \"\\u03E6\", \"\\u03E8\", \"\\u03EA\", \"\\u03EC\", \"\\u03EE\", \"\\u03F4\", \"\\u03F7\", [\"\\u03F9\", \"\\u03FA\"], [\"\\u03FD\", \"\\u042F\"], \"\\u0460\", \"\\u0462\", \"\\u0464\", \"\\u0466\", \"\\u0468\", \"\\u046A\", \"\\u046C\", \"\\u046E\", \"\\u0470\", \"\\u0472\", \"\\u0474\", \"\\u0476\", \"\\u0478\", \"\\u047A\", \"\\u047C\", \"\\u047E\", \"\\u0480\", \"\\u048A\", \"\\u048C\", \"\\u048E\", \"\\u0490\", \"\\u0492\", \"\\u0494\", \"\\u0496\", \"\\u0498\", \"\\u049A\", \"\\u049C\", \"\\u049E\", \"\\u04A0\", \"\\u04A2\", \"\\u04A4\", \"\\u04A6\", \"\\u04A8\", \"\\u04AA\", \"\\u04AC\", \"\\u04AE\", \"\\u04B0\", \"\\u04B2\", \"\\u04B4\", \"\\u04B6\", \"\\u04B8\", \"\\u04BA\", \"\\u04BC\", \"\\u04BE\", [\"\\u04C0\", \"\\u04C1\"], \"\\u04C3\", \"\\u04C5\", \"\\u04C7\", \"\\u04C9\", \"\\u04CB\", \"\\u04CD\", \"\\u04D0\", \"\\u04D2\", \"\\u04D4\", \"\\u04D6\", \"\\u04D8\", \"\\u04DA\", \"\\u04DC\", \"\\u04DE\", \"\\u04E0\", \"\\u04E2\", \"\\u04E4\", \"\\u04E6\", \"\\u04E8\", \"\\u04EA\", \"\\u04EC\", \"\\u04EE\", \"\\u04F0\", \"\\u04F2\", \"\\u04F4\", \"\\u04F6\", \"\\u04F8\", \"\\u04FA\", \"\\u04FC\", \"\\u04FE\", \"\\u0500\", \"\\u0502\", \"\\u0504\", \"\\u0506\", \"\\u0508\", \"\\u050A\", \"\\u050C\", \"\\u050E\", \"\\u0510\", \"\\u0512\", \"\\u0514\", \"\\u0516\", \"\\u0518\", \"\\u051A\", \"\\u051C\", \"\\u051E\", \"\\u0520\", \"\\u0522\", \"\\u0524\", \"\\u0526\", \"\\u0528\", \"\\u052A\", \"\\u052C\", \"\\u052E\", [\"\\u0531\", \"\\u0556\"], [\"\\u10A0\", \"\\u10C5\"], \"\\u10C7\", \"\\u10CD\", [\"\\u13A0\", \"\\u13F5\"], \"\\u1E00\", \"\\u1E02\", \"\\u1E04\", \"\\u1E06\", \"\\u1E08\", \"\\u1E0A\", \"\\u1E0C\", \"\\u1E0E\", \"\\u1E10\", \"\\u1E12\", \"\\u1E14\", \"\\u1E16\", \"\\u1E18\", \"\\u1E1A\", \"\\u1E1C\", \"\\u1E1E\", \"\\u1E20\", \"\\u1E22\", \"\\u1E24\", \"\\u1E26\", \"\\u1E28\", \"\\u1E2A\", \"\\u1E2C\", \"\\u1E2E\", \"\\u1E30\", \"\\u1E32\", \"\\u1E34\", \"\\u1E36\", \"\\u1E38\", \"\\u1E3A\", \"\\u1E3C\", \"\\u1E3E\", \"\\u1E40\", \"\\u1E42\", \"\\u1E44\", \"\\u1E46\", \"\\u1E48\", \"\\u1E4A\", \"\\u1E4C\", \"\\u1E4E\", \"\\u1E50\", \"\\u1E52\", \"\\u1E54\", \"\\u1E56\", \"\\u1E58\", \"\\u1E5A\", \"\\u1E5C\", \"\\u1E5E\", \"\\u1E60\", \"\\u1E62\", \"\\u1E64\", \"\\u1E66\", \"\\u1E68\", \"\\u1E6A\", \"\\u1E6C\", \"\\u1E6E\", \"\\u1E70\", \"\\u1E72\", \"\\u1E74\", \"\\u1E76\", \"\\u1E78\", \"\\u1E7A\", \"\\u1E7C\", \"\\u1E7E\", \"\\u1E80\", \"\\u1E82\", \"\\u1E84\", \"\\u1E86\", \"\\u1E88\", \"\\u1E8A\", \"\\u1E8C\", \"\\u1E8E\", \"\\u1E90\", \"\\u1E92\", \"\\u1E94\", \"\\u1E9E\", \"\\u1EA0\", \"\\u1EA2\", \"\\u1EA4\", \"\\u1EA6\", \"\\u1EA8\", \"\\u1EAA\", \"\\u1EAC\", \"\\u1EAE\", \"\\u1EB0\", \"\\u1EB2\", \"\\u1EB4\", \"\\u1EB6\", \"\\u1EB8\", \"\\u1EBA\", \"\\u1EBC\", \"\\u1EBE\", \"\\u1EC0\", \"\\u1EC2\", \"\\u1EC4\", \"\\u1EC6\", \"\\u1EC8\", \"\\u1ECA\", \"\\u1ECC\", \"\\u1ECE\", \"\\u1ED0\", \"\\u1ED2\", \"\\u1ED4\", \"\\u1ED6\", \"\\u1ED8\", \"\\u1EDA\", \"\\u1EDC\", \"\\u1EDE\", \"\\u1EE0\", \"\\u1EE2\", \"\\u1EE4\", \"\\u1EE6\", \"\\u1EE8\", \"\\u1EEA\", \"\\u1EEC\", \"\\u1EEE\", \"\\u1EF0\", \"\\u1EF2\", \"\\u1EF4\", \"\\u1EF6\", \"\\u1EF8\", \"\\u1EFA\", \"\\u1EFC\", \"\\u1EFE\", [\"\\u1F08\", \"\\u1F0F\"], [\"\\u1F18\", \"\\u1F1D\"], [\"\\u1F28\", \"\\u1F2F\"], [\"\\u1F38\", \"\\u1F3F\"], [\"\\u1F48\", \"\\u1F4D\"], \"\\u1F59\", \"\\u1F5B\", \"\\u1F5D\", \"\\u1F5F\", [\"\\u1F68\", \"\\u1F6F\"], [\"\\u1FB8\", \"\\u1FBB\"], [\"\\u1FC8\", \"\\u1FCB\"], [\"\\u1FD8\", \"\\u1FDB\"], [\"\\u1FE8\", \"\\u1FEC\"], [\"\\u1FF8\", \"\\u1FFB\"], \"\\u2102\", \"\\u2107\", [\"\\u210B\", \"\\u210D\"], [\"\\u2110\", \"\\u2112\"], \"\\u2115\", [\"\\u2119\", \"\\u211D\"], \"\\u2124\", \"\\u2126\", \"\\u2128\", [\"\\u212A\", \"\\u212D\"], [\"\\u2130\", \"\\u2133\"], [\"\\u213E\", \"\\u213F\"], \"\\u2145\", \"\\u2183\", [\"\\u2C00\", \"\\u2C2E\"], \"\\u2C60\", [\"\\u2C62\", \"\\u2C64\"], \"\\u2C67\", \"\\u2C69\", \"\\u2C6B\", [\"\\u2C6D\", \"\\u2C70\"], \"\\u2C72\", \"\\u2C75\", [\"\\u2C7E\", \"\\u2C80\"], \"\\u2C82\", \"\\u2C84\", \"\\u2C86\", \"\\u2C88\", \"\\u2C8A\", \"\\u2C8C\", \"\\u2C8E\", \"\\u2C90\", \"\\u2C92\", \"\\u2C94\", \"\\u2C96\", \"\\u2C98\", \"\\u2C9A\", \"\\u2C9C\", \"\\u2C9E\", \"\\u2CA0\", \"\\u2CA2\", \"\\u2CA4\", \"\\u2CA6\", \"\\u2CA8\", \"\\u2CAA\", \"\\u2CAC\", \"\\u2CAE\", \"\\u2CB0\", \"\\u2CB2\", \"\\u2CB4\", \"\\u2CB6\", \"\\u2CB8\", \"\\u2CBA\", \"\\u2CBC\", \"\\u2CBE\", \"\\u2CC0\", \"\\u2CC2\", \"\\u2CC4\", \"\\u2CC6\", \"\\u2CC8\", \"\\u2CCA\", \"\\u2CCC\", \"\\u2CCE\", \"\\u2CD0\", \"\\u2CD2\", \"\\u2CD4\", \"\\u2CD6\", \"\\u2CD8\", \"\\u2CDA\", \"\\u2CDC\", \"\\u2CDE\", \"\\u2CE0\", \"\\u2CE2\", \"\\u2CEB\", \"\\u2CED\", \"\\u2CF2\", \"\\uA640\", \"\\uA642\", \"\\uA644\", \"\\uA646\", \"\\uA648\", \"\\uA64A\", \"\\uA64C\", \"\\uA64E\", \"\\uA650\", \"\\uA652\", \"\\uA654\", \"\\uA656\", \"\\uA658\", \"\\uA65A\", \"\\uA65C\", \"\\uA65E\", \"\\uA660\", \"\\uA662\", \"\\uA664\", \"\\uA666\", \"\\uA668\", \"\\uA66A\", \"\\uA66C\", \"\\uA680\", \"\\uA682\", \"\\uA684\", \"\\uA686\", \"\\uA688\", \"\\uA68A\", \"\\uA68C\", \"\\uA68E\", \"\\uA690\", \"\\uA692\", \"\\uA694\", \"\\uA696\", \"\\uA698\", \"\\uA69A\", \"\\uA722\", \"\\uA724\", \"\\uA726\", \"\\uA728\", \"\\uA72A\", \"\\uA72C\", \"\\uA72E\", \"\\uA732\", \"\\uA734\", \"\\uA736\", \"\\uA738\", \"\\uA73A\", \"\\uA73C\", \"\\uA73E\", \"\\uA740\", \"\\uA742\", \"\\uA744\", \"\\uA746\", \"\\uA748\", \"\\uA74A\", \"\\uA74C\", \"\\uA74E\", \"\\uA750\", \"\\uA752\", \"\\uA754\", \"\\uA756\", \"\\uA758\", \"\\uA75A\", \"\\uA75C\", \"\\uA75E\", \"\\uA760\", \"\\uA762\", \"\\uA764\", \"\\uA766\", \"\\uA768\", \"\\uA76A\", \"\\uA76C\", \"\\uA76E\", \"\\uA779\", \"\\uA77B\", [\"\\uA77D\", \"\\uA77E\"], \"\\uA780\", \"\\uA782\", \"\\uA784\", \"\\uA786\", \"\\uA78B\", \"\\uA78D\", \"\\uA790\", \"\\uA792\", \"\\uA796\", \"\\uA798\", \"\\uA79A\", \"\\uA79C\", \"\\uA79E\", \"\\uA7A0\", \"\\uA7A2\", \"\\uA7A4\", \"\\uA7A6\", \"\\uA7A8\", [\"\\uA7AA\", \"\\uA7AD\"], [\"\\uA7B0\", \"\\uA7B4\"], \"\\uA7B6\", [\"\\uFF21\", \"\\uFF3A\"]], false, false),\n      peg$c154 = /^[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E-\\u094F\\u0982-\\u0983\\u09BE-\\u09C0\\u09C7-\\u09C8\\u09CB-\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB-\\u0ACC\\u0B02-\\u0B03\\u0B3E\\u0B40\\u0B47-\\u0B48\\u0B4B-\\u0B4C\\u0B57\\u0BBE-\\u0BBF\\u0BC1-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82-\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7-\\u0CC8\\u0CCA-\\u0CCB\\u0CD5-\\u0CD6\\u0D02-\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82-\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2-\\u0DF3\\u0F3E-\\u0F3F\\u0F7F\\u102B-\\u102C\\u1031\\u1038\\u103B-\\u103C\\u1056-\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083-\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7-\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930-\\u1931\\u1933-\\u1938\\u1A19-\\u1A1A\\u1A55\\u1A57\\u1A61\\u1A63-\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43-\\u1B44\\u1B82\\u1BA1\\u1BA6-\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2-\\u1BF3\\u1C24-\\u1C2B\\u1C34-\\u1C35\\u1CE1\\u1CF2-\\u1CF3\\u302E-\\u302F\\uA823-\\uA824\\uA827\\uA880-\\uA881\\uA8B4-\\uA8C3\\uA952-\\uA953\\uA983\\uA9B4-\\uA9B5\\uA9BA-\\uA9BB\\uA9BD-\\uA9C0\\uAA2F-\\uAA30\\uAA33-\\uAA34\\uAA4D\\uAA7B\\uAA7D\\uAAEB\\uAAEE-\\uAAEF\\uAAF5\\uABE3-\\uABE4\\uABE6-\\uABE7\\uABE9-\\uABEA\\uABEC]/,\n      peg$c155 = peg$classExpectation([\"\\u0903\", \"\\u093B\", [\"\\u093E\", \"\\u0940\"], [\"\\u0949\", \"\\u094C\"], [\"\\u094E\", \"\\u094F\"], [\"\\u0982\", \"\\u0983\"], [\"\\u09BE\", \"\\u09C0\"], [\"\\u09C7\", \"\\u09C8\"], [\"\\u09CB\", \"\\u09CC\"], \"\\u09D7\", \"\\u0A03\", [\"\\u0A3E\", \"\\u0A40\"], \"\\u0A83\", [\"\\u0ABE\", \"\\u0AC0\"], \"\\u0AC9\", [\"\\u0ACB\", \"\\u0ACC\"], [\"\\u0B02\", \"\\u0B03\"], \"\\u0B3E\", \"\\u0B40\", [\"\\u0B47\", \"\\u0B48\"], [\"\\u0B4B\", \"\\u0B4C\"], \"\\u0B57\", [\"\\u0BBE\", \"\\u0BBF\"], [\"\\u0BC1\", \"\\u0BC2\"], [\"\\u0BC6\", \"\\u0BC8\"], [\"\\u0BCA\", \"\\u0BCC\"], \"\\u0BD7\", [\"\\u0C01\", \"\\u0C03\"], [\"\\u0C41\", \"\\u0C44\"], [\"\\u0C82\", \"\\u0C83\"], \"\\u0CBE\", [\"\\u0CC0\", \"\\u0CC4\"], [\"\\u0CC7\", \"\\u0CC8\"], [\"\\u0CCA\", \"\\u0CCB\"], [\"\\u0CD5\", \"\\u0CD6\"], [\"\\u0D02\", \"\\u0D03\"], [\"\\u0D3E\", \"\\u0D40\"], [\"\\u0D46\", \"\\u0D48\"], [\"\\u0D4A\", \"\\u0D4C\"], \"\\u0D57\", [\"\\u0D82\", \"\\u0D83\"], [\"\\u0DCF\", \"\\u0DD1\"], [\"\\u0DD8\", \"\\u0DDF\"], [\"\\u0DF2\", \"\\u0DF3\"], [\"\\u0F3E\", \"\\u0F3F\"], \"\\u0F7F\", [\"\\u102B\", \"\\u102C\"], \"\\u1031\", \"\\u1038\", [\"\\u103B\", \"\\u103C\"], [\"\\u1056\", \"\\u1057\"], [\"\\u1062\", \"\\u1064\"], [\"\\u1067\", \"\\u106D\"], [\"\\u1083\", \"\\u1084\"], [\"\\u1087\", \"\\u108C\"], \"\\u108F\", [\"\\u109A\", \"\\u109C\"], \"\\u17B6\", [\"\\u17BE\", \"\\u17C5\"], [\"\\u17C7\", \"\\u17C8\"], [\"\\u1923\", \"\\u1926\"], [\"\\u1929\", \"\\u192B\"], [\"\\u1930\", \"\\u1931\"], [\"\\u1933\", \"\\u1938\"], [\"\\u1A19\", \"\\u1A1A\"], \"\\u1A55\", \"\\u1A57\", \"\\u1A61\", [\"\\u1A63\", \"\\u1A64\"], [\"\\u1A6D\", \"\\u1A72\"], \"\\u1B04\", \"\\u1B35\", \"\\u1B3B\", [\"\\u1B3D\", \"\\u1B41\"], [\"\\u1B43\", \"\\u1B44\"], \"\\u1B82\", \"\\u1BA1\", [\"\\u1BA6\", \"\\u1BA7\"], \"\\u1BAA\", \"\\u1BE7\", [\"\\u1BEA\", \"\\u1BEC\"], \"\\u1BEE\", [\"\\u1BF2\", \"\\u1BF3\"], [\"\\u1C24\", \"\\u1C2B\"], [\"\\u1C34\", \"\\u1C35\"], \"\\u1CE1\", [\"\\u1CF2\", \"\\u1CF3\"], [\"\\u302E\", \"\\u302F\"], [\"\\uA823\", \"\\uA824\"], \"\\uA827\", [\"\\uA880\", \"\\uA881\"], [\"\\uA8B4\", \"\\uA8C3\"], [\"\\uA952\", \"\\uA953\"], \"\\uA983\", [\"\\uA9B4\", \"\\uA9B5\"], [\"\\uA9BA\", \"\\uA9BB\"], [\"\\uA9BD\", \"\\uA9C0\"], [\"\\uAA2F\", \"\\uAA30\"], [\"\\uAA33\", \"\\uAA34\"], \"\\uAA4D\", \"\\uAA7B\", \"\\uAA7D\", \"\\uAAEB\", [\"\\uAAEE\", \"\\uAAEF\"], \"\\uAAF5\", [\"\\uABE3\", \"\\uABE4\"], [\"\\uABE6\", \"\\uABE7\"], [\"\\uABE9\", \"\\uABEA\"], \"\\uABEC\"], false, false),\n      peg$c156 = /^[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1-\\u05C2\\u05C4-\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7-\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2-\\u09E3\\u0A01-\\u0A02\\u0A3C\\u0A41-\\u0A42\\u0A47-\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70-\\u0A71\\u0A75\\u0A81-\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7-\\u0AC8\\u0ACD\\u0AE2-\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62-\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C00\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55-\\u0C56\\u0C62-\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC6\\u0CCC-\\u0CCD\\u0CE2-\\u0CE3\\u0D01\\u0D41-\\u0D44\\u0D4D\\u0D62-\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB-\\u0EBC\\u0EC8-\\u0ECD\\u0F18-\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86-\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039-\\u103A\\u103D-\\u103E\\u1058-\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085-\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17B4-\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193B\\u1A17-\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ABD\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80-\\u1B81\\u1BA2-\\u1BA5\\u1BA8-\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8-\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8-\\u1CF9\\u1DC0-\\u1DF5\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302D\\u3099-\\u309A\\uA66F\\uA674-\\uA67D\\uA69E-\\uA69F\\uA6F0-\\uA6F1\\uA802\\uA806\\uA80B\\uA825-\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9E5\\uAA29-\\uAA2E\\uAA31-\\uAA32\\uAA35-\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7-\\uAAB8\\uAABE-\\uAABF\\uAAC1\\uAAEC-\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F]/,\n      peg$c157 = peg$classExpectation([[\"\\u0300\", \"\\u036F\"], [\"\\u0483\", \"\\u0487\"], [\"\\u0591\", \"\\u05BD\"], \"\\u05BF\", [\"\\u05C1\", \"\\u05C2\"], [\"\\u05C4\", \"\\u05C5\"], \"\\u05C7\", [\"\\u0610\", \"\\u061A\"], [\"\\u064B\", \"\\u065F\"], \"\\u0670\", [\"\\u06D6\", \"\\u06DC\"], [\"\\u06DF\", \"\\u06E4\"], [\"\\u06E7\", \"\\u06E8\"], [\"\\u06EA\", \"\\u06ED\"], \"\\u0711\", [\"\\u0730\", \"\\u074A\"], [\"\\u07A6\", \"\\u07B0\"], [\"\\u07EB\", \"\\u07F3\"], [\"\\u0816\", \"\\u0819\"], [\"\\u081B\", \"\\u0823\"], [\"\\u0825\", \"\\u0827\"], [\"\\u0829\", \"\\u082D\"], [\"\\u0859\", \"\\u085B\"], [\"\\u08E3\", \"\\u0902\"], \"\\u093A\", \"\\u093C\", [\"\\u0941\", \"\\u0948\"], \"\\u094D\", [\"\\u0951\", \"\\u0957\"], [\"\\u0962\", \"\\u0963\"], \"\\u0981\", \"\\u09BC\", [\"\\u09C1\", \"\\u09C4\"], \"\\u09CD\", [\"\\u09E2\", \"\\u09E3\"], [\"\\u0A01\", \"\\u0A02\"], \"\\u0A3C\", [\"\\u0A41\", \"\\u0A42\"], [\"\\u0A47\", \"\\u0A48\"], [\"\\u0A4B\", \"\\u0A4D\"], \"\\u0A51\", [\"\\u0A70\", \"\\u0A71\"], \"\\u0A75\", [\"\\u0A81\", \"\\u0A82\"], \"\\u0ABC\", [\"\\u0AC1\", \"\\u0AC5\"], [\"\\u0AC7\", \"\\u0AC8\"], \"\\u0ACD\", [\"\\u0AE2\", \"\\u0AE3\"], \"\\u0B01\", \"\\u0B3C\", \"\\u0B3F\", [\"\\u0B41\", \"\\u0B44\"], \"\\u0B4D\", \"\\u0B56\", [\"\\u0B62\", \"\\u0B63\"], \"\\u0B82\", \"\\u0BC0\", \"\\u0BCD\", \"\\u0C00\", [\"\\u0C3E\", \"\\u0C40\"], [\"\\u0C46\", \"\\u0C48\"], [\"\\u0C4A\", \"\\u0C4D\"], [\"\\u0C55\", \"\\u0C56\"], [\"\\u0C62\", \"\\u0C63\"], \"\\u0C81\", \"\\u0CBC\", \"\\u0CBF\", \"\\u0CC6\", [\"\\u0CCC\", \"\\u0CCD\"], [\"\\u0CE2\", \"\\u0CE3\"], \"\\u0D01\", [\"\\u0D41\", \"\\u0D44\"], \"\\u0D4D\", [\"\\u0D62\", \"\\u0D63\"], \"\\u0DCA\", [\"\\u0DD2\", \"\\u0DD4\"], \"\\u0DD6\", \"\\u0E31\", [\"\\u0E34\", \"\\u0E3A\"], [\"\\u0E47\", \"\\u0E4E\"], \"\\u0EB1\", [\"\\u0EB4\", \"\\u0EB9\"], [\"\\u0EBB\", \"\\u0EBC\"], [\"\\u0EC8\", \"\\u0ECD\"], [\"\\u0F18\", \"\\u0F19\"], \"\\u0F35\", \"\\u0F37\", \"\\u0F39\", [\"\\u0F71\", \"\\u0F7E\"], [\"\\u0F80\", \"\\u0F84\"], [\"\\u0F86\", \"\\u0F87\"], [\"\\u0F8D\", \"\\u0F97\"], [\"\\u0F99\", \"\\u0FBC\"], \"\\u0FC6\", [\"\\u102D\", \"\\u1030\"], [\"\\u1032\", \"\\u1037\"], [\"\\u1039\", \"\\u103A\"], [\"\\u103D\", \"\\u103E\"], [\"\\u1058\", \"\\u1059\"], [\"\\u105E\", \"\\u1060\"], [\"\\u1071\", \"\\u1074\"], \"\\u1082\", [\"\\u1085\", \"\\u1086\"], \"\\u108D\", \"\\u109D\", [\"\\u135D\", \"\\u135F\"], [\"\\u1712\", \"\\u1714\"], [\"\\u1732\", \"\\u1734\"], [\"\\u1752\", \"\\u1753\"], [\"\\u1772\", \"\\u1773\"], [\"\\u17B4\", \"\\u17B5\"], [\"\\u17B7\", \"\\u17BD\"], \"\\u17C6\", [\"\\u17C9\", \"\\u17D3\"], \"\\u17DD\", [\"\\u180B\", \"\\u180D\"], \"\\u18A9\", [\"\\u1920\", \"\\u1922\"], [\"\\u1927\", \"\\u1928\"], \"\\u1932\", [\"\\u1939\", \"\\u193B\"], [\"\\u1A17\", \"\\u1A18\"], \"\\u1A1B\", \"\\u1A56\", [\"\\u1A58\", \"\\u1A5E\"], \"\\u1A60\", \"\\u1A62\", [\"\\u1A65\", \"\\u1A6C\"], [\"\\u1A73\", \"\\u1A7C\"], \"\\u1A7F\", [\"\\u1AB0\", \"\\u1ABD\"], [\"\\u1B00\", \"\\u1B03\"], \"\\u1B34\", [\"\\u1B36\", \"\\u1B3A\"], \"\\u1B3C\", \"\\u1B42\", [\"\\u1B6B\", \"\\u1B73\"], [\"\\u1B80\", \"\\u1B81\"], [\"\\u1BA2\", \"\\u1BA5\"], [\"\\u1BA8\", \"\\u1BA9\"], [\"\\u1BAB\", \"\\u1BAD\"], \"\\u1BE6\", [\"\\u1BE8\", \"\\u1BE9\"], \"\\u1BED\", [\"\\u1BEF\", \"\\u1BF1\"], [\"\\u1C2C\", \"\\u1C33\"], [\"\\u1C36\", \"\\u1C37\"], [\"\\u1CD0\", \"\\u1CD2\"], [\"\\u1CD4\", \"\\u1CE0\"], [\"\\u1CE2\", \"\\u1CE8\"], \"\\u1CED\", \"\\u1CF4\", [\"\\u1CF8\", \"\\u1CF9\"], [\"\\u1DC0\", \"\\u1DF5\"], [\"\\u1DFC\", \"\\u1DFF\"], [\"\\u20D0\", \"\\u20DC\"], \"\\u20E1\", [\"\\u20E5\", \"\\u20F0\"], [\"\\u2CEF\", \"\\u2CF1\"], \"\\u2D7F\", [\"\\u2DE0\", \"\\u2DFF\"], [\"\\u302A\", \"\\u302D\"], [\"\\u3099\", \"\\u309A\"], \"\\uA66F\", [\"\\uA674\", \"\\uA67D\"], [\"\\uA69E\", \"\\uA69F\"], [\"\\uA6F0\", \"\\uA6F1\"], \"\\uA802\", \"\\uA806\", \"\\uA80B\", [\"\\uA825\", \"\\uA826\"], \"\\uA8C4\", [\"\\uA8E0\", \"\\uA8F1\"], [\"\\uA926\", \"\\uA92D\"], [\"\\uA947\", \"\\uA951\"], [\"\\uA980\", \"\\uA982\"], \"\\uA9B3\", [\"\\uA9B6\", \"\\uA9B9\"], \"\\uA9BC\", \"\\uA9E5\", [\"\\uAA29\", \"\\uAA2E\"], [\"\\uAA31\", \"\\uAA32\"], [\"\\uAA35\", \"\\uAA36\"], \"\\uAA43\", \"\\uAA4C\", \"\\uAA7C\", \"\\uAAB0\", [\"\\uAAB2\", \"\\uAAB4\"], [\"\\uAAB7\", \"\\uAAB8\"], [\"\\uAABE\", \"\\uAABF\"], \"\\uAAC1\", [\"\\uAAEC\", \"\\uAAED\"], \"\\uAAF6\", \"\\uABE5\", \"\\uABE8\", \"\\uABED\", \"\\uFB1E\", [\"\\uFE00\", \"\\uFE0F\"], [\"\\uFE20\", \"\\uFE2F\"]], false, false),\n      peg$c158 = /^[0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]/,\n      peg$c159 = peg$classExpectation([[\"0\", \"9\"], [\"\\u0660\", \"\\u0669\"], [\"\\u06F0\", \"\\u06F9\"], [\"\\u07C0\", \"\\u07C9\"], [\"\\u0966\", \"\\u096F\"], [\"\\u09E6\", \"\\u09EF\"], [\"\\u0A66\", \"\\u0A6F\"], [\"\\u0AE6\", \"\\u0AEF\"], [\"\\u0B66\", \"\\u0B6F\"], [\"\\u0BE6\", \"\\u0BEF\"], [\"\\u0C66\", \"\\u0C6F\"], [\"\\u0CE6\", \"\\u0CEF\"], [\"\\u0D66\", \"\\u0D6F\"], [\"\\u0DE6\", \"\\u0DEF\"], [\"\\u0E50\", \"\\u0E59\"], [\"\\u0ED0\", \"\\u0ED9\"], [\"\\u0F20\", \"\\u0F29\"], [\"\\u1040\", \"\\u1049\"], [\"\\u1090\", \"\\u1099\"], [\"\\u17E0\", \"\\u17E9\"], [\"\\u1810\", \"\\u1819\"], [\"\\u1946\", \"\\u194F\"], [\"\\u19D0\", \"\\u19D9\"], [\"\\u1A80\", \"\\u1A89\"], [\"\\u1A90\", \"\\u1A99\"], [\"\\u1B50\", \"\\u1B59\"], [\"\\u1BB0\", \"\\u1BB9\"], [\"\\u1C40\", \"\\u1C49\"], [\"\\u1C50\", \"\\u1C59\"], [\"\\uA620\", \"\\uA629\"], [\"\\uA8D0\", \"\\uA8D9\"], [\"\\uA900\", \"\\uA909\"], [\"\\uA9D0\", \"\\uA9D9\"], [\"\\uA9F0\", \"\\uA9F9\"], [\"\\uAA50\", \"\\uAA59\"], [\"\\uABF0\", \"\\uABF9\"], [\"\\uFF10\", \"\\uFF19\"]], false, false),\n      peg$c160 = /^[\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF]/,\n      peg$c161 = peg$classExpectation([[\"\\u16EE\", \"\\u16F0\"], [\"\\u2160\", \"\\u2182\"], [\"\\u2185\", \"\\u2188\"], \"\\u3007\", [\"\\u3021\", \"\\u3029\"], [\"\\u3038\", \"\\u303A\"], [\"\\uA6E6\", \"\\uA6EF\"]], false, false),\n      peg$c162 = /^[_\\u203F-\\u2040\\u2054\\uFE33-\\uFE34\\uFE4D-\\uFE4F\\uFF3F]/,\n      peg$c163 = peg$classExpectation([\"_\", [\"\\u203F\", \"\\u2040\"], \"\\u2054\", [\"\\uFE33\", \"\\uFE34\"], [\"\\uFE4D\", \"\\uFE4F\"], \"\\uFF3F\"], false, false),\n      peg$c164 = /^[ \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/,\n      peg$c165 = peg$classExpectation([\" \", \"\\xA0\", \"\\u1680\", [\"\\u2000\", \"\\u200A\"], \"\\u202F\", \"\\u205F\", \"\\u3000\"], false, false),\n      peg$c166 = \"break\",\n      peg$c167 = peg$literalExpectation(\"break\", false),\n      peg$c168 = \"case\",\n      peg$c169 = peg$literalExpectation(\"case\", false),\n      peg$c170 = \"catch\",\n      peg$c171 = peg$literalExpectation(\"catch\", false),\n      peg$c172 = \"class\",\n      peg$c173 = peg$literalExpectation(\"class\", false),\n      peg$c174 = \"const\",\n      peg$c175 = peg$literalExpectation(\"const\", false),\n      peg$c176 = \"continue\",\n      peg$c177 = peg$literalExpectation(\"continue\", false),\n      peg$c178 = \"debugger\",\n      peg$c179 = peg$literalExpectation(\"debugger\", false),\n      peg$c180 = \"default\",\n      peg$c181 = peg$literalExpectation(\"default\", false),\n      peg$c182 = \"delete\",\n      peg$c183 = peg$literalExpectation(\"delete\", false),\n      peg$c184 = \"do\",\n      peg$c185 = peg$literalExpectation(\"do\", false),\n      peg$c186 = \"else\",\n      peg$c187 = peg$literalExpectation(\"else\", false),\n      peg$c188 = \"enum\",\n      peg$c189 = peg$literalExpectation(\"enum\", false),\n      peg$c190 = \"export\",\n      peg$c191 = peg$literalExpectation(\"export\", false),\n      peg$c192 = \"extends\",\n      peg$c193 = peg$literalExpectation(\"extends\", false),\n      peg$c194 = \"false\",\n      peg$c195 = peg$literalExpectation(\"false\", false),\n      peg$c196 = \"finally\",\n      peg$c197 = peg$literalExpectation(\"finally\", false),\n      peg$c198 = \"for\",\n      peg$c199 = peg$literalExpectation(\"for\", false),\n      peg$c200 = \"function\",\n      peg$c201 = peg$literalExpectation(\"function\", false),\n      peg$c202 = \"if\",\n      peg$c203 = peg$literalExpectation(\"if\", false),\n      peg$c204 = \"import\",\n      peg$c205 = peg$literalExpectation(\"import\", false),\n      peg$c206 = \"instanceof\",\n      peg$c207 = peg$literalExpectation(\"instanceof\", false),\n      peg$c208 = \"in\",\n      peg$c209 = peg$literalExpectation(\"in\", false),\n      peg$c210 = \"new\",\n      peg$c211 = peg$literalExpectation(\"new\", false),\n      peg$c212 = \"null\",\n      peg$c213 = peg$literalExpectation(\"null\", false),\n      peg$c214 = \"return\",\n      peg$c215 = peg$literalExpectation(\"return\", false),\n      peg$c216 = \"super\",\n      peg$c217 = peg$literalExpectation(\"super\", false),\n      peg$c218 = \"switch\",\n      peg$c219 = peg$literalExpectation(\"switch\", false),\n      peg$c220 = \"this\",\n      peg$c221 = peg$literalExpectation(\"this\", false),\n      peg$c222 = \"throw\",\n      peg$c223 = peg$literalExpectation(\"throw\", false),\n      peg$c224 = \"true\",\n      peg$c225 = peg$literalExpectation(\"true\", false),\n      peg$c226 = \"try\",\n      peg$c227 = peg$literalExpectation(\"try\", false),\n      peg$c228 = \"typeof\",\n      peg$c229 = peg$literalExpectation(\"typeof\", false),\n      peg$c230 = \"var\",\n      peg$c231 = peg$literalExpectation(\"var\", false),\n      peg$c232 = \"void\",\n      peg$c233 = peg$literalExpectation(\"void\", false),\n      peg$c234 = \"while\",\n      peg$c235 = peg$literalExpectation(\"while\", false),\n      peg$c236 = \"with\",\n      peg$c237 = peg$literalExpectation(\"with\", false),\n      peg$c238 = \";\",\n      peg$c239 = peg$literalExpectation(\";\", false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parseGrammar() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    s1 = peg$parse__();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parseInitializer();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse__();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$currPos;\n        s5 = peg$parseRule();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$currPos;\n            s5 = peg$parseRule();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parse__();\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          }\n        } else {\n          s3 = peg$FAILED;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseInitializer() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseCodeBlock();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseEOS();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseRule() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierName();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$currPos;\n        s4 = peg$parseStringLiteral();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parse__();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s4 = peg$c2;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c3); }\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parse__();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parseChoiceExpression();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseEOS();\n                if (s7 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c4(s1, s3, s6);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseChoiceExpression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parseActionExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s5 = peg$c5;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c6); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseActionExpression();\n            if (s7 !== peg$FAILED) {\n              s4 = [s4, s5, s6, s7];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s5 = peg$c5;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c6); }\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parse__();\n            if (s6 !== peg$FAILED) {\n              s7 = peg$parseActionExpression();\n              if (s7 !== peg$FAILED) {\n                s4 = [s4, s5, s6, s7];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c7(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseActionExpression() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseSequenceExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parse__();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseCodeBlock();\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c8(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSequenceExpression() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseLabeledExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseLabeledExpression();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseLabeledExpression();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c9(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLabeledExpression() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifier();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c10;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c11); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parse__();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsePrefixedExpression();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c12(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsePrefixedExpression();\n    }\n\n    return s0;\n  }\n\n  function peg$parsePrefixedExpression() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsePrefixedOperator();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseSuffixedExpression();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c13(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseSuffixedExpression();\n    }\n\n    return s0;\n  }\n\n  function peg$parsePrefixedOperator() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 36) {\n      s0 = peg$c14;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c15); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 38) {\n        s0 = peg$c16;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c17); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 33) {\n          s0 = peg$c18;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSuffixedExpression() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsePrimaryExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseSuffixedOperator();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c20(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsePrimaryExpression();\n    }\n\n    return s0;\n  }\n\n  function peg$parseSuffixedOperator() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 63) {\n      s0 = peg$c21;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c22); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 42) {\n        s0 = peg$c23;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c24); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 43) {\n          s0 = peg$c25;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c26); }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsePrimaryExpression() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$parseLiteralMatcher();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseCharacterClassMatcher();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseAnyMatcher();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseRuleReferenceExpression();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseSemanticPredicateExpression();\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 40) {\n                s1 = peg$c27;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c28); }\n              }\n              if (s1 !== peg$FAILED) {\n                s2 = peg$parse__();\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parseChoiceExpression();\n                  if (s3 !== peg$FAILED) {\n                    s4 = peg$parse__();\n                    if (s4 !== peg$FAILED) {\n                      if (input.charCodeAt(peg$currPos) === 41) {\n                        s5 = peg$c29;\n                        peg$currPos++;\n                      } else {\n                        s5 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c30); }\n                      }\n                      if (s5 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c31(s3);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseRuleReferenceExpression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierName();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$currPos;\n        s6 = peg$parseStringLiteral();\n        if (s6 !== peg$FAILED) {\n          s7 = peg$parse__();\n          if (s7 !== peg$FAILED) {\n            s6 = [s6, s7];\n            s5 = s6;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        if (s5 === peg$FAILED) {\n          s5 = null;\n        }\n        if (s5 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s6 = peg$c2;\n            peg$currPos++;\n          } else {\n            s6 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c3); }\n          }\n          if (s6 !== peg$FAILED) {\n            s4 = [s4, s5, s6];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c32(s1);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSemanticPredicateExpression() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseSemanticPredicateOperator();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseCodeBlock();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c33(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSemanticPredicateOperator() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 38) {\n      s0 = peg$c16;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c17); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s0 = peg$c18;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c19); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSourceCharacter() {\n    var s0;\n\n    if (input.length > peg$currPos) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseWhiteSpace() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 9) {\n      s0 = peg$c36;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c37); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 11) {\n        s0 = peg$c38;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c39); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 12) {\n          s0 = peg$c40;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c41); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s0 = peg$c42;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c43); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 160) {\n              s0 = peg$c44;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c45); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 65279) {\n                s0 = peg$c46;\n                peg$currPos++;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c47); }\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$parseZs();\n              }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c35); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineTerminator() {\n    var s0;\n\n    if (peg$c48.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c49); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineTerminatorSequence() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 10) {\n      s0 = peg$c51;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c52); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c53) {\n        s0 = peg$c53;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c54); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 13) {\n          s0 = peg$c55;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c56); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 8232) {\n            s0 = peg$c57;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c58); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 8233) {\n              s0 = peg$c59;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c60); }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseComment() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parseMultiLineComment();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseSingleLineComment();\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c61); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseMultiLineComment() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c62) {\n      s1 = peg$c62;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c63); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (input.substr(peg$currPos, 2) === peg$c64) {\n        s5 = peg$c64;\n        peg$currPos += 2;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c65); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c64) {\n          s5 = peg$c64;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c65); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c64) {\n          s3 = peg$c64;\n          peg$currPos += 2;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c65); }\n        }\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMultiLineCommentNoLineTerminator() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c62) {\n      s1 = peg$c62;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c63); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (input.substr(peg$currPos, 2) === peg$c64) {\n        s5 = peg$c64;\n        peg$currPos += 2;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c65); }\n      }\n      if (s5 === peg$FAILED) {\n        s5 = peg$parseLineTerminator();\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c64) {\n          s5 = peg$c64;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c65); }\n        }\n        if (s5 === peg$FAILED) {\n          s5 = peg$parseLineTerminator();\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c64) {\n          s3 = peg$c64;\n          peg$currPos += 2;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c65); }\n        }\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSingleLineComment() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c66) {\n      s1 = peg$c66;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parseLineTerminator();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseLineTerminator();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifier() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    s2 = peg$parseReservedWord();\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = void 0;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseIdentifierName();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c68(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifierName() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierStart();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseIdentifierPart();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseIdentifierPart();\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c70(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c69); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifierStart() {\n    var s0, s1, s2;\n\n    s0 = peg$parseUnicodeLetter();\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 36) {\n        s0 = peg$c14;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c15); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 95) {\n          s0 = peg$c71;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c72); }\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 92) {\n            s1 = peg$c73;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c74); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseUnicodeEscapeSequence();\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c75(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifierPart() {\n    var s0;\n\n    s0 = peg$parseIdentifierStart();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseUnicodeCombiningMark();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseNd();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsePc();\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 8204) {\n              s0 = peg$c76;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c77); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 8205) {\n                s0 = peg$c78;\n                peg$currPos++;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c79); }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodeLetter() {\n    var s0;\n\n    s0 = peg$parseLu();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseLl();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLt();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseLm();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseLo();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseNl();\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodeCombiningMark() {\n    var s0;\n\n    s0 = peg$parseMn();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseMc();\n    }\n\n    return s0;\n  }\n\n  function peg$parseReservedWord() {\n    var s0;\n\n    s0 = peg$parseKeyword();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseFutureReservedWord();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseNullToken();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseBooleanLiteral();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseKeyword() {\n    var s0;\n\n    s0 = peg$parseBreakToken();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseCaseToken();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseCatchToken();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseContinueToken();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseDebuggerToken();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseDefaultToken();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parseDeleteToken();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parseDoToken();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseElseToken();\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parseFinallyToken();\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parseForToken();\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parseFunctionToken();\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parseIfToken();\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$parseInstanceofToken();\n                              if (s0 === peg$FAILED) {\n                                s0 = peg$parseInToken();\n                                if (s0 === peg$FAILED) {\n                                  s0 = peg$parseNewToken();\n                                  if (s0 === peg$FAILED) {\n                                    s0 = peg$parseReturnToken();\n                                    if (s0 === peg$FAILED) {\n                                      s0 = peg$parseSwitchToken();\n                                      if (s0 === peg$FAILED) {\n                                        s0 = peg$parseThisToken();\n                                        if (s0 === peg$FAILED) {\n                                          s0 = peg$parseThrowToken();\n                                          if (s0 === peg$FAILED) {\n                                            s0 = peg$parseTryToken();\n                                            if (s0 === peg$FAILED) {\n                                              s0 = peg$parseTypeofToken();\n                                              if (s0 === peg$FAILED) {\n                                                s0 = peg$parseVarToken();\n                                                if (s0 === peg$FAILED) {\n                                                  s0 = peg$parseVoidToken();\n                                                  if (s0 === peg$FAILED) {\n                                                    s0 = peg$parseWhileToken();\n                                                    if (s0 === peg$FAILED) {\n                                                      s0 = peg$parseWithToken();\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseFutureReservedWord() {\n    var s0;\n\n    s0 = peg$parseClassToken();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseConstToken();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseEnumToken();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseExportToken();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseExtendsToken();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseImportToken();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parseSuperToken();\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseBooleanLiteral() {\n    var s0;\n\n    s0 = peg$parseTrueToken();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseFalseToken();\n    }\n\n    return s0;\n  }\n\n  function peg$parseLiteralMatcher() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseStringLiteral();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 105) {\n        s2 = peg$c81;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c82); }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c83(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c80); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseStringLiteral() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s1 = peg$c85;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c86); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseDoubleStringCharacter();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseDoubleStringCharacter();\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s3 = peg$c85;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c86); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c87(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 39) {\n        s1 = peg$c88;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c89); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseSingleStringCharacter();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseSingleStringCharacter();\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 39) {\n            s3 = peg$c88;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c89); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c87(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c84); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseDoubleStringCharacter() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s2 = peg$c85;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c86); }\n    }\n    if (s2 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s2 = peg$c73;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseLineTerminator();\n      }\n    }\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = void 0;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseSourceCharacter();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c90();\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c73;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEscapeSequence();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c75(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLineContinuation();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSingleStringCharacter() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 39) {\n      s2 = peg$c88;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c89); }\n    }\n    if (s2 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s2 = peg$c73;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseLineTerminator();\n      }\n    }\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = void 0;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseSourceCharacter();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c90();\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c73;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEscapeSequence();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c75(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLineContinuation();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCharacterClassMatcher() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c92;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c93); }\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 94) {\n        s2 = peg$c94;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c95); }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parseClassCharacterRange();\n        if (s4 === peg$FAILED) {\n          s4 = peg$parseClassCharacter();\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parseClassCharacterRange();\n          if (s4 === peg$FAILED) {\n            s4 = peg$parseClassCharacter();\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 93) {\n            s4 = peg$c96;\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c97); }\n          }\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 105) {\n              s5 = peg$c81;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c82); }\n            }\n            if (s5 === peg$FAILED) {\n              s5 = null;\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c98(s2, s3, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c91); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseClassCharacterRange() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseClassCharacter();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s2 = peg$c99;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c100); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseClassCharacter();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c101(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseClassCharacter() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 93) {\n      s2 = peg$c96;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c97); }\n    }\n    if (s2 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s2 = peg$c73;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseLineTerminator();\n      }\n    }\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = void 0;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseSourceCharacter();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c90();\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c73;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEscapeSequence();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c75(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLineContinuation();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineContinuation() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s1 = peg$c73;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c74); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseLineTerminatorSequence();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c102();\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEscapeSequence() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$parseCharacterEscapeSequence();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 48) {\n        s1 = peg$c103;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c104); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        peg$silentFails++;\n        s3 = peg$parseDecimalDigit();\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = void 0;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c105();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseHexEscapeSequence();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseUnicodeEscapeSequence();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCharacterEscapeSequence() {\n    var s0;\n\n    s0 = peg$parseSingleEscapeCharacter();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseNonEscapeCharacter();\n    }\n\n    return s0;\n  }\n\n  function peg$parseSingleEscapeCharacter() {\n    var s0, s1;\n\n    if (input.charCodeAt(peg$currPos) === 39) {\n      s0 = peg$c88;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c89); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s0 = peg$c85;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c86); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s0 = peg$c73;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c74); }\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 98) {\n            s1 = peg$c106;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c107); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c108();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 102) {\n              s1 = peg$c109;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c110); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c111();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 110) {\n                s1 = peg$c112;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c113); }\n              }\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c114();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 114) {\n                  s1 = peg$c115;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c116); }\n                }\n                if (s1 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c117();\n                }\n                s0 = s1;\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 116) {\n                    s1 = peg$c118;\n                    peg$currPos++;\n                  } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c119); }\n                  }\n                  if (s1 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c120();\n                  }\n                  s0 = s1;\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    if (input.charCodeAt(peg$currPos) === 118) {\n                      s1 = peg$c121;\n                      peg$currPos++;\n                    } else {\n                      s1 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c122); }\n                    }\n                    if (s1 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c123();\n                    }\n                    s0 = s1;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNonEscapeCharacter() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    s2 = peg$parseEscapeCharacter();\n    if (s2 === peg$FAILED) {\n      s2 = peg$parseLineTerminator();\n    }\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = void 0;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseSourceCharacter();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c90();\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEscapeCharacter() {\n    var s0;\n\n    s0 = peg$parseSingleEscapeCharacter();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseDecimalDigit();\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 120) {\n          s0 = peg$c124;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c125); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 117) {\n            s0 = peg$c126;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c127); }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseHexEscapeSequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 120) {\n      s1 = peg$c124;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c125); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$parseHexDigit();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseHexDigit();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c128(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodeEscapeSequence() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 117) {\n      s1 = peg$c126;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c127); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$parseHexDigit();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseHexDigit();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseHexDigit();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseHexDigit();\n            if (s7 !== peg$FAILED) {\n              s4 = [s4, s5, s6, s7];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c128(s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseDecimalDigit() {\n    var s0;\n\n    if (peg$c129.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c130); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseHexDigit() {\n    var s0;\n\n    if (peg$c131.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c132); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseAnyMatcher() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c133;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c134); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c135();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseCodeBlock() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c137;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c138); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseCode();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 125) {\n          s3 = peg$c139;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c140); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c141(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c136); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCode() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = [];\n    s3 = peg$currPos;\n    s4 = peg$currPos;\n    peg$silentFails++;\n    if (peg$c142.test(input.charAt(peg$currPos))) {\n      s5 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s5 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c143); }\n    }\n    peg$silentFails--;\n    if (s5 === peg$FAILED) {\n      s4 = void 0;\n    } else {\n      peg$currPos = s4;\n      s4 = peg$FAILED;\n    }\n    if (s4 !== peg$FAILED) {\n      s5 = peg$parseSourceCharacter();\n      if (s5 !== peg$FAILED) {\n        s4 = [s4, s5];\n        s3 = s4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s3;\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (peg$c142.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c143); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 === peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s3 = peg$c137;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c138); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseCode();\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s5 = peg$c139;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c140); }\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (peg$c142.test(input.charAt(peg$currPos))) {\n        s5 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c143); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          if (peg$c142.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c143); }\n          }\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = void 0;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseSourceCharacter();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s3 = peg$c137;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c138); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseCode();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 125) {\n              s5 = peg$c139;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c140); }\n            }\n            if (s5 !== peg$FAILED) {\n              s3 = [s3, s4, s5];\n              s2 = s3;\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLl() {\n    var s0;\n\n    if (peg$c144.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c145); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLm() {\n    var s0;\n\n    if (peg$c146.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c147); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLo() {\n    var s0;\n\n    if (peg$c148.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c149); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLt() {\n    var s0;\n\n    if (peg$c150.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c151); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLu() {\n    var s0;\n\n    if (peg$c152.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c153); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseMc() {\n    var s0;\n\n    if (peg$c154.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c155); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseMn() {\n    var s0;\n\n    if (peg$c156.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c157); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNd() {\n    var s0;\n\n    if (peg$c158.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c159); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNl() {\n    var s0;\n\n    if (peg$c160.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c161); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsePc() {\n    var s0;\n\n    if (peg$c162.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c163); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseZs() {\n    var s0;\n\n    if (peg$c164.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c165); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseBreakToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c166) {\n      s1 = peg$c166;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c167); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseCaseToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4) === peg$c168) {\n      s1 = peg$c168;\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c169); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseCatchToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c170) {\n      s1 = peg$c170;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c171); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseClassToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c172) {\n      s1 = peg$c172;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c173); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseConstToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c174) {\n      s1 = peg$c174;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c175); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseContinueToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 8) === peg$c176) {\n      s1 = peg$c176;\n      peg$currPos += 8;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c177); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseDebuggerToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 8) === peg$c178) {\n      s1 = peg$c178;\n      peg$currPos += 8;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c179); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseDefaultToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 7) === peg$c180) {\n      s1 = peg$c180;\n      peg$currPos += 7;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c181); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseDeleteToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c182) {\n      s1 = peg$c182;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c183); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseDoToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c184) {\n      s1 = peg$c184;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c185); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseElseToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4) === peg$c186) {\n      s1 = peg$c186;\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c187); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEnumToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4) === peg$c188) {\n      s1 = peg$c188;\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c189); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseExportToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c190) {\n      s1 = peg$c190;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c191); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseExtendsToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 7) === peg$c192) {\n      s1 = peg$c192;\n      peg$currPos += 7;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c193); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseFalseToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c194) {\n      s1 = peg$c194;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c195); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseFinallyToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 7) === peg$c196) {\n      s1 = peg$c196;\n      peg$currPos += 7;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c197); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseForToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 3) === peg$c198) {\n      s1 = peg$c198;\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c199); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseFunctionToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 8) === peg$c200) {\n      s1 = peg$c200;\n      peg$currPos += 8;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c201); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseIfToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c202) {\n      s1 = peg$c202;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c203); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseImportToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c204) {\n      s1 = peg$c204;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c205); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseInstanceofToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 10) === peg$c206) {\n      s1 = peg$c206;\n      peg$currPos += 10;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c207); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseInToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c208) {\n      s1 = peg$c208;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c209); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseNewToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 3) === peg$c210) {\n      s1 = peg$c210;\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c211); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseNullToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4) === peg$c212) {\n      s1 = peg$c212;\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c213); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseReturnToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c214) {\n      s1 = peg$c214;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c215); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSuperToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c216) {\n      s1 = peg$c216;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c217); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSwitchToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c218) {\n      s1 = peg$c218;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c219); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseThisToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4) === peg$c220) {\n      s1 = peg$c220;\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c221); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseThrowToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c222) {\n      s1 = peg$c222;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c223); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseTrueToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4) === peg$c224) {\n      s1 = peg$c224;\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c225); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseTryToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 3) === peg$c226) {\n      s1 = peg$c226;\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c227); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseTypeofToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c228) {\n      s1 = peg$c228;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c229); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseVarToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 3) === peg$c230) {\n      s1 = peg$c230;\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c231); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseVoidToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4) === peg$c232) {\n      s1 = peg$c232;\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c233); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseWhileToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c234) {\n      s1 = peg$c234;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c235); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseWithToken() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4) === peg$c236) {\n      s1 = peg$c236;\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c237); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$parseIdentifierPart();\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = void 0;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parse__() {\n    var s0, s1;\n\n    s0 = [];\n    s1 = peg$parseWhiteSpace();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseLineTerminatorSequence();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseComment();\n      }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseWhiteSpace();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseLineTerminatorSequence();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseComment();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    s0 = [];\n    s1 = peg$parseWhiteSpace();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseMultiLineCommentNoLineTerminator();\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseWhiteSpace();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseMultiLineCommentNoLineTerminator();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOS() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse__();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 59) {\n        s2 = peg$c238;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c239); }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseSingleLineComment();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseLineTerminatorSequence();\n          if (s3 !== peg$FAILED) {\n            s1 = [s1, s2, s3];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse__();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseEOF();\n          if (s2 !== peg$FAILED) {\n            s1 = [s1, s2];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOF() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = void 0;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n\n    var OPS_TO_PREFIXED_TYPES = {\n      \"$\": \"text\",\n      \"&\": \"simple_and\",\n      \"!\": \"simple_not\"\n    };\n\n    var OPS_TO_SUFFIXED_TYPES = {\n      \"?\": \"optional\",\n      \"*\": \"zero_or_more\",\n      \"+\": \"one_or_more\"\n    };\n\n    var OPS_TO_SEMANTIC_PREDICATE_TYPES = {\n      \"&\": \"semantic_and\",\n      \"!\": \"semantic_not\"\n    };\n\n    function filterEmptyStrings(array) {\n      var result = [], i;\n\n      for (i = 0; i < array.length; i++) {\n        if (array[i] !== \"\") {\n          result.push(array[i]);\n        }\n      }\n\n      return result;\n    }\n\n    function extractOptional(optional, index) {\n      return optional ? optional[index] : null;\n    }\n\n    function extractList(list, index) {\n      var result = new Array(list.length), i;\n\n      for (i = 0; i < list.length; i++) {\n        result[i] = list[i][index];\n      }\n\n      return result;\n    }\n\n    function buildList(head, tail, index) {\n      return [head].concat(extractList(tail, index));\n    }\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n","\"use strict\";\n\nvar objects = require(\"../utils/objects\"),\n    arrays  = require(\"../utils/arrays\");\n\n/* Simple AST node visitor builder. */\nvar visitor = {\n  build: function(functions) {\n    function visit(node) {\n      return functions[node.type].apply(null, arguments);\n    }\n\n    function visitNop() { }\n\n    function visitExpression(node) {\n      var extraArgs = Array.prototype.slice.call(arguments, 1);\n\n      visit.apply(null, [node.expression].concat(extraArgs));\n    }\n\n    function visitChildren(property) {\n      return function(node) {\n        var extraArgs = Array.prototype.slice.call(arguments, 1);\n\n        arrays.each(node[property], function(child) {\n          visit.apply(null, [child].concat(extraArgs));\n        });\n      };\n    }\n\n    var DEFAULT_FUNCTIONS = {\n          grammar: function(node) {\n            var extraArgs = Array.prototype.slice.call(arguments, 1);\n\n            if (node.initializer) {\n              visit.apply(null, [node.initializer].concat(extraArgs));\n            }\n\n            arrays.each(node.rules, function(rule) {\n              visit.apply(null, [rule].concat(extraArgs));\n            });\n          },\n\n          initializer:  visitNop,\n          rule:         visitExpression,\n          named:        visitExpression,\n          choice:       visitChildren(\"alternatives\"),\n          action:       visitExpression,\n          sequence:     visitChildren(\"elements\"),\n          labeled:      visitExpression,\n          text:         visitExpression,\n          simple_and:   visitExpression,\n          simple_not:   visitExpression,\n          optional:     visitExpression,\n          zero_or_more: visitExpression,\n          one_or_more:  visitExpression,\n          group:        visitExpression,\n          semantic_and: visitNop,\n          semantic_not: visitNop,\n          rule_ref:     visitNop,\n          literal:      visitNop,\n          \"class\":      visitNop,\n          any:          visitNop\n        };\n\n    objects.defaults(functions, DEFAULT_FUNCTIONS);\n\n    return visit;\n  }\n};\n\nmodule.exports = visitor;\n","\"use strict\";\n\nvar arrays  = require(\"../utils/arrays\"),\n    visitor = require(\"./visitor\");\n\n/* AST utilities. */\nvar asts = {\n  findRule: function(ast, name) {\n    return arrays.find(ast.rules, function(r) { return r.name === name; });\n  },\n\n  indexOfRule: function(ast, name) {\n    return arrays.indexOf(ast.rules, function(r) { return r.name === name; });\n  },\n\n  alwaysConsumesOnSuccess: function(ast, node) {\n    function consumesTrue()  { return true;  }\n    function consumesFalse() { return false; }\n\n    function consumesExpression(node) {\n      return consumes(node.expression);\n    }\n\n    var consumes = visitor.build({\n      rule:  consumesExpression,\n      named: consumesExpression,\n\n      choice: function(node) {\n        return arrays.every(node.alternatives, consumes);\n      },\n\n      action: consumesExpression,\n\n      sequence: function(node) {\n        return arrays.some(node.elements, consumes);\n      },\n\n      labeled:      consumesExpression,\n      text:         consumesExpression,\n      simple_and:   consumesFalse,\n      simple_not:   consumesFalse,\n      optional:     consumesFalse,\n      zero_or_more: consumesFalse,\n      one_or_more:  consumesExpression,\n      group:        consumesExpression,\n      semantic_and: consumesFalse,\n      semantic_not: consumesFalse,\n\n      rule_ref: function(node) {\n        return consumes(asts.findRule(ast, node.name));\n      },\n\n      literal: function(node) {\n        return node.value !== \"\";\n      },\n\n      \"class\": consumesTrue,\n      any:     consumesTrue\n    });\n\n    return consumes(node);\n  }\n};\n\nmodule.exports = asts;\n","\"use strict\";\n\nvar GrammarError = require(\"../../grammar-error\"),\n    asts         = require(\"../asts\"),\n    visitor      = require(\"../visitor\");\n\n/* Checks that all referenced rules exist. */\nfunction reportUndefinedRules(ast) {\n  var check = visitor.build({\n    rule_ref: function(node) {\n      if (!asts.findRule(ast, node.name)) {\n        throw new GrammarError(\n          \"Rule \\\"\" + node.name + \"\\\" is not defined.\",\n          node.location\n        );\n      }\n    }\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportUndefinedRules;\n","\"use strict\";\n\nvar GrammarError = require(\"../../grammar-error\"),\n    visitor      = require(\"../visitor\");\n\n/* Checks that each rule is defined only once. */\nfunction reportDuplicateRules(ast) {\n  var rules = {};\n\n  var check = visitor.build({\n    rule: function(node) {\n      if (rules.hasOwnProperty(node.name)) {\n        throw new GrammarError(\n          \"Rule \\\"\" + node.name + \"\\\" is already defined \"\n            + \"at line \" + rules[node.name].start.line + \", \"\n            + \"column \" + rules[node.name].start.column + \".\",\n          node.location\n        );\n      }\n\n      rules[node.name] = node.location;\n    }\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportDuplicateRules;\n","\"use strict\";\n\nvar GrammarError = require(\"../../grammar-error\"),\n    arrays       = require(\"../../utils/arrays\"),\n    objects      = require(\"../../utils/objects\"),\n    visitor      = require(\"../visitor\");\n\n/* Checks that each label is defined only once within each scope. */\nfunction reportDuplicateLabels(ast) {\n  function checkExpressionWithClonedEnv(node, env) {\n    check(node.expression, objects.clone(env));\n  }\n\n  var check = visitor.build({\n    rule: function(node) {\n      check(node.expression, { });\n    },\n\n    choice: function(node, env) {\n      arrays.each(node.alternatives, function(alternative) {\n        check(alternative, objects.clone(env));\n      });\n    },\n\n    action: checkExpressionWithClonedEnv,\n\n    labeled: function(node, env) {\n      if (env.hasOwnProperty(node.label)) {\n        throw new GrammarError(\n          \"Label \\\"\" + node.label + \"\\\" is already defined \"\n            + \"at line \" + env[node.label].start.line + \", \"\n            + \"column \" + env[node.label].start.column + \".\",\n          node.location\n        );\n      }\n\n      check(node.expression, env);\n\n      env[node.label] = node.location;\n    },\n\n    text:         checkExpressionWithClonedEnv,\n    simple_and:   checkExpressionWithClonedEnv,\n    simple_not:   checkExpressionWithClonedEnv,\n    optional:     checkExpressionWithClonedEnv,\n    zero_or_more: checkExpressionWithClonedEnv,\n    one_or_more:  checkExpressionWithClonedEnv,\n    group:        checkExpressionWithClonedEnv\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportDuplicateLabels;\n","\"use strict\";\n\nvar arrays       = require(\"../../utils/arrays\"),\n    GrammarError = require(\"../../grammar-error\"),\n    asts         = require(\"../asts\"),\n    visitor      = require(\"../visitor\");\n\n/*\n * Reports left recursion in the grammar, which prevents infinite recursion in\n * the generated parser.\n *\n * Both direct and indirect recursion is detected. The pass also correctly\n * reports cases like this:\n *\n *   start = \"a\"? start\n *\n * In general, if a rule reference can be reached without consuming any input,\n * it can lead to left recursion.\n */\nfunction reportInfiniteRecursion(ast) {\n  var visitedRules = [];\n\n  var check = visitor.build({\n    rule: function(node) {\n      visitedRules.push(node.name);\n      check(node.expression);\n      visitedRules.pop(node.name);\n    },\n\n    sequence: function(node) {\n      arrays.every(node.elements, function(element) {\n        check(element);\n\n        return !asts.alwaysConsumesOnSuccess(ast, element);\n      });\n    },\n\n    rule_ref: function(node) {\n      if (arrays.contains(visitedRules, node.name)) {\n        visitedRules.push(node.name);\n\n        throw new GrammarError(\n          \"Possible infinite loop when parsing (left recursion: \"\n            + visitedRules.join(\" -> \")\n            + \").\",\n          node.location\n        );\n      }\n\n      check(asts.findRule(ast, node.name));\n    }\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportInfiniteRecursion;\n","\"use strict\";\n\nvar GrammarError = require(\"../../grammar-error\"),\n    asts         = require(\"../asts\"),\n    visitor      = require(\"../visitor\");\n\n/*\n * Reports expressions that don't consume any input inside |*| or |+| in the\n * grammar, which prevents infinite loops in the generated parser.\n */\nfunction reportInfiniteRepetition(ast) {\n  var check = visitor.build({\n    zero_or_more: function(node) {\n      if (!asts.alwaysConsumesOnSuccess(ast, node.expression)) {\n        throw new GrammarError(\n          \"Possible infinite loop when parsing (repetition used with an expression that may not consume any input).\",\n          node.location\n        );\n      }\n    },\n\n    one_or_more: function(node) {\n      if (!asts.alwaysConsumesOnSuccess(ast, node.expression)) {\n        throw new GrammarError(\n          \"Possible infinite loop when parsing (repetition used with an expression that may not consume any input).\",\n          node.location\n        );\n      }\n    }\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportInfiniteRepetition;\n","\"use strict\";\n\nvar arrays  = require(\"../../utils/arrays\"),\n    visitor = require(\"../visitor\");\n\n/*\n * Removes proxy rules -- that is, rules that only delegate to other rule.\n */\nfunction removeProxyRules(ast, options) {\n  function isProxyRule(node) {\n    return node.type === \"rule\" && node.expression.type === \"rule_ref\";\n  }\n\n  function replaceRuleRefs(ast, from, to) {\n    var replace = visitor.build({\n      rule_ref: function(node) {\n        if (node.name === from) {\n          node.name = to;\n        }\n      }\n    });\n\n    replace(ast);\n  }\n\n  var indices = [];\n\n  arrays.each(ast.rules, function(rule, i) {\n    if (isProxyRule(rule)) {\n      replaceRuleRefs(ast, rule.name, rule.expression.name);\n      if (!arrays.contains(options.allowedStartRules, rule.name)) {\n        indices.push(i);\n      }\n    }\n  });\n\n  indices.reverse();\n\n  arrays.each(indices, function(i) { ast.rules.splice(i, 1); });\n}\n\nmodule.exports = removeProxyRules;\n","\"use strict\";\n\n/* Bytecode instruction opcodes. */\nvar opcodes = {\n  /* Stack Manipulation */\n\n  PUSH:             0,    // PUSH c\n  PUSH_UNDEFINED:   1,    // PUSH_UNDEFINED\n  PUSH_NULL:        2,    // PUSH_NULL\n  PUSH_FAILED:      3,    // PUSH_FAILED\n  PUSH_EMPTY_ARRAY: 4,    // PUSH_EMPTY_ARRAY\n  PUSH_CURR_POS:    5,    // PUSH_CURR_POS\n  POP:              6,    // POP\n  POP_CURR_POS:     7,    // POP_CURR_POS\n  POP_N:            8,    // POP_N n\n  NIP:              9,    // NIP\n  APPEND:           10,   // APPEND\n  WRAP:             11,   // WRAP n\n  TEXT:             12,   // TEXT\n\n  /* Conditions and Loops */\n\n  IF:               13,   // IF t, f\n  IF_ERROR:         14,   // IF_ERROR t, f\n  IF_NOT_ERROR:     15,   // IF_NOT_ERROR t, f\n  WHILE_NOT_ERROR:  16,   // WHILE_NOT_ERROR b\n\n  /* Matching */\n\n  MATCH_ANY:        17,   // MATCH_ANY a, f, ...\n  MATCH_STRING:     18,   // MATCH_STRING s, a, f, ...\n  MATCH_STRING_IC:  19,   // MATCH_STRING_IC s, a, f, ...\n  MATCH_REGEXP:     20,   // MATCH_REGEXP r, a, f, ...\n  ACCEPT_N:         21,   // ACCEPT_N n\n  ACCEPT_STRING:    22,   // ACCEPT_STRING s\n  FAIL:             23,   // FAIL e\n\n  /* Calls */\n\n  LOAD_SAVED_POS:   24,   // LOAD_SAVED_POS p\n  UPDATE_SAVED_POS: 25,   // UPDATE_SAVED_POS\n  CALL:             26,   // CALL f, n, pc, p1, p2, ..., pN\n\n  /* Rules */\n\n  RULE:             27,   // RULE r\n\n  /* Failure Reporting */\n\n  SILENT_FAILS_ON:  28,   // SILENT_FAILS_ON\n  SILENT_FAILS_OFF: 29    // SILENT_FAILS_OFF\n};\n\nmodule.exports = opcodes;\n","\"use strict\";\n\nfunction hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n/* JavaScript code generation helpers. */\nvar js = {\n  stringEscape: function(s) {\n    /*\n     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string\n     * literal except for the closing quote character, backslash, carriage\n     * return, line separator, paragraph separator, and line feed. Any character\n     * may appear in the form of an escape sequence.\n     *\n     * For portability, we also escape all control and non-ASCII characters.\n     * Note that the \"\\v\" escape sequence is not used because IE does not like\n     * it.\n     */\n    return s\n      .replace(/\\\\/g,   '\\\\\\\\')   // backslash\n      .replace(/\"/g,    '\\\\\"')    // closing double quote\n      .replace(/\\0/g,   '\\\\0')    // null\n      .replace(/\\x08/g, '\\\\b')    // backspace\n      .replace(/\\t/g,   '\\\\t')    // horizontal tab\n      .replace(/\\n/g,   '\\\\n')    // line feed\n      .replace(/\\f/g,   '\\\\f')    // form feed\n      .replace(/\\r/g,   '\\\\r')    // carriage return\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\xFF]/g, function(ch) { return '\\\\x'  + hex(ch); })\n      .replace(/[\\u0100-\\u0FFF]/g,      function(ch) { return '\\\\u0' + hex(ch); })\n      .replace(/[\\u1000-\\uFFFF]/g,      function(ch) { return '\\\\u'  + hex(ch); });\n  },\n\n  regexpClassEscape: function(s) {\n    /*\n     * Based on ECMA-262, 5th ed., 7.8.5 & 15.10.1.\n     *\n     * For portability, we also escape all control and non-ASCII characters.\n     */\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')    // backslash\n      .replace(/\\//g, '\\\\/')     // closing slash\n      .replace(/\\]/g, '\\\\]')     // closing bracket\n      .replace(/\\^/g, '\\\\^')     // caret\n      .replace(/-/g,  '\\\\-')     // dash\n      .replace(/\\0/g, '\\\\0')     // null\n      .replace(/\\t/g, '\\\\t')     // horizontal tab\n      .replace(/\\n/g, '\\\\n')     // line feed\n      .replace(/\\v/g, '\\\\x0B')   // vertical tab\n      .replace(/\\f/g, '\\\\f')     // form feed\n      .replace(/\\r/g, '\\\\r')     // carriage return\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\xFF]/g, function(ch) { return '\\\\x'  + hex(ch); })\n      .replace(/[\\u0100-\\u0FFF]/g,      function(ch) { return '\\\\u0' + hex(ch); })\n      .replace(/[\\u1000-\\uFFFF]/g,      function(ch) { return '\\\\u'  + hex(ch); });\n  }\n};\n\nmodule.exports = js;\n","\"use strict\";\n\nvar arrays  = require(\"../../utils/arrays\"),\n    objects = require(\"../../utils/objects\"),\n    asts    = require(\"../asts\"),\n    visitor = require(\"../visitor\"),\n    op      = require(\"../opcodes\"),\n    js      = require(\"../js\");\n\n/* Generates bytecode.\n *\n * Instructions\n * ============\n *\n * Stack Manipulation\n * ------------------\n *\n *  [0] PUSH c\n *\n *        stack.push(consts[c]);\n *\n *  [1] PUSH_UNDEFINED\n *\n *        stack.push(undefined);\n *\n *  [2] PUSH_NULL\n *\n *        stack.push(null);\n *\n *  [3] PUSH_FAILED\n *\n *        stack.push(FAILED);\n *\n *  [4] PUSH_EMPTY_ARRAY\n *\n *        stack.push([]);\n *\n *  [5] PUSH_CURR_POS\n *\n *        stack.push(currPos);\n *\n *  [6] POP\n *\n *        stack.pop();\n *\n *  [7] POP_CURR_POS\n *\n *        currPos = stack.pop();\n *\n *  [8] POP_N n\n *\n *        stack.pop(n);\n *\n *  [9] NIP\n *\n *        value = stack.pop();\n *        stack.pop();\n *        stack.push(value);\n *\n * [10] APPEND\n *\n *        value = stack.pop();\n *        array = stack.pop();\n *        array.push(value);\n *        stack.push(array);\n *\n * [11] WRAP n\n *\n *        stack.push(stack.pop(n));\n *\n * [12] TEXT\n *\n *        stack.push(input.substring(stack.pop(), currPos));\n *\n * Conditions and Loops\n * --------------------\n *\n * [13] IF t, f\n *\n *        if (stack.top()) {\n *          interpret(ip + 3, ip + 3 + t);\n *        } else {\n *          interpret(ip + 3 + t, ip + 3 + t + f);\n *        }\n *\n * [14] IF_ERROR t, f\n *\n *        if (stack.top() === FAILED) {\n *          interpret(ip + 3, ip + 3 + t);\n *        } else {\n *          interpret(ip + 3 + t, ip + 3 + t + f);\n *        }\n *\n * [15] IF_NOT_ERROR t, f\n *\n *        if (stack.top() !== FAILED) {\n *          interpret(ip + 3, ip + 3 + t);\n *        } else {\n *          interpret(ip + 3 + t, ip + 3 + t + f);\n *        }\n *\n * [16] WHILE_NOT_ERROR b\n *\n *        while(stack.top() !== FAILED) {\n *          interpret(ip + 2, ip + 2 + b);\n *        }\n *\n * Matching\n * --------\n *\n * [17] MATCH_ANY a, f, ...\n *\n *        if (input.length > currPos) {\n *          interpret(ip + 3, ip + 3 + a);\n *        } else {\n *          interpret(ip + 3 + a, ip + 3 + a + f);\n *        }\n *\n * [18] MATCH_STRING s, a, f, ...\n *\n *        if (input.substr(currPos, consts[s].length) === consts[s]) {\n *          interpret(ip + 4, ip + 4 + a);\n *        } else {\n *          interpret(ip + 4 + a, ip + 4 + a + f);\n *        }\n *\n * [19] MATCH_STRING_IC s, a, f, ...\n *\n *        if (input.substr(currPos, consts[s].length).toLowerCase() === consts[s]) {\n *          interpret(ip + 4, ip + 4 + a);\n *        } else {\n *          interpret(ip + 4 + a, ip + 4 + a + f);\n *        }\n *\n * [20] MATCH_REGEXP r, a, f, ...\n *\n *        if (consts[r].test(input.charAt(currPos))) {\n *          interpret(ip + 4, ip + 4 + a);\n *        } else {\n *          interpret(ip + 4 + a, ip + 4 + a + f);\n *        }\n *\n * [21] ACCEPT_N n\n *\n *        stack.push(input.substring(currPos, n));\n *        currPos += n;\n *\n * [22] ACCEPT_STRING s\n *\n *        stack.push(consts[s]);\n *        currPos += consts[s].length;\n *\n * [23] FAIL e\n *\n *        stack.push(FAILED);\n *        fail(consts[e]);\n *\n * Calls\n * -----\n *\n * [24] LOAD_SAVED_POS p\n *\n *        savedPos = stack[p];\n *\n * [25] UPDATE_SAVED_POS\n *\n *        savedPos = currPos;\n *\n * [26] CALL f, n, pc, p1, p2, ..., pN\n *\n *        value = consts[f](stack[p1], ..., stack[pN]);\n *        stack.pop(n);\n *        stack.push(value);\n *\n * Rules\n * -----\n *\n * [27] RULE r\n *\n *        stack.push(parseRule(r));\n *\n * Failure Reporting\n * -----------------\n *\n * [28] SILENT_FAILS_ON\n *\n *        silentFails++;\n *\n * [29] SILENT_FAILS_OFF\n *\n *        silentFails--;\n */\nfunction generateBytecode(ast) {\n  var consts = [];\n\n  function addConst(value) {\n    var index = arrays.indexOf(consts, value);\n\n    return index === -1 ? consts.push(value) - 1 : index;\n  }\n\n  function addFunctionConst(params, code) {\n    return addConst(\n      \"function(\" + params.join(\", \") + \") {\" + code + \"}\"\n    );\n  }\n\n  function buildSequence() {\n    return Array.prototype.concat.apply([], arguments);\n  }\n\n  function buildCondition(condCode, thenCode, elseCode) {\n    return condCode.concat(\n      [thenCode.length, elseCode.length],\n      thenCode,\n      elseCode\n    );\n  }\n\n  function buildLoop(condCode, bodyCode) {\n    return condCode.concat([bodyCode.length], bodyCode);\n  }\n\n  function buildCall(functionIndex, delta, env, sp) {\n    var params = arrays.map(objects.values(env), function(p) { return sp - p; });\n\n    return [op.CALL, functionIndex, delta, params.length].concat(params);\n  }\n\n  function buildSimplePredicate(expression, negative, context) {\n    return buildSequence(\n      [op.PUSH_CURR_POS],\n      [op.SILENT_FAILS_ON],\n      generate(expression, {\n        sp:     context.sp + 1,\n        env:    objects.clone(context.env),\n        action: null\n      }),\n      [op.SILENT_FAILS_OFF],\n      buildCondition(\n        [negative ? op.IF_ERROR : op.IF_NOT_ERROR],\n        buildSequence(\n          [op.POP],\n          [negative ? op.POP : op.POP_CURR_POS],\n          [op.PUSH_UNDEFINED]\n        ),\n        buildSequence(\n          [op.POP],\n          [negative ? op.POP_CURR_POS : op.POP],\n          [op.PUSH_FAILED]\n        )\n      )\n    );\n  }\n\n  function buildSemanticPredicate(code, negative, context) {\n    var functionIndex = addFunctionConst(objects.keys(context.env), code);\n\n    return buildSequence(\n      [op.UPDATE_SAVED_POS],\n      buildCall(functionIndex, 0, context.env, context.sp),\n      buildCondition(\n        [op.IF],\n        buildSequence(\n          [op.POP],\n          negative ? [op.PUSH_FAILED] : [op.PUSH_UNDEFINED]\n        ),\n        buildSequence(\n          [op.POP],\n          negative ? [op.PUSH_UNDEFINED] : [op.PUSH_FAILED]\n        )\n      )\n    );\n  }\n\n  function buildAppendLoop(expressionCode) {\n    return buildLoop(\n      [op.WHILE_NOT_ERROR],\n      buildSequence([op.APPEND], expressionCode)\n    );\n  }\n\n  var generate = visitor.build({\n    grammar: function(node) {\n      arrays.each(node.rules, generate);\n\n      node.consts = consts;\n    },\n\n    rule: function(node) {\n      node.bytecode = generate(node.expression, {\n        sp:     -1,    // stack pointer\n        env:    { },   // mapping of label names to stack positions\n        action: null   // action nodes pass themselves to children here\n      });\n    },\n\n    named: function(node, context) {\n      var nameIndex = addConst(\n        'peg$otherExpectation(\"' + js.stringEscape(node.name) + '\")'\n      );\n\n      /*\n       * The code generated below is slightly suboptimal because |FAIL| pushes\n       * to the stack, so we need to stick a |POP| in front of it. We lack a\n       * dedicated instruction that would just report the failure and not touch\n       * the stack.\n       */\n      return buildSequence(\n        [op.SILENT_FAILS_ON],\n        generate(node.expression, context),\n        [op.SILENT_FAILS_OFF],\n        buildCondition([op.IF_ERROR], [op.FAIL, nameIndex], [])\n      );\n    },\n\n    choice: function(node, context) {\n      function buildAlternativesCode(alternatives, context) {\n        return buildSequence(\n          generate(alternatives[0], {\n            sp:     context.sp,\n            env:    objects.clone(context.env),\n            action: null\n          }),\n          alternatives.length > 1\n            ? buildCondition(\n                [op.IF_ERROR],\n                buildSequence(\n                  [op.POP],\n                  buildAlternativesCode(alternatives.slice(1), context)\n                ),\n                []\n              )\n            : []\n        );\n      }\n\n      return buildAlternativesCode(node.alternatives, context);\n    },\n\n    action: function(node, context) {\n      var env            = objects.clone(context.env),\n          emitCall       = node.expression.type !== \"sequence\"\n                        || node.expression.elements.length === 0,\n          expressionCode = generate(node.expression, {\n            sp:     context.sp + (emitCall ? 1 : 0),\n            env:    env,\n            action: node\n          }),\n          functionIndex  = addFunctionConst(objects.keys(env), node.code);\n\n      return emitCall\n        ? buildSequence(\n            [op.PUSH_CURR_POS],\n            expressionCode,\n            buildCondition(\n              [op.IF_NOT_ERROR],\n              buildSequence(\n                [op.LOAD_SAVED_POS, 1],\n                buildCall(functionIndex, 1, env, context.sp + 2)\n              ),\n              []\n            ),\n            [op.NIP]\n          )\n        : expressionCode;\n    },\n\n    sequence: function(node, context) {\n      function buildElementsCode(elements, context) {\n        var processedCount, functionIndex;\n\n        if (elements.length > 0) {\n          processedCount = node.elements.length - elements.slice(1).length;\n\n          return buildSequence(\n            generate(elements[0], {\n              sp:     context.sp,\n              env:    context.env,\n              action: null\n            }),\n            buildCondition(\n              [op.IF_NOT_ERROR],\n              buildElementsCode(elements.slice(1), {\n                sp:     context.sp + 1,\n                env:    context.env,\n                action: context.action\n              }),\n              buildSequence(\n                processedCount > 1 ? [op.POP_N, processedCount] : [op.POP],\n                [op.POP_CURR_POS],\n                [op.PUSH_FAILED]\n              )\n            )\n          );\n        } else {\n          if (context.action) {\n            functionIndex = addFunctionConst(\n              objects.keys(context.env),\n              context.action.code\n            );\n\n            return buildSequence(\n              [op.LOAD_SAVED_POS, node.elements.length],\n              buildCall(\n                functionIndex,\n                node.elements.length,\n                context.env,\n                context.sp\n              ),\n              [op.NIP]\n            );\n          } else {\n            return buildSequence([op.WRAP, node.elements.length], [op.NIP]);\n          }\n        }\n      }\n\n      return buildSequence(\n        [op.PUSH_CURR_POS],\n        buildElementsCode(node.elements, {\n          sp:     context.sp + 1,\n          env:    context.env,\n          action: context.action\n        })\n      );\n    },\n\n    labeled: function(node, context) {\n      var env = objects.clone(context.env);\n\n      context.env[node.label] = context.sp + 1;\n\n      return generate(node.expression, {\n        sp:     context.sp,\n        env:    env,\n        action: null\n      });\n    },\n\n    text: function(node, context) {\n      return buildSequence(\n        [op.PUSH_CURR_POS],\n        generate(node.expression, {\n          sp:     context.sp + 1,\n          env:    objects.clone(context.env),\n          action: null\n        }),\n        buildCondition(\n          [op.IF_NOT_ERROR],\n          buildSequence([op.POP], [op.TEXT]),\n          [op.NIP]\n        )\n      );\n    },\n\n    simple_and: function(node, context) {\n      return buildSimplePredicate(node.expression, false, context);\n    },\n\n    simple_not: function(node, context) {\n      return buildSimplePredicate(node.expression, true, context);\n    },\n\n    optional: function(node, context) {\n      return buildSequence(\n        generate(node.expression, {\n          sp:     context.sp,\n          env:    objects.clone(context.env),\n          action: null\n        }),\n        buildCondition(\n          [op.IF_ERROR],\n          buildSequence([op.POP], [op.PUSH_NULL]),\n          []\n        )\n      );\n    },\n\n    zero_or_more: function(node, context) {\n      var expressionCode = generate(node.expression, {\n            sp:     context.sp + 1,\n            env:    objects.clone(context.env),\n            action: null\n          });\n\n      return buildSequence(\n        [op.PUSH_EMPTY_ARRAY],\n        expressionCode,\n        buildAppendLoop(expressionCode),\n        [op.POP]\n      );\n    },\n\n    one_or_more: function(node, context) {\n      var expressionCode = generate(node.expression, {\n            sp:     context.sp + 1,\n            env:    objects.clone(context.env),\n            action: null\n          });\n\n      return buildSequence(\n        [op.PUSH_EMPTY_ARRAY],\n        expressionCode,\n        buildCondition(\n          [op.IF_NOT_ERROR],\n          buildSequence(buildAppendLoop(expressionCode), [op.POP]),\n          buildSequence([op.POP], [op.POP], [op.PUSH_FAILED])\n        )\n      );\n    },\n\n    group: function(node, context) {\n      return generate(node.expression, {\n        sp:     context.sp,\n        env:    objects.clone(context.env),\n        action: null\n      });\n    },\n\n    semantic_and: function(node, context) {\n      return buildSemanticPredicate(node.code, false, context);\n    },\n\n    semantic_not: function(node, context) {\n      return buildSemanticPredicate(node.code, true, context);\n    },\n\n    rule_ref: function(node) {\n      return [op.RULE, asts.indexOfRule(ast, node.name)];\n    },\n\n    literal: function(node) {\n      var stringIndex, expectedIndex;\n\n      if (node.value.length > 0) {\n        stringIndex = addConst('\"'\n          + js.stringEscape(\n              node.ignoreCase ? node.value.toLowerCase() : node.value\n            )\n          + '\"'\n        );\n        expectedIndex = addConst(\n          'peg$literalExpectation('\n            + '\"' + js.stringEscape(node.value) + '\", '\n            + node.ignoreCase\n            + ')'\n        );\n\n        /*\n         * For case-sensitive strings the value must match the beginning of the\n         * remaining input exactly. As a result, we can use |ACCEPT_STRING| and\n         * save one |substr| call that would be needed if we used |ACCEPT_N|.\n         */\n        return buildCondition(\n          node.ignoreCase\n            ? [op.MATCH_STRING_IC, stringIndex]\n            : [op.MATCH_STRING, stringIndex],\n          node.ignoreCase\n            ? [op.ACCEPT_N, node.value.length]\n            : [op.ACCEPT_STRING, stringIndex],\n          [op.FAIL, expectedIndex]\n        );\n      } else {\n        stringIndex = addConst('\"\"');\n\n        return [op.PUSH, stringIndex];\n      }\n    },\n\n    \"class\": function(node) {\n      var regexp, parts, regexpIndex, expectedIndex;\n\n      if (node.parts.length > 0) {\n        regexp = '/^['\n          + (node.inverted ? '^' : '')\n          + arrays.map(node.parts, function(part) {\n              return part instanceof Array\n                ? js.regexpClassEscape(part[0])\n                  + '-'\n                  + js.regexpClassEscape(part[1])\n                : js.regexpClassEscape(part);\n            }).join('')\n          + ']/' + (node.ignoreCase ? 'i' : '');\n      } else {\n        /*\n         * IE considers regexps /[]/ and /[^]/ as syntactically invalid, so we\n         * translate them into equivalents it can handle.\n         */\n        regexp = node.inverted ? '/^[\\\\S\\\\s]/' : '/^(?!)/';\n      }\n\n      parts = '['\n        + arrays.map(node.parts, function(part) {\n            return part instanceof Array\n              ? '[\"' + js.stringEscape(part[0]) + '\", \"' + js.stringEscape(part[1]) + '\"]'\n              : '\"' + js.stringEscape(part) + '\"';\n          }).join(', ')\n        + ']';\n\n      regexpIndex   = addConst(regexp);\n      expectedIndex = addConst(\n        'peg$classExpectation('\n          + parts + ', '\n          + node.inverted + ', '\n          + node.ignoreCase\n          + ')'\n      );\n\n      return buildCondition(\n        [op.MATCH_REGEXP, regexpIndex],\n        [op.ACCEPT_N, 1],\n        [op.FAIL, expectedIndex]\n      );\n    },\n\n    any: function() {\n      var expectedIndex = addConst('peg$anyExpectation()');\n\n      return buildCondition(\n        [op.MATCH_ANY],\n        [op.ACCEPT_N, 1],\n        [op.FAIL, expectedIndex]\n      );\n    }\n  });\n\n  generate(ast);\n}\n\nmodule.exports = generateBytecode;\n","\"use strict\";\n\nvar arrays  = require(\"../../utils/arrays\"),\n    objects = require(\"../../utils/objects\"),\n    asts    = require(\"../asts\"),\n    op      = require(\"../opcodes\"),\n    js      = require(\"../js\");\n\n/* Generates parser JavaScript code. */\nfunction generateJS(ast, options) {\n  /* These only indent non-empty lines to avoid trailing whitespace. */\n  function indent2(code)  { return code.replace(/^(.+)$/gm, '  $1');         }\n  function indent6(code)  { return code.replace(/^(.+)$/gm, '      $1');     }\n  function indent10(code) { return code.replace(/^(.+)$/gm, '          $1'); }\n\n  function generateTables() {\n    if (options.optimize === \"size\") {\n      return [\n        'peg$consts = [',\n           indent2(ast.consts.join(',\\n')),\n        '],',\n        '',\n        'peg$bytecode = [',\n           indent2(arrays.map(ast.rules, function(rule) {\n             return 'peg$decode(\"'\n                   + js.stringEscape(arrays.map(\n                       rule.bytecode,\n                       function(b) { return String.fromCharCode(b + 32); }\n                     ).join(''))\n                   + '\")';\n           }).join(',\\n')),\n        '],'\n      ].join('\\n');\n    } else {\n      return arrays.map(\n        ast.consts,\n        function(c, i) { return 'peg$c' + i + ' = ' + c + ','; }\n      ).join('\\n');\n    }\n  }\n\n  function generateRuleHeader(ruleNameCode, ruleIndexCode) {\n    var parts = [];\n\n    parts.push('');\n\n    if (options.trace) {\n      parts.push([\n        'peg$tracer.trace({',\n        '  type:     \"rule.enter\",',\n        '  rule:     ' + ruleNameCode + ',',\n        '  location: peg$computeLocation(startPos, startPos)',\n        '});',\n        ''\n      ].join('\\n'));\n    }\n\n    if (options.cache) {\n      parts.push([\n        'var key    = peg$currPos * ' + ast.rules.length + ' + ' + ruleIndexCode + ',',\n        '    cached = peg$resultsCache[key];',\n        '',\n        'if (cached) {',\n        '  peg$currPos = cached.nextPos;',\n        ''\n      ].join('\\n'));\n\n      if (options.trace) {\n        parts.push([\n          'if (cached.result !== peg$FAILED) {',\n          '  peg$tracer.trace({',\n          '    type:   \"rule.match\",',\n          '    rule:   ' + ruleNameCode + ',',\n          '    result: cached.result,',\n          '    location: peg$computeLocation(startPos, peg$currPos)',\n          '  });',\n          '} else {',\n          '  peg$tracer.trace({',\n          '    type: \"rule.fail\",',\n          '    rule: ' + ruleNameCode + ',',\n          '    location: peg$computeLocation(startPos, startPos)',\n          '  });',\n          '}',\n          ''\n        ].join('\\n'));\n      }\n\n      parts.push([\n        '  return cached.result;',\n        '}',\n        ''\n      ].join('\\n'));\n    }\n\n    return parts.join('\\n');\n  }\n\n  function generateRuleFooter(ruleNameCode, resultCode) {\n    var parts = [];\n\n    if (options.cache) {\n      parts.push([\n        '',\n        'peg$resultsCache[key] = { nextPos: peg$currPos, result: ' + resultCode + ' };'\n      ].join('\\n'));\n    }\n\n    if (options.trace) {\n      parts.push([\n          '',\n          'if (' + resultCode + ' !== peg$FAILED) {',\n          '  peg$tracer.trace({',\n          '    type:   \"rule.match\",',\n          '    rule:   ' + ruleNameCode + ',',\n          '    result: ' + resultCode + ',',\n          '    location: peg$computeLocation(startPos, peg$currPos)',\n          '  });',\n          '} else {',\n          '  peg$tracer.trace({',\n          '    type: \"rule.fail\",',\n          '    rule: ' + ruleNameCode + ',',\n          '    location: peg$computeLocation(startPos, startPos)',\n          '  });',\n          '}'\n      ].join('\\n'));\n    }\n\n    parts.push([\n      '',\n      'return ' + resultCode + ';'\n    ].join('\\n'));\n\n    return parts.join('\\n');\n  }\n\n  function generateInterpreter() {\n    var parts = [];\n\n    function generateCondition(cond, argsLength) {\n      var baseLength      = argsLength + 3,\n          thenLengthCode = 'bc[ip + ' + (baseLength - 2) + ']',\n          elseLengthCode = 'bc[ip + ' + (baseLength - 1) + ']';\n\n      return [\n        'ends.push(end);',\n        'ips.push(ip + ' + baseLength + ' + ' + thenLengthCode + ' + ' + elseLengthCode + ');',\n        '',\n        'if (' + cond + ') {',\n        '  end = ip + ' + baseLength + ' + ' + thenLengthCode + ';',\n        '  ip += ' + baseLength + ';',\n        '} else {',\n        '  end = ip + ' + baseLength + ' + ' + thenLengthCode + ' + ' + elseLengthCode + ';',\n        '  ip += ' + baseLength + ' + ' + thenLengthCode + ';',\n        '}',\n        '',\n        'break;'\n      ].join('\\n');\n    }\n\n    function generateLoop(cond) {\n      var baseLength     = 2,\n          bodyLengthCode = 'bc[ip + ' + (baseLength - 1) + ']';\n\n      return [\n        'if (' + cond + ') {',\n        '  ends.push(end);',\n        '  ips.push(ip);',\n        '',\n        '  end = ip + ' + baseLength + ' + ' + bodyLengthCode + ';',\n        '  ip += ' + baseLength + ';',\n        '} else {',\n        '  ip += ' + baseLength + ' + ' + bodyLengthCode + ';',\n        '}',\n        '',\n        'break;'\n      ].join('\\n');\n    }\n\n    function generateCall() {\n      var baseLength       = 4,\n          paramsLengthCode = 'bc[ip + ' + (baseLength - 1) + ']';\n\n      return [\n        'params = bc.slice(ip + ' + baseLength + ', ip + ' + baseLength + ' + ' + paramsLengthCode + ');',\n        'for (i = 0; i < ' + paramsLengthCode + '; i++) {',\n        '  params[i] = stack[stack.length - 1 - params[i]];',\n        '}',\n        '',\n        'stack.splice(',\n        '  stack.length - bc[ip + 2],',\n        '  bc[ip + 2],',\n        '  peg$consts[bc[ip + 1]].apply(null, params)',\n        ');',\n        '',\n        'ip += ' + baseLength + ' + ' + paramsLengthCode + ';',\n        'break;'\n      ].join('\\n');\n    }\n\n    parts.push([\n      'function peg$decode(s) {',\n      '  var bc = new Array(s.length), i;',\n      '',\n      '  for (i = 0; i < s.length; i++) {',\n      '    bc[i] = s.charCodeAt(i) - 32;',\n      '  }',\n      '',\n      '  return bc;',\n      '}',\n      '',\n      'function peg$parseRule(index) {'\n    ].join('\\n'));\n\n    if (options.trace) {\n      parts.push([\n        '  var bc       = peg$bytecode[index],',\n        '      ip       = 0,',\n        '      ips      = [],',\n        '      end      = bc.length,',\n        '      ends     = [],',\n        '      stack    = [],',\n        '      startPos = peg$currPos,',\n        '      params, i;'\n      ].join('\\n'));\n    } else {\n      parts.push([\n        '  var bc    = peg$bytecode[index],',\n        '      ip    = 0,',\n        '      ips   = [],',\n        '      end   = bc.length,',\n        '      ends  = [],',\n        '      stack = [],',\n        '      params, i;'\n      ].join('\\n'));\n    }\n\n    parts.push(indent2(generateRuleHeader('peg$ruleNames[index]', 'index')));\n\n    parts.push([\n      /*\n       * The point of the outer loop and the |ips| & |ends| stacks is to avoid\n       * recursive calls for interpreting parts of bytecode. In other words, we\n       * implement the |interpret| operation of the abstract machine without\n       * function calls. Such calls would likely slow the parser down and more\n       * importantly cause stack overflows for complex grammars.\n       */\n      '  while (true) {',\n      '    while (ip < end) {',\n      '      switch (bc[ip]) {',\n      '        case ' + op.PUSH + ':',               // PUSH c\n      '          stack.push(peg$consts[bc[ip + 1]]);',\n      '          ip += 2;',\n      '          break;',\n      '',\n      '        case ' + op.PUSH_UNDEFINED + ':',     // PUSH_UNDEFINED\n      '          stack.push(void 0);',\n      '          ip++;',\n      '          break;',\n      '',\n      '        case ' + op.PUSH_NULL + ':',          // PUSH_NULL\n      '          stack.push(null);',\n      '          ip++;',\n      '          break;',\n      '',\n      '        case ' + op.PUSH_FAILED + ':',        // PUSH_FAILED\n      '          stack.push(peg$FAILED);',\n      '          ip++;',\n      '          break;',\n      '',\n      '        case ' + op.PUSH_EMPTY_ARRAY + ':',   // PUSH_EMPTY_ARRAY\n      '          stack.push([]);',\n      '          ip++;',\n      '          break;',\n      '',\n      '        case ' + op.PUSH_CURR_POS + ':',      // PUSH_CURR_POS\n      '          stack.push(peg$currPos);',\n      '          ip++;',\n      '          break;',\n      '',\n      '        case ' + op.POP + ':',                // POP\n      '          stack.pop();',\n      '          ip++;',\n      '          break;',\n      '',\n      '        case ' + op.POP_CURR_POS + ':',       // POP_CURR_POS\n      '          peg$currPos = stack.pop();',\n      '          ip++;',\n      '          break;',\n      '',\n      '        case ' + op.POP_N + ':',              // POP_N n\n      '          stack.length -= bc[ip + 1];',\n      '          ip += 2;',\n      '          break;',\n      '',\n      '        case ' + op.NIP + ':',                // NIP\n      '          stack.splice(-2, 1);',\n      '          ip++;',\n      '          break;',\n      '',\n      '        case ' + op.APPEND + ':',             // APPEND\n      '          stack[stack.length - 2].push(stack.pop());',\n      '          ip++;',\n      '          break;',\n      '',\n      '        case ' + op.WRAP + ':',               // WRAP n\n      '          stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));',\n      '          ip += 2;',\n      '          break;',\n      '',\n      '        case ' + op.TEXT + ':',               // TEXT\n      '          stack.push(input.substring(stack.pop(), peg$currPos));',\n      '          ip++;',\n      '          break;',\n      '',\n      '        case ' + op.IF + ':',                 // IF t, f\n                 indent10(generateCondition('stack[stack.length - 1]', 0)),\n      '',\n      '        case ' + op.IF_ERROR + ':',           // IF_ERROR t, f\n                 indent10(generateCondition(\n                   'stack[stack.length - 1] === peg$FAILED',\n                   0\n                 )),\n      '',\n      '        case ' + op.IF_NOT_ERROR + ':',       // IF_NOT_ERROR t, f\n                 indent10(\n                   generateCondition('stack[stack.length - 1] !== peg$FAILED',\n                   0\n                 )),\n      '',\n      '        case ' + op.WHILE_NOT_ERROR + ':',    // WHILE_NOT_ERROR b\n                 indent10(generateLoop('stack[stack.length - 1] !== peg$FAILED')),\n      '',\n      '        case ' + op.MATCH_ANY + ':',          // MATCH_ANY a, f, ...\n                 indent10(generateCondition('input.length > peg$currPos', 0)),\n      '',\n      '        case ' + op.MATCH_STRING + ':',       // MATCH_STRING s, a, f, ...\n                 indent10(generateCondition(\n                   'input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]',\n                   1\n                 )),\n      '',\n      '        case ' + op.MATCH_STRING_IC + ':',    // MATCH_STRING_IC s, a, f, ...\n                 indent10(generateCondition(\n                   'input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]',\n                   1\n                 )),\n      '',\n      '        case ' + op.MATCH_REGEXP + ':',       // MATCH_REGEXP r, a, f, ...\n                 indent10(generateCondition(\n                   'peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))',\n                   1\n                 )),\n      '',\n      '        case ' + op.ACCEPT_N + ':',           // ACCEPT_N n\n      '          stack.push(input.substr(peg$currPos, bc[ip + 1]));',\n      '          peg$currPos += bc[ip + 1];',\n      '          ip += 2;',\n      '          break;',\n      '',\n      '        case ' + op.ACCEPT_STRING + ':',      // ACCEPT_STRING s\n      '          stack.push(peg$consts[bc[ip + 1]]);',\n      '          peg$currPos += peg$consts[bc[ip + 1]].length;',\n      '          ip += 2;',\n      '          break;',\n      '',\n      '        case ' + op.FAIL + ':',               // FAIL e\n      '          stack.push(peg$FAILED);',\n      '          if (peg$silentFails === 0) {',\n      '            peg$fail(peg$consts[bc[ip + 1]]);',\n      '          }',\n      '          ip += 2;',\n      '          break;',\n      '',\n      '        case ' + op.LOAD_SAVED_POS + ':',     // LOAD_SAVED_POS p\n      '          peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];',\n      '          ip += 2;',\n      '          break;',\n      '',\n      '        case ' + op.UPDATE_SAVED_POS + ':',   // UPDATE_SAVED_POS\n      '          peg$savedPos = peg$currPos;',\n      '          ip++;',\n      '          break;',\n      '',\n      '        case ' + op.CALL + ':',               // CALL f, n, pc, p1, p2, ..., pN\n                 indent10(generateCall()),\n      '',\n      '        case ' + op.RULE + ':',               // RULE r\n      '          stack.push(peg$parseRule(bc[ip + 1]));',\n      '          ip += 2;',\n      '          break;',\n      '',\n      '        case ' + op.SILENT_FAILS_ON + ':',    // SILENT_FAILS_ON\n      '          peg$silentFails++;',\n      '          ip++;',\n      '          break;',\n      '',\n      '        case ' + op.SILENT_FAILS_OFF + ':',   // SILENT_FAILS_OFF\n      '          peg$silentFails--;',\n      '          ip++;',\n      '          break;',\n      '',\n      '        default:',\n      '          throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");',\n      '      }',\n      '    }',\n      '',\n      '    if (ends.length > 0) {',\n      '      end = ends.pop();',\n      '      ip = ips.pop();',\n      '    } else {',\n      '      break;',\n      '    }',\n      '  }'\n    ].join('\\n'));\n\n    parts.push(indent2(generateRuleFooter('peg$ruleNames[index]', 'stack[0]')));\n    parts.push('}');\n\n    return parts.join('\\n');\n  }\n\n  function generateRuleFunction(rule) {\n    var parts = [], code;\n\n    function c(i) { return \"peg$c\" + i; } // |consts[i]| of the abstract machine\n    function s(i) { return \"s\"     + i; } // |stack[i]| of the abstract machine\n\n    var stack = {\n          sp:    -1,\n          maxSp: -1,\n\n          push: function(exprCode) {\n            var code = s(++this.sp) + ' = ' + exprCode + ';';\n\n            if (this.sp > this.maxSp) { this.maxSp = this.sp; }\n\n            return code;\n          },\n\n          pop: function(n) {\n            var values;\n\n            if (n === void 0) {\n              return s(this.sp--);\n            } else {\n              values = arrays.map(arrays.range(this.sp - n + 1, this.sp + 1), s);\n              this.sp -= n;\n\n              return values;\n            }\n          },\n\n          top: function() {\n            return s(this.sp);\n          },\n\n          index: function(i) {\n            return s(this.sp - i);\n          }\n        };\n\n    function compile(bc) {\n      var ip    = 0,\n          end   = bc.length,\n          parts = [],\n          value;\n\n      function compileCondition(cond, argCount) {\n        var baseLength = argCount + 3,\n            thenLength = bc[ip + baseLength - 2],\n            elseLength = bc[ip + baseLength - 1],\n            baseSp     = stack.sp,\n            thenCode, elseCode, thenSp, elseSp;\n\n        ip += baseLength;\n        thenCode = compile(bc.slice(ip, ip + thenLength));\n        thenSp = stack.sp;\n        ip += thenLength;\n\n        if (elseLength > 0) {\n          stack.sp = baseSp;\n          elseCode = compile(bc.slice(ip, ip + elseLength));\n          elseSp = stack.sp;\n          ip += elseLength;\n\n          if (thenSp !== elseSp) {\n            throw new Error(\n              \"Branches of a condition must move the stack pointer in the same way.\"\n            );\n          }\n        }\n\n        parts.push('if (' + cond + ') {');\n        parts.push(indent2(thenCode));\n        if (elseLength > 0) {\n          parts.push('} else {');\n          parts.push(indent2(elseCode));\n        }\n        parts.push('}');\n      }\n\n      function compileLoop(cond) {\n        var baseLength = 2,\n            bodyLength = bc[ip + baseLength - 1],\n            baseSp     = stack.sp,\n            bodyCode, bodySp;\n\n        ip += baseLength;\n        bodyCode = compile(bc.slice(ip, ip + bodyLength));\n        bodySp = stack.sp;\n        ip += bodyLength;\n\n        if (bodySp !== baseSp) {\n          throw new Error(\"Body of a loop can't move the stack pointer.\");\n        }\n\n        parts.push('while (' + cond + ') {');\n        parts.push(indent2(bodyCode));\n        parts.push('}');\n      }\n\n      function compileCall() {\n        var baseLength   = 4,\n            paramsLength = bc[ip + baseLength - 1];\n\n        var value = c(bc[ip + 1]) + '('\n              + arrays.map(\n                  bc.slice(ip + baseLength, ip + baseLength + paramsLength),\n                  function(p) { return stack.index(p); }\n                ).join(', ')\n              + ')';\n        stack.pop(bc[ip + 2]);\n        parts.push(stack.push(value));\n        ip += baseLength + paramsLength;\n      }\n\n      while (ip < end) {\n        switch (bc[ip]) {\n          case op.PUSH:               // PUSH c\n            parts.push(stack.push(c(bc[ip + 1])));\n            ip += 2;\n            break;\n\n          case op.PUSH_CURR_POS:      // PUSH_CURR_POS\n            parts.push(stack.push('peg$currPos'));\n            ip++;\n            break;\n\n          case op.PUSH_UNDEFINED:      // PUSH_UNDEFINED\n            parts.push(stack.push('void 0'));\n            ip++;\n            break;\n\n          case op.PUSH_NULL:          // PUSH_NULL\n            parts.push(stack.push('null'));\n            ip++;\n            break;\n\n          case op.PUSH_FAILED:        // PUSH_FAILED\n            parts.push(stack.push('peg$FAILED'));\n            ip++;\n            break;\n\n          case op.PUSH_EMPTY_ARRAY:   // PUSH_EMPTY_ARRAY\n            parts.push(stack.push('[]'));\n            ip++;\n            break;\n\n          case op.POP:                // POP\n            stack.pop();\n            ip++;\n            break;\n\n          case op.POP_CURR_POS:       // POP_CURR_POS\n            parts.push('peg$currPos = ' + stack.pop() + ';');\n            ip++;\n            break;\n\n          case op.POP_N:              // POP_N n\n            stack.pop(bc[ip + 1]);\n            ip += 2;\n            break;\n\n          case op.NIP:                // NIP\n            value = stack.pop();\n            stack.pop();\n            parts.push(stack.push(value));\n            ip++;\n            break;\n\n          case op.APPEND:             // APPEND\n            value = stack.pop();\n            parts.push(stack.top() + '.push(' + value + ');');\n            ip++;\n            break;\n\n          case op.WRAP:               // WRAP n\n            parts.push(\n              stack.push('[' + stack.pop(bc[ip + 1]).join(', ') + ']')\n            );\n            ip += 2;\n            break;\n\n          case op.TEXT:               // TEXT\n            parts.push(\n              stack.push('input.substring(' + stack.pop() + ', peg$currPos)')\n            );\n            ip++;\n            break;\n\n          case op.IF:                 // IF t, f\n            compileCondition(stack.top(), 0);\n            break;\n\n          case op.IF_ERROR:           // IF_ERROR t, f\n            compileCondition(stack.top() + ' === peg$FAILED', 0);\n            break;\n\n          case op.IF_NOT_ERROR:       // IF_NOT_ERROR t, f\n            compileCondition(stack.top() + ' !== peg$FAILED', 0);\n            break;\n\n          case op.WHILE_NOT_ERROR:    // WHILE_NOT_ERROR b\n            compileLoop(stack.top() + ' !== peg$FAILED', 0);\n            break;\n\n          case op.MATCH_ANY:          // MATCH_ANY a, f, ...\n            compileCondition('input.length > peg$currPos', 0);\n            break;\n\n          case op.MATCH_STRING:       // MATCH_STRING s, a, f, ...\n            compileCondition(\n              eval(ast.consts[bc[ip + 1]]).length > 1\n                ? 'input.substr(peg$currPos, '\n                    + eval(ast.consts[bc[ip + 1]]).length\n                    + ') === '\n                    + c(bc[ip + 1])\n                : 'input.charCodeAt(peg$currPos) === '\n                    + eval(ast.consts[bc[ip + 1]]).charCodeAt(0),\n              1\n            );\n            break;\n\n          case op.MATCH_STRING_IC:    // MATCH_STRING_IC s, a, f, ...\n            compileCondition(\n              'input.substr(peg$currPos, '\n                + eval(ast.consts[bc[ip + 1]]).length\n                + ').toLowerCase() === '\n                + c(bc[ip + 1]),\n              1\n            );\n            break;\n\n          case op.MATCH_REGEXP:       // MATCH_REGEXP r, a, f, ...\n            compileCondition(\n              c(bc[ip + 1]) + '.test(input.charAt(peg$currPos))',\n              1\n            );\n            break;\n\n          case op.ACCEPT_N:           // ACCEPT_N n\n            parts.push(stack.push(\n              bc[ip + 1] > 1\n                ? 'input.substr(peg$currPos, ' + bc[ip + 1] + ')'\n                : 'input.charAt(peg$currPos)'\n            ));\n            parts.push(\n              bc[ip + 1] > 1\n                ? 'peg$currPos += ' + bc[ip + 1] + ';'\n                : 'peg$currPos++;'\n            );\n            ip += 2;\n            break;\n\n          case op.ACCEPT_STRING:      // ACCEPT_STRING s\n            parts.push(stack.push(c(bc[ip + 1])));\n            parts.push(\n              eval(ast.consts[bc[ip + 1]]).length > 1\n                ? 'peg$currPos += ' + eval(ast.consts[bc[ip + 1]]).length + ';'\n                : 'peg$currPos++;'\n            );\n            ip += 2;\n            break;\n\n          case op.FAIL:               // FAIL e\n            parts.push(stack.push('peg$FAILED'));\n            parts.push('if (peg$silentFails === 0) { peg$fail(' + c(bc[ip + 1]) + '); }');\n            ip += 2;\n            break;\n\n          case op.LOAD_SAVED_POS:     // LOAD_SAVED_POS p\n            parts.push('peg$savedPos = ' + stack.index(bc[ip + 1]) + ';');\n            ip += 2;\n            break;\n\n          case op.UPDATE_SAVED_POS:   // UPDATE_SAVED_POS\n            parts.push('peg$savedPos = peg$currPos;');\n            ip++;\n            break;\n\n          case op.CALL:               // CALL f, n, pc, p1, p2, ..., pN\n            compileCall();\n            break;\n\n          case op.RULE:               // RULE r\n            parts.push(stack.push(\"peg$parse\" + ast.rules[bc[ip + 1]].name + \"()\"));\n            ip += 2;\n            break;\n\n          case op.SILENT_FAILS_ON:    // SILENT_FAILS_ON\n            parts.push('peg$silentFails++;');\n            ip++;\n            break;\n\n          case op.SILENT_FAILS_OFF:   // SILENT_FAILS_OFF\n            parts.push('peg$silentFails--;');\n            ip++;\n            break;\n\n          default:\n            throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");\n        }\n      }\n\n      return parts.join('\\n');\n    }\n\n    code = compile(rule.bytecode);\n\n    parts.push('function peg$parse' + rule.name + '() {');\n\n    if (options.trace) {\n      parts.push([\n        '  var ' + arrays.map(arrays.range(0, stack.maxSp + 1), s).join(', ') + ',',\n        '      startPos = peg$currPos;'\n      ].join('\\n'));\n    } else {\n      parts.push(\n        '  var ' + arrays.map(arrays.range(0, stack.maxSp + 1), s).join(', ') + ';'\n      );\n    }\n\n    parts.push(indent2(generateRuleHeader(\n      '\"' + js.stringEscape(rule.name) + '\"',\n      asts.indexOfRule(ast, rule.name)\n    )));\n    parts.push(indent2(code));\n    parts.push(indent2(generateRuleFooter(\n      '\"' + js.stringEscape(rule.name) + '\"',\n      s(0)\n    )));\n\n    parts.push('}');\n\n    return parts.join('\\n');\n  }\n\n  function generateToplevel() {\n    var parts = [],\n        startRuleIndices,   startRuleIndex,\n        startRuleFunctions, startRuleFunction,\n        ruleNames;\n\n    parts.push([\n      'function peg$subclass(child, parent) {',\n      '  function ctor() { this.constructor = child; }',\n      '  ctor.prototype = parent.prototype;',\n      '  child.prototype = new ctor();',\n      '}',\n      '',\n      'function peg$SyntaxError(message, expected, found, location) {',\n      '  this.message  = message;',\n      '  this.expected = expected;',\n      '  this.found    = found;',\n      '  this.location = location;',\n      '  this.name     = \"SyntaxError\";',\n      '',\n      '  if (typeof Error.captureStackTrace === \"function\") {',\n      '    Error.captureStackTrace(this, peg$SyntaxError);',\n      '  }',\n      '}',\n      '',\n      'peg$subclass(peg$SyntaxError, Error);',\n      '',\n      'peg$SyntaxError.buildMessage = function(expected, found) {',\n      '  var DESCRIBE_EXPECTATION_FNS = {',\n      '        literal: function(expectation) {',\n      '          return \"\\\\\\\"\" + literalEscape(expectation.text) + \"\\\\\\\"\";',\n      '        },',\n      '',\n      '        \"class\": function(expectation) {',\n      '          var escapedParts = \"\",',\n      '              i;',\n      '',\n      '          for (i = 0; i < expectation.parts.length; i++) {',\n      '            escapedParts += expectation.parts[i] instanceof Array',\n      '              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])',\n      '              : classEscape(expectation.parts[i]);',\n      '          }',\n      '',\n      '          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";',\n      '        },',\n      '',\n      '        any: function(expectation) {',\n      '          return \"any character\";',\n      '        },',\n      '',\n      '        end: function(expectation) {',\n      '          return \"end of input\";',\n      '        },',\n      '',\n      '        other: function(expectation) {',\n      '          return expectation.description;',\n      '        }',\n      '      };',\n      '',\n      '  function hex(ch) {',\n      '    return ch.charCodeAt(0).toString(16).toUpperCase();',\n      '  }',\n      '',\n      '  function literalEscape(s) {',\n      '    return s',\n      '      .replace(/\\\\\\\\/g, \\'\\\\\\\\\\\\\\\\\\')',   // backslash\n      '      .replace(/\"/g,  \\'\\\\\\\\\"\\')',        // closing double quote\n      '      .replace(/\\\\0/g, \\'\\\\\\\\0\\')',       // null\n      '      .replace(/\\\\t/g, \\'\\\\\\\\t\\')',       // horizontal tab\n      '      .replace(/\\\\n/g, \\'\\\\\\\\n\\')',       // line feed\n      '      .replace(/\\\\r/g, \\'\\\\\\\\r\\')',       // carriage return\n      '      .replace(/[\\\\x00-\\\\x0F]/g,          function(ch) { return \\'\\\\\\\\x0\\' + hex(ch); })',\n      '      .replace(/[\\\\x10-\\\\x1F\\\\x7F-\\\\x9F]/g, function(ch) { return \\'\\\\\\\\x\\'  + hex(ch); });',\n      '  }',\n      '',\n      '  function classEscape(s) {',\n      '    return s',\n      '      .replace(/\\\\\\\\/g, \\'\\\\\\\\\\\\\\\\\\')',   // backslash\n      '      .replace(/\\\\]/g, \\'\\\\\\\\]\\')',       // closing bracket\n      '      .replace(/\\\\^/g, \\'\\\\\\\\^\\')',       // caret\n      '      .replace(/-/g,  \\'\\\\\\\\-\\')',        // dash\n      '      .replace(/\\\\0/g, \\'\\\\\\\\0\\')',       // null\n      '      .replace(/\\\\t/g, \\'\\\\\\\\t\\')',       // horizontal tab\n      '      .replace(/\\\\n/g, \\'\\\\\\\\n\\')',       // line feed\n      '      .replace(/\\\\r/g, \\'\\\\\\\\r\\')',       // carriage return\n      '      .replace(/[\\\\x00-\\\\x0F]/g,          function(ch) { return \\'\\\\\\\\x0\\' + hex(ch); })',\n      '      .replace(/[\\\\x10-\\\\x1F\\\\x7F-\\\\x9F]/g, function(ch) { return \\'\\\\\\\\x\\'  + hex(ch); });',\n      '  }',\n      '',\n      '  function describeExpectation(expectation) {',\n      '    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);',\n      '  }',\n      '',\n      '  function describeExpected(expected) {',\n      '    var descriptions = new Array(expected.length),',\n      '        i, j;',\n      '',\n      '    for (i = 0; i < expected.length; i++) {',\n      '      descriptions[i] = describeExpectation(expected[i]);',\n      '    }',\n      '',\n      '    descriptions.sort();',\n      '',\n      '    if (descriptions.length > 0) {',\n      '      for (i = 1, j = 1; i < descriptions.length; i++) {',\n      '        if (descriptions[i - 1] !== descriptions[i]) {',\n      '          descriptions[j] = descriptions[i];',\n      '          j++;',\n      '        }',\n      '      }',\n      '      descriptions.length = j;',\n      '    }',\n      '',\n      '    switch (descriptions.length) {',\n      '      case 1:',\n      '        return descriptions[0];',\n      '',\n      '      case 2:',\n      '        return descriptions[0] + \" or \" + descriptions[1];',\n      '',\n      '      default:',\n      '        return descriptions.slice(0, -1).join(\", \")',\n      '          + \", or \"',\n      '          + descriptions[descriptions.length - 1];',\n      '    }',\n      '  }',\n      '',\n      '  function describeFound(found) {',\n      '    return found ? \"\\\\\"\" + literalEscape(found) + \"\\\\\"\" : \"end of input\";',\n      '  }',\n      '',\n      '  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";',\n      '};',\n      ''\n    ].join('\\n'));\n\n    if (options.trace) {\n      parts.push([\n        'function peg$DefaultTracer() {',\n        '  this.indentLevel = 0;',\n        '}',\n        '',\n        'peg$DefaultTracer.prototype.trace = function(event) {',\n        '  var that = this;',\n        '',\n        '  function log(event) {',\n        '    function repeat(string, n) {',\n        '       var result = \"\", i;',\n        '',\n        '       for (i = 0; i < n; i++) {',\n        '         result += string;',\n        '       }',\n        '',\n        '       return result;',\n        '    }',\n        '',\n        '    function pad(string, length) {',\n        '      return string + repeat(\" \", length - string.length);',\n        '    }',\n        '',\n        '    if (typeof console === \"object\") {',   // IE 8-10\n        '      console.log(',\n        '        event.location.start.line + \":\" + event.location.start.column + \"-\"',\n        '          + event.location.end.line + \":\" + event.location.end.column + \" \"',\n        '          + pad(event.type, 10) + \" \"',\n        '          + repeat(\"  \", that.indentLevel) + event.rule',\n        '      );',\n        '    }',\n        '  }',\n        '',\n        '  switch (event.type) {',\n        '    case \"rule.enter\":',\n        '      log(event);',\n        '      this.indentLevel++;',\n        '      break;',\n        '',\n        '    case \"rule.match\":',\n        '      this.indentLevel--;',\n        '      log(event);',\n        '      break;',\n        '',\n        '    case \"rule.fail\":',\n        '      this.indentLevel--;',\n        '      log(event);',\n        '      break;',\n        '',\n        '    default:',\n        '      throw new Error(\"Invalid event type: \" + event.type + \".\");',\n        '  }',\n        '};',\n        ''\n      ].join('\\n'));\n    }\n\n    parts.push([\n      'function peg$parse(input, options) {',\n      '  options = options !== void 0 ? options : {};',\n      '',\n      '  var peg$FAILED = {},',\n      ''\n    ].join('\\n'));\n\n    if (options.optimize === \"size\") {\n      startRuleIndices = '{ '\n                       + arrays.map(\n                           options.allowedStartRules,\n                           function(r) { return r + ': ' + asts.indexOfRule(ast, r); }\n                         ).join(', ')\n                       + ' }';\n      startRuleIndex = asts.indexOfRule(ast, options.allowedStartRules[0]);\n\n      parts.push([\n        '      peg$startRuleIndices = ' + startRuleIndices + ',',\n        '      peg$startRuleIndex   = ' + startRuleIndex + ','\n      ].join('\\n'));\n    } else {\n      startRuleFunctions = '{ '\n                       + arrays.map(\n                           options.allowedStartRules,\n                           function(r) { return r + ': peg$parse' + r; }\n                         ).join(', ')\n                       + ' }';\n      startRuleFunction = 'peg$parse' + options.allowedStartRules[0];\n\n      parts.push([\n        '      peg$startRuleFunctions = ' + startRuleFunctions + ',',\n        '      peg$startRuleFunction  = ' + startRuleFunction + ','\n      ].join('\\n'));\n    }\n\n    parts.push('');\n\n    parts.push(indent6(generateTables()));\n\n    parts.push([\n      '',\n      '      peg$currPos          = 0,',\n      '      peg$savedPos         = 0,',\n      '      peg$posDetailsCache  = [{ line: 1, column: 1 }],',\n      '      peg$maxFailPos       = 0,',\n      '      peg$maxFailExpected  = [],',\n      '      peg$silentFails      = 0,',   // 0 = report failures, > 0 = silence failures\n      ''\n    ].join('\\n'));\n\n    if (options.cache) {\n      parts.push([\n        '      peg$resultsCache = {},',\n        ''\n      ].join('\\n'));\n    }\n\n    if (options.trace) {\n      if (options.optimize === \"size\") {\n        ruleNames = '['\n                  + arrays.map(\n                      ast.rules,\n                      function(r) { return '\"' + js.stringEscape(r.name) + '\"'; }\n                    ).join(', ')\n                  + ']';\n\n        parts.push([\n          '      peg$ruleNames = ' + ruleNames + ',',\n          ''\n        ].join('\\n'));\n      }\n\n      parts.push([\n        '      peg$tracer = \"tracer\" in options ? options.tracer : new peg$DefaultTracer(),',\n        ''\n      ].join('\\n'));\n    }\n\n    parts.push([\n      '      peg$result;',\n      ''\n    ].join('\\n'));\n\n    if (options.optimize === \"size\") {\n      parts.push([\n        '  if (\"startRule\" in options) {',\n        '    if (!(options.startRule in peg$startRuleIndices)) {',\n        '      throw new Error(\"Can\\'t start parsing from rule \\\\\"\" + options.startRule + \"\\\\\".\");',\n        '    }',\n        '',\n        '    peg$startRuleIndex = peg$startRuleIndices[options.startRule];',\n        '  }'\n      ].join('\\n'));\n    } else {\n      parts.push([\n        '  if (\"startRule\" in options) {',\n        '    if (!(options.startRule in peg$startRuleFunctions)) {',\n        '      throw new Error(\"Can\\'t start parsing from rule \\\\\"\" + options.startRule + \"\\\\\".\");',\n        '    }',\n        '',\n        '    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];',\n        '  }'\n      ].join('\\n'));\n    }\n\n    parts.push([\n      '',\n      '  function text() {',\n      '    return input.substring(peg$savedPos, peg$currPos);',\n      '  }',\n      '',\n      '  function location() {',\n      '    return peg$computeLocation(peg$savedPos, peg$currPos);',\n      '  }',\n      '',\n      '  function expected(description, location) {',\n      '    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)',\n      '',\n      '    throw peg$buildStructuredError(',\n      '      [peg$otherExpectation(description)],',\n      '      input.substring(peg$savedPos, peg$currPos),',\n      '      location',\n      '    );',\n      '  }',\n      '',\n      '  function error(message, location) {',\n      '    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)',\n      '',\n      '    throw peg$buildSimpleError(message, location);',\n      '  }',\n      '',\n      '  function peg$literalExpectation(text, ignoreCase) {',\n      '    return { type: \"literal\", text: text, ignoreCase: ignoreCase };',\n      '  }',\n      '',\n      '  function peg$classExpectation(parts, inverted, ignoreCase) {',\n      '    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };',\n      '  }',\n      '',\n      '  function peg$anyExpectation() {',\n      '    return { type: \"any\" };',\n      '  }',\n      '',\n      '  function peg$endExpectation() {',\n      '    return { type: \"end\" };',\n      '  }',\n      '',\n      '  function peg$otherExpectation(description) {',\n      '    return { type: \"other\", description: description };',\n      '  }',\n      '',\n      '  function peg$computePosDetails(pos) {',\n      '    var details = peg$posDetailsCache[pos], p;',\n      '',\n      '    if (details) {',\n      '      return details;',\n      '    } else {',\n      '      p = pos - 1;',\n      '      while (!peg$posDetailsCache[p]) {',\n      '        p--;',\n      '      }',\n      '',\n      '      details = peg$posDetailsCache[p];',\n      '      details = {',\n      '        line:   details.line,',\n      '        column: details.column',\n      '      };',\n      '',\n      '      while (p < pos) {',\n      '        if (input.charCodeAt(p) === 10) {',\n      '          details.line++;',\n      '          details.column = 1;',\n      '        } else {',\n      '          details.column++;',\n      '        }',\n      '',\n      '        p++;',\n      '      }',\n      '',\n      '      peg$posDetailsCache[pos] = details;',\n      '      return details;',\n      '    }',\n      '  }',\n      '',\n      '  function peg$computeLocation(startPos, endPos) {',\n      '    var startPosDetails = peg$computePosDetails(startPos),',\n      '        endPosDetails   = peg$computePosDetails(endPos);',\n      '',\n      '    return {',\n      '      start: {',\n      '        offset: startPos,',\n      '        line:   startPosDetails.line,',\n      '        column: startPosDetails.column',\n      '      },',\n      '      end: {',\n      '        offset: endPos,',\n      '        line:   endPosDetails.line,',\n      '        column: endPosDetails.column',\n      '      }',\n      '    };',\n      '  }',\n      '',\n      '  function peg$fail(expected) {',\n      '    if (peg$currPos < peg$maxFailPos) { return; }',\n      '',\n      '    if (peg$currPos > peg$maxFailPos) {',\n      '      peg$maxFailPos = peg$currPos;',\n      '      peg$maxFailExpected = [];',\n      '    }',\n      '',\n      '    peg$maxFailExpected.push(expected);',\n      '  }',\n      '',\n      '  function peg$buildSimpleError(message, location) {',\n      '    return new peg$SyntaxError(message, null, null, location);',\n      '  }',\n      '',\n      '  function peg$buildStructuredError(expected, found, location) {',\n      '    return new peg$SyntaxError(',\n      '      peg$SyntaxError.buildMessage(expected, found),',\n      '      expected,',\n      '      found,',\n      '      location',\n      '    );',\n      '  }',\n      ''\n    ].join('\\n'));\n\n    if (options.optimize === \"size\") {\n      parts.push(indent2(generateInterpreter()));\n      parts.push('');\n    } else {\n      arrays.each(ast.rules, function(rule) {\n        parts.push(indent2(generateRuleFunction(rule)));\n        parts.push('');\n      });\n    }\n\n    if (ast.initializer) {\n      parts.push(indent2(ast.initializer.code));\n      parts.push('');\n    }\n\n    if (options.optimize === \"size\") {\n      parts.push('  peg$result = peg$parseRule(peg$startRuleIndex);');\n    } else {\n      parts.push('  peg$result = peg$startRuleFunction();');\n    }\n\n    parts.push([\n      '',\n      '  if (peg$result !== peg$FAILED && peg$currPos === input.length) {',\n      '    return peg$result;',\n      '  } else {',\n      '    if (peg$result !== peg$FAILED && peg$currPos < input.length) {',\n      '      peg$fail(peg$endExpectation());',\n      '    }',\n      '',\n      '    throw peg$buildStructuredError(',\n      '      peg$maxFailExpected,',\n      '      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,',\n      '      peg$maxFailPos < input.length',\n      '        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)',\n      '        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)',\n      '    );',\n      '  }',\n      '}'\n    ].join('\\n'));\n\n    return parts.join('\\n');\n  }\n\n  function generateWrapper(toplevelCode) {\n    function generateGeneratedByComment() {\n      return [\n        '/*',\n        ' * Generated by PEG.js 0.10.0.',\n        ' *',\n        ' * http://pegjs.org/',\n        ' */'\n      ].join('\\n');\n    }\n\n    function generateParserObject() {\n      return options.trace\n        ? [\n            '{',\n            '  SyntaxError:   peg$SyntaxError,',\n            '  DefaultTracer: peg$DefaultTracer,',\n            '  parse:         peg$parse',\n            '}'\n          ].join('\\n')\n        : [\n            '{',\n            '  SyntaxError: peg$SyntaxError,',\n            '  parse:       peg$parse',\n            '}'\n          ].join('\\n');\n    }\n\n    var generators = {\n      bare: function() {\n        return [\n          generateGeneratedByComment(),\n          '(function() {',\n          '  \"use strict\";',\n          '',\n             indent2(toplevelCode),\n          '',\n             indent2('return ' + generateParserObject() + ';'),\n          '})()'\n        ].join('\\n');\n      },\n\n      commonjs: function() {\n        var parts          = [],\n            dependencyVars = objects.keys(options.dependencies),\n            requires       = arrays.map(\n              dependencyVars,\n              function(variable) {\n                return variable\n                  + ' = require(\"'\n                  + js.stringEscape(options.dependencies[variable])\n                  + '\")';\n              }\n            );\n\n        parts.push([\n          generateGeneratedByComment(),\n          '',\n          '\"use strict\";',\n          ''\n        ].join('\\n'));\n\n        if (requires.length > 0) {\n          parts.push('var ' + requires.join(', ') + ';');\n          parts.push('');\n        }\n\n        parts.push([\n          toplevelCode,\n          '',\n          'module.exports = ' + generateParserObject() + ';',\n          ''\n        ].join('\\n'));\n\n        return parts.join('\\n');\n      },\n\n      amd: function() {\n        var dependencyIds  = objects.values(options.dependencies),\n            dependencyVars = objects.keys(options.dependencies),\n            dependencies   = '['\n              + arrays.map(\n                  dependencyIds,\n                  function(id) { return '\"' + js.stringEscape(id) + '\"'; }\n                ).join(', ')\n              + ']',\n            params         = dependencyVars.join(', ');\n\n        return [\n          generateGeneratedByComment(),\n          'define(' + dependencies + ', function(' + params + ') {',\n          '  \"use strict\";',\n          '',\n             indent2(toplevelCode),\n          '',\n             indent2('return ' + generateParserObject() + ';'),\n          '});',\n          ''\n        ].join('\\n');\n      },\n\n      globals: function() {\n        return [\n          generateGeneratedByComment(),\n          '(function(root) {',\n          '  \"use strict\";',\n          '',\n             indent2(toplevelCode),\n          '',\n             indent2('root.' + options.exportVar + ' = ' + generateParserObject() + ';'),\n          '})(this);',\n          ''\n        ].join('\\n');\n      },\n\n      umd: function() {\n        var parts          = [],\n            dependencyIds  = objects.values(options.dependencies),\n            dependencyVars = objects.keys(options.dependencies),\n            dependencies   = '['\n              + arrays.map(\n                  dependencyIds,\n                  function(id) { return '\"' + js.stringEscape(id) + '\"'; }\n                ).join(', ')\n              + ']',\n            requires       = arrays.map(\n              dependencyIds,\n              function(id) { return 'require(\"' + js.stringEscape(id) + '\")'; }\n            ).join(', '),\n            params         = dependencyVars.join(', ');\n\n        parts.push([\n          generateGeneratedByComment(),\n          '(function(root, factory) {',\n          '  if (typeof define === \"function\" && define.amd) {',\n          '    define(' + dependencies + ', factory);',\n          '  } else if (typeof module === \"object\" && module.exports) {',\n          '    module.exports = factory(' + requires + ');'\n        ].join('\\n'));\n\n        if (options.exportVar !== null) {\n          parts.push([\n            '  } else {',\n            '    root.' + options.exportVar + ' = factory();'\n          ].join('\\n'));\n        }\n\n        parts.push([\n          '  }',\n          '})(this, function(' + params + ') {',\n          '  \"use strict\";',\n          '',\n             indent2(toplevelCode),\n          '',\n             indent2('return ' + generateParserObject() + ';'),\n          '});',\n          ''\n        ].join('\\n'));\n\n        return parts.join('\\n');\n      }\n    };\n\n    return generators[options.format]();\n  }\n\n  ast.code = generateWrapper(generateToplevel());\n}\n\nmodule.exports = generateJS;\n","\"use strict\";\n\nvar arrays  = require(\"../utils/arrays\"),\n    objects = require(\"../utils/objects\");\n\nvar compiler = {\n  /*\n   * AST node visitor builder. Useful mainly for plugins which manipulate the\n   * AST.\n   */\n  visitor: require(\"./visitor\"),\n\n  /*\n   * Compiler passes.\n   *\n   * Each pass is a function that is passed the AST. It can perform checks on it\n   * or modify it as needed. If the pass encounters a semantic error, it throws\n   * |peg.GrammarError|.\n   */\n  passes: {\n    check: {\n      reportUndefinedRules:     require(\"./passes/report-undefined-rules\"),\n      reportDuplicateRules:     require(\"./passes/report-duplicate-rules\"),\n      reportDuplicateLabels:    require(\"./passes/report-duplicate-labels\"),\n      reportInfiniteRecursion:  require(\"./passes/report-infinite-recursion\"),\n      reportInfiniteRepetition: require(\"./passes/report-infinite-repetition\")\n    },\n    transform: {\n      removeProxyRules:         require(\"./passes/remove-proxy-rules\")\n    },\n    generate: {\n      generateBytecode:         require(\"./passes/generate-bytecode\"),\n      generateJS:               require(\"./passes/generate-js\")\n    }\n  },\n\n  /*\n   * Generates a parser from a specified grammar AST. Throws |peg.GrammarError|\n   * if the AST contains a semantic error. Note that not all errors are detected\n   * during the generation and some may protrude to the generated parser and\n   * cause its malfunction.\n   */\n  compile: function(ast, passes, options) {\n    options = options !== void 0 ? options : {};\n\n    var stage;\n\n    options = objects.clone(options);\n    objects.defaults(options, {\n      allowedStartRules: [ast.rules[0].name],\n      cache:             false,\n      dependencies:      {},\n      exportVar:         null,\n      format:            \"bare\",\n      optimize:          \"speed\",\n      output:            \"parser\",\n      trace:             false\n    });\n\n    for (stage in passes) {\n      if (passes.hasOwnProperty(stage)) {\n        arrays.each(passes[stage], function(p) { p(ast, options); });\n      }\n    }\n\n    switch (options.output) {\n      case \"parser\": return eval(ast.code);\n      case \"source\": return ast.code;\n    }\n  }\n};\n\nmodule.exports = compiler;\n","\"use strict\";\n\nvar arrays  = require(\"./utils/arrays\"),\n    objects = require(\"./utils/objects\");\n\nvar peg = {\n  /* PEG.js version (uses semantic versioning). */\n  VERSION: \"0.10.0\",\n\n  GrammarError: require(\"./grammar-error\"),\n  parser:       require(\"./parser\"),\n  compiler:     require(\"./compiler\"),\n\n  /*\n   * Generates a parser from a specified grammar and returns it.\n   *\n   * The grammar must be a string in the format described by the metagramar in\n   * the parser.pegjs file.\n   *\n   * Throws |peg.parser.SyntaxError| if the grammar contains a syntax error or\n   * |peg.GrammarError| if it contains a semantic error. Note that not all\n   * errors are detected during the generation and some may protrude to the\n   * generated parser and cause its malfunction.\n   */\n  generate: function(grammar, options) {\n    options = options !== void 0 ? options : {};\n\n    function convertPasses(passes) {\n      var converted = {}, stage;\n\n      for (stage in passes) {\n        if (passes.hasOwnProperty(stage)) {\n          converted[stage] = objects.values(passes[stage]);\n        }\n      }\n\n      return converted;\n    }\n\n    options = objects.clone(options);\n\n    var plugins = \"plugins\" in options ? options.plugins : [],\n        config  = {\n          parser: peg.parser,\n          passes: convertPasses(peg.compiler.passes)\n        };\n\n    arrays.each(plugins, function(p) { p.use(config, options); });\n\n    return peg.compiler.compile(\n      config.parser.parse(grammar),\n      config.passes,\n      options\n    );\n  }\n};\n\nmodule.exports = peg;\n","import {Node, SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {CompileContext} from \"../context\";\nimport {Declarator} from \"../declaration/declarator\";\nimport {SpecifierList} from \"../declaration/specifier_list\";\n\nexport class TypeName extends Node {\n    public specifierQualifiers: SpecifierList;\n    public declarator: Declarator | null;\n\n    constructor(location: SourceLocation, specifierQualifiers: SpecifierList, declarator: Declarator | null) {\n        super(location);\n        this.specifierQualifiers = specifierQualifiers;\n        this.declarator = declarator;\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        const baseType = this.specifierQualifiers.getType(ctx);\n        return this.declarator ? this.declarator.getType(ctx, baseType) : baseType;\n    }\n\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {ClassDirective, SourceLocation} from \"../../common/node\";\nimport {ClassType} from \"../../type/class_type\";\nimport {TypeName} from \"../class/type_name\";\nimport {CompileContext} from \"../context\";\nimport {Identifier} from \"../expression/identifier\";\nimport {FunctionLookUpResult} from \"../scope\";\n\nexport class UsingStatement extends ClassDirective {\n    public name: Identifier;\n    public type: TypeName | null;\n\n    constructor(location: SourceLocation, name: Identifier, type: TypeName | null) {\n        super(location);\n        this.name = name;\n        this.type = type;\n    }\n\n    public codegen(ctx: CompileContext): void {\n        if (this.type) {\n            const type = this.type.deduceType(ctx);\n            ctx.scopeManager.define(this.name.getPlainName(ctx), type, this);\n        } else {\n            const item = ctx.scopeManager.lookup(this.name.getLookupName(ctx));\n            if ( item === null ) {\n                throw new SyntaxError(`undefine symbol ${this.name.name}`, this);\n            }\n            if ( item instanceof FunctionLookUpResult ) {\n                item.functions.map((func) => ctx.scopeManager.define(func.shortName.split(\"@\")[0], func, this));\n            } else {\n                ctx.scopeManager.define(this.name.getPlainName(ctx), item, this);\n            }\n        }\n    }\n\n    public declare(ctx: CompileContext, classType: ClassType): void {\n        this.codegen(ctx);\n    }\n\n}\n","import {Directive, SourceLocation} from \"../../common/node\";\nimport {AccessControl} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {TypeName} from \"../class/type_name\";\nimport {CompileContext} from \"../context\";\nimport {Identifier} from \"../expression/identifier\";\nimport {UsingStatement} from \"../statement/using_statement\";\nimport {InitDeclarator} from \"./init_declartor\";\nimport {SpecifierList} from \"./specifier_list\";\n\nexport class Declaration extends Directive {\n    public specifiers: SpecifierList;\n    public initDeclarators: InitDeclarator[];\n\n    constructor(location: SourceLocation, specifiers: SpecifierList, initDeclarators: InitDeclarator[]) {\n        super(location);\n        this.specifiers = specifiers;\n        this.initDeclarators = initDeclarators;\n    }\n\n    public declare(ctx: CompileContext, classType: ClassType): void {\n        const type = this.specifiers.getType(ctx);\n        const isTypedef = this.specifiers.specifiers.includes(\"typedef\");\n        for (const declarator of this.initDeclarators) {\n            if (isTypedef) {\n                const name = declarator.declarator.getNameRequired().getPlainName(ctx);\n                new UsingStatement(this.location, Identifier.fromString(this.location, name),\n                    new TypeName(this.location, this.specifiers, declarator.declarator)).codegen(ctx);\n            } else {\n                declarator.declareInClass(ctx, {\n                    type,\n                    isLibCall: this.specifiers.specifiers.includes(\"__libcall\"),\n                    isExtern: this.specifiers.specifiers.includes(\"extern\"),\n                    isStatic: this.specifiers.specifiers.includes(\"static\"),\n                    accessControl: classType.accessControl,\n                }, classType);\n            }\n        }\n    }\n\n    public codegen(ctx: CompileContext): void {\n        const type = this.specifiers.getType(ctx);\n        const isTypedef = this.specifiers.specifiers.includes(\"typedef\");\n        for (const declarator of this.initDeclarators) {\n            if (isTypedef) {\n                const name = declarator.declarator.getNameRequired().getPlainName(ctx);\n                new UsingStatement(this.location, Identifier.fromString(this.location, name),\n                    new TypeName(this.location, this.specifiers, declarator.declarator)).codegen(ctx);\n            } else {\n                const isInClass = ctx.scopeManager.currentContext.scope.classType !== null;\n                declarator.declare(ctx, {\n                    type,\n                    isLibCall: this.specifiers.specifiers.includes(\"__libcall\"),\n                    isExtern: this.specifiers.specifiers.includes(\"extern\"),\n                    isStatic: this.specifiers.specifiers.includes(\"static\"),\n                    accessControl: isInClass ? AccessControl.Unknown : AccessControl.Public,\n                });\n            }\n        }\n    }\n\n    public getTypedefName(): string[] {\n        if (this.specifiers.specifiers.includes(\"typedef\")) {\n            return this.initDeclarators.map((decl) => decl.declarator.getNameRequired())\n                .map((x) => x.getLastID().name);\n        } else {\n            return [];\n        }\n    }\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {Node, SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {CompileContext} from \"../context\";\nimport {Identifier} from \"../expression/identifier\";\nexport abstract class Declarator extends Node {\n    public declarator: Declarator | null;\n\n    constructor(location: SourceLocation, declarator: Declarator | null) {\n        super(location);\n        this.declarator = declarator;\n    }\n\n    public abstract getType(ctx: CompileContext, baseType: Type): Type;\n\n    public getName(): Identifier | null {\n        return this.declarator ? this.declarator.getName() : null;\n    }\n\n    public getNameRequired(): Identifier {\n        const name = this.getName();\n        if (!name) {\n            throw new SyntaxError(`the name is missing, no name`, this);\n        }\n        return name;\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {FunctionType} from \"../../type/function_type\";\nimport {CompileContext} from \"../context\";\nimport {ParameterList} from \"../function/parameter_list\";\nimport {Declarator} from \"./declarator\";\n\nexport class FunctionDeclarator extends Declarator {\n\n    public static getFunctionDeclarator(decl: Declarator): FunctionDeclarator | null {\n        return decl instanceof FunctionDeclarator ? decl :\n            (decl.declarator ? this.getFunctionDeclarator(decl.declarator) : null);\n    }\n    public parameters: ParameterList;\n\n    constructor(location: SourceLocation, declarator: Declarator, parameters: ParameterList) {\n        super(location, declarator);\n        this.parameters = parameters;\n    }\n\n    public getType(ctx: CompileContext, baseType: Type): Type {\n        const result = new FunctionType(\n            baseType,\n            this.parameters.parameters.map((x) => x.getType(ctx)),\n            this.parameters.variableArguments);\n        return this.declarator ? this.declarator.getType(ctx, result) : result;\n    }\n\n}\n","import {InternalError, SyntaxError} from \"../../common/error\";\nimport {ClassDirective, SourceLocation} from \"../../common/node\";\nimport {FunctionEntity, OverloadSymbol} from \"../../common/symbol\";\nimport {AccessControl} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {PointerType} from \"../../type/compound_type\";\nimport {CppFunctionType, FunctionType} from \"../../type/function_type\";\nimport {CompileContext} from \"../context\";\nimport {Declarator} from \"../declaration/declarator\";\nimport {FunctionDeclarator} from \"../declaration/function_declarator\";\nimport {SpecifierList} from \"../declaration/specifier_list\";\nimport {FunctionLookUpResult, Scope} from \"../scope\";\nimport {CompoundStatement} from \"../statement/compound_statement\";\nimport {declareFunction, defineFunction, FunctionConfig} from \"./function\";\n\nexport class FunctionDefinition extends ClassDirective {\n    public specifiers: SpecifierList;\n    public declarator: Declarator;\n    public body: CompoundStatement;\n    public parameterNames: string[];\n\n    constructor(location: SourceLocation, specifiers: SpecifierList,\n                declarator: Declarator, body: CompoundStatement) {\n        super(location);\n        this.specifiers = specifiers;\n        this.declarator = declarator;\n        this.body = body;\n        this.parameterNames = [];\n    }\n\n    public deduceType(ctx: CompileContext): FunctionType {\n        const type = this.declarator.getType(ctx, this.specifiers.getType(ctx));\n        if (!(type instanceof FunctionType)) {\n            throw new InternalError(`this is not a function`);\n        }\n        return type;\n    }\n\n    public getFunctionConfig(ctx: CompileContext): FunctionConfig {\n        const name = this.declarator.getNameRequired();\n        const functionDeclarator = FunctionDeclarator.getFunctionDeclarator(this.declarator);\n        const functionType = this.deduceType(ctx);\n        if (!functionDeclarator) {\n            throw new InternalError(`function is not a functionDeclarator`);\n        }\n        const parameterNames = functionDeclarator.parameters.getNameList(ctx);\n        const parameterInits = functionDeclarator.parameters.getInitList(ctx);\n        if (new Set<string>(parameterNames).size !== parameterNames.length) {\n            throw new SyntaxError(`some of the name of parameters are repeative`, this);\n        }\n        return {\n            name: name.getLookupName(ctx),\n            functionType,\n            parameterNames,\n            parameterInits,\n            accessControl: AccessControl.Public,\n            isLibCall: this.specifiers.specifiers.includes(\"__libcall\"),\n        };\n    }\n\n    public getMemberFunctionConfig(ctx: CompileContext, classType: ClassType): FunctionConfig {\n        if (this.specifiers.specifiers.includes(\"static\")) {\n            return this.getFunctionConfig(ctx);\n        }\n        const name = this.declarator.getNameRequired();\n        const functionType = this.deduceType(ctx);\n        const functionDeclarator = FunctionDeclarator.getFunctionDeclarator(this.declarator);\n        if (!functionDeclarator) {\n            throw new InternalError(`function is not a functionDeclarator`);\n        }\n        functionType.parameterTypes = [new PointerType(classType), ...functionType.parameterTypes];\n        functionType.cppFunctionType = CppFunctionType.MemberFunction;\n        functionType.referenceClass = classType;\n        const parameterNames = [\"this\", ...functionDeclarator.parameters.getNameList(ctx)];\n        const parameterInits = [null, ...functionDeclarator.parameters.getInitList(ctx)];\n        const isVirtual = this.specifiers.specifiers.includes(\"virtual\");\n        const fullName = name.getFullName(ctx) + \"@\" + functionType.toMangledName();\n        const vcallSigature = name.getShortName(ctx) + \"@\" + functionType.parameterTypes\n            .slice(1).map((x) => x.toString()).join(\",\");\n        if (isVirtual) {\n            functionType.isVirtual = true;\n            classType.registerVFunction(ctx, vcallSigature, fullName);\n        } else {\n            if (classType.getVCallInfo(vcallSigature) !== null) {\n                functionType.isVirtual = true;\n                classType.registerVFunction(ctx, vcallSigature, fullName);\n            }\n        }\n        if (new Set<string>(parameterNames).size !== parameterNames.length) {\n            throw new SyntaxError(`some of the name of parameters are repeative`, this);\n        }\n        return {\n            name: name.getLookupName(ctx),\n            functionType,\n            parameterNames,\n            parameterInits,\n            accessControl: classType.accessControl,\n            isLibCall: this.specifiers.specifiers.includes(\"__libcall\"),\n        };\n    }\n\n    public declare(ctx: CompileContext, classType: ClassType) {\n        const config = this.getMemberFunctionConfig(ctx, classType);\n        declareFunction(ctx, config, this);\n    }\n\n    public codegen(ctx: CompileContext): void {\n        const name = this.declarator.getNameRequired();\n        const fullName = name.getFullName(ctx);\n        const scope = ctx.scopeManager.root.getScopeOfLookupName(fullName);\n        if (!scope) {\n            throw new SyntaxError(`unresolvedname ${fullName}`, this);\n        }\n        if (scope.classType === null) {\n            const config = this.getFunctionConfig(ctx);\n            const oldItem = ctx.scopeManager.getOldOverloadSymbol(\n                fullName + \"@\" + config.functionType.toMangledName());\n            const activeScopes = (oldItem && oldItem instanceof FunctionEntity)\n                ? oldItem.declareActiveScopes : [];\n            defineFunction(ctx, config, this.body.body, activeScopes, this);\n        } else {\n            const classType = scope.classType;\n            const config = this.getMemberFunctionConfig(ctx, classType);\n            const oldItem = ctx.scopeManager.getOldOverloadSymbol(\n                fullName + \"@\" + config.functionType.toMangledName());\n            const activeScopes = (oldItem && oldItem instanceof FunctionEntity)\n                ? oldItem.declareActiveScopes : [];\n            config.accessControl = AccessControl.Unknown;\n            defineFunction(ctx, config, this.body.body, activeScopes, this);\n        }\n    }\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {Node, SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {CompileContext} from \"../context\";\nimport {ParameterDeclaration} from \"./parameter_declaration\";\n\nexport class ParameterList extends Node {\n    public parameters: ParameterDeclaration[];\n    public variableArguments: boolean;\n\n    constructor(location: SourceLocation, parameters: ParameterDeclaration[] = [], variableArguments: boolean = false) {\n        super(location);\n        this.parameters = parameters;\n        this.variableArguments = variableArguments;\n\n        // check legal or not of init\n        let ix = this.parameters.length - 1;\n        for (; ix >= 0; ix--) {\n            if (this.parameters[ix].init === null) { break; }\n            if (this.variableArguments) {\n                throw new SyntaxError(`var argument function could not apply default param`, this);\n            }\n        }\n        ix --;\n        for (; ix >= 0; ix--) {\n            if (this.parameters[ix].init !== null) {\n                throw new SyntaxError(`illegal init expression`, this);\n            }\n        }\n    }\n\n    public getTypeList(ctx: CompileContext): Type[] {\n        return this.parameters.map((x) => x.getType(ctx));\n    }\n\n    public getNameList(ctx: CompileContext): string[] {\n        const result = [] as string[];\n        for (const item of this.parameters) {\n            if (!item.declarator) {\n                throw new SyntaxError(`the parameter list is not complete, some name is missing`, this);\n            }\n            const id = item.declarator.getNameRequired();\n            result.push(id.getPlainName(ctx));\n        }\n        return result;\n    }\n\n    public getInitList(ctx: CompileContext): Array<string | null> {\n        return this.parameters.map((x) => x.init ?  x.init.evaluate(ctx) : null);\n    }\n}\n","import {Directive, SourceLocation} from \"../../common/node\";\nimport {triggerAllDestructor} from \"../class/destructor\";\nimport {CompileContext} from \"../context\";\nimport {Statement} from \"./statement\";\n\nexport class CompoundStatement extends Statement {\n    public body: Directive[];\n\n    constructor(location: SourceLocation, body: Directive[]) {\n        super(location);\n        this.body = body;\n    }\n\n    public codegen(ctx: CompileContext) {\n        ctx.enterScope();\n        this.body.map((x) => x.codegen(ctx));\n        triggerAllDestructor(ctx, this);\n        ctx.exitScope(this);\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {CompileContext} from \"../context\";\nimport {Expression, recycleExpressionResult} from \"../expression/expression\";\nimport {Statement} from \"./statement\";\n\nexport class ExpressionStatement extends Statement {\n    public expression: Expression;\n\n    constructor(location: SourceLocation, expression: Expression) {\n        super(location);\n        this.expression = expression;\n    }\n\n    public codegen(ctx: CompileContext) {\n        recycleExpressionResult(ctx, this, this.expression.codegen(ctx));\n    }\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {Node, SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {CompileContext} from \"../context\";\nimport {Expression, recycleExpressionResult} from \"../expression/expression\";\nimport {Identifier} from \"../expression/identifier\";\nimport {UnaryExpression} from \"../expression/unary_expression\";\nimport {CallExpression} from \"../function/call_expression\";\n\nexport class ObjectInitializer extends Node {\n    public argus: Expression[];\n\n    constructor(location: SourceLocation, argus: Expression[]) {\n        super(location);\n        this.argus = argus;\n    }\n\n    public initialize(ctx: CompileContext, name: Identifier, type: Type) {\n        if ( !(type instanceof ClassType)) {\n            throw new SyntaxError(`only class type could apply object initializer`, this);\n        }\n        const ctorName = type.fullName + \"::#\" + type.shortName;\n        const callee = Identifier.fromString(this.location, ctorName);\n        const thisPtr = new UnaryExpression(this.location, \"&\",\n            Identifier.fromString(this.location, name.getPlainName(ctx)));\n        const expr = new CallExpression(this.location, callee, [thisPtr, ...this.argus]);\n        recycleExpressionResult(ctx, this, expr.codegen(ctx));\n    }\n}\n","import {InternalError, SyntaxError} from \"../../common/error\";\nimport {ClassDirective, Directive, Node, SourceLocation} from \"../../common/node\";\nimport {FunctionEntity} from \"../../common/symbol\";\nimport {AccessControl} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {PointerType} from \"../../type/compound_type\";\nimport {CppFunctionType, FunctionType} from \"../../type/function_type\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {CompileContext} from \"../context\";\nimport {ObjectInitializer} from \"../declaration/object_initializer\";\nimport {AnonymousCastExpression, AnonymousExpression} from \"../expression/anonymous_expression\";\nimport {AssignmentExpression} from \"../expression/assignment_expression\";\nimport {BinaryExpression} from \"../expression/binary_expression\";\nimport {Expression} from \"../expression/expression\";\nimport {Identifier} from \"../expression/identifier\";\nimport {IntegerConstant} from \"../expression/integer_constant\";\nimport {UnaryExpression} from \"../expression/unary_expression\";\nimport {CallExpression} from \"../function/call_expression\";\nimport {declareFunction, defineFunction, FunctionConfig} from \"../function/function\";\nimport {ParameterList} from \"../function/parameter_list\";\nimport {isFunctionExists} from \"../overload\";\nimport {FunctionLookUpResult} from \"../scope\";\nimport {CompoundStatement} from \"../statement/compound_statement\";\nimport {ExpressionStatement} from \"../statement/expression_statement\";\nimport {Statement} from \"../statement/statement\";\nimport {MemberExpression} from \"./member_expression\";\nimport {WGetAddress, WMemoryLocation} from \"../../wasm\";\n\nexport class ConstructorDeclaration extends ClassDirective {\n    public name: Identifier;\n    public param: ParameterList;\n    public initList: ConstructorInitializeItem[];\n    public body: CompoundStatement | null;\n\n    constructor(location: SourceLocation, name: Identifier, param: ParameterList,\n                initList: ConstructorInitializeItem[], body: CompoundStatement | null) {\n        super(location);\n        this.name = name;\n        this.param = param;\n        this.initList = initList;\n        this.body = body;\n    }\n\n    public getFunctionConfig(ctx: CompileContext, classType: ClassType, accessControl: AccessControl): FunctionConfig {\n        const name = this.name.getPlainName(ctx);\n        if (classType.shortName.split(\"<\")[0] !== name.split(\"<\")[0]) {\n            throw new SyntaxError(`invaild ctor name ${name.split(\"<\")[0]}`, this);\n        }\n        const parameterTypes = [new PointerType(classType), ...this.param.getTypeList(ctx)];\n        const parameterNames = [\"this\", ...this.param.getNameList(ctx)];\n        const parameterInits = [null, ...this.param.getInitList(ctx)];\n        const functionType = new FunctionType(PrimitiveTypes.void, parameterTypes, false);\n        functionType.cppFunctionType = CppFunctionType.Constructor;\n        functionType.referenceClass = classType;\n        return {\n            name: \"#\" + classType.shortName,\n            functionType,\n            parameterNames,\n            parameterInits,\n            accessControl,\n            isLibCall: false,\n        };\n    }\n\n    public declare(ctx: CompileContext, classType: ClassType) {\n        const functionConfig = this.getFunctionConfig(ctx, classType, classType.accessControl);\n        declareFunction(ctx, functionConfig, this);\n    }\n\n    public codegen(ctx: CompileContext) {\n        const classType = ctx.scopeManager.currentContext.scope.classType;\n        if (!classType) {\n            throw new SyntaxError(`unresolved name ${this.name.getLookupName(ctx)}`, this);\n        }\n        const functionConfig = this.getFunctionConfig(ctx, classType, AccessControl.Unknown);\n        if (this.body) {\n            const body: Directive[] = [...this.generateStatements(ctx, functionConfig), ...this.body.body];\n            const oldItem = ctx.scopeManager.getOldOverloadSymbol(\n                ctx.scopeManager.currentContext.scope.fullName + \"::\" +\n                functionConfig.name + \"@\" + functionConfig.functionType.toMangledName());\n            const activeScopes = (oldItem && oldItem instanceof FunctionEntity)\n                ? oldItem.declareActiveScopes : [];\n            defineFunction(ctx, functionConfig, body, activeScopes, this);\n        } else {\n            declareFunction(ctx, functionConfig, this);\n        }\n    }\n\n    private generateStatements(ctx: CompileContext, functionConfig: FunctionConfig): Statement[] {\n\n        if (functionConfig.functionType.cppFunctionType !== CppFunctionType.Constructor\n            || functionConfig.functionType.referenceClass === null) {\n            throw new InternalError(`getCtorStmts()`);\n        }\n\n        const classType = functionConfig.functionType.referenceClass;\n        const initList = this.initList;\n        const initMap = new Map<string, Expression>();\n        const baseStatements = [] as Statement[];\n\n        // prepreprocess initList\n        for (const initItem of initList) {\n            if (!initItem.isType) {\n                // base class ctor\n                const key = initItem.key.getPlainName(ctx);\n                if (initItem.value.length !== 1) {\n                    throw new SyntaxError(`the number of argument to init `\n                        + key + ` is incorrect, exepct 1, actual ${initItem.value.length}`, this);\n                }\n                if (classType.getField(key) !== null) {\n                    initMap.set(key, initItem.value[0]);\n                } else {\n                    throw new SyntaxError(`unknown field ${key} in class ${classType.shortName}`, this);\n                }\n            } else {\n                // field init\n                const key = initItem.key.getPlainName(ctx);\n                let hasFound = false;\n                for (let i = 0; i < classType.inheritance.length; i++) {\n                    if (testMatchClassName(\n                        classType.inheritance[i].classType.fullName,\n                        classType.fullName,\n                        key)) {\n                        const baseType = classType.inheritance[i].classType;\n                        const fullName = baseType.fullName + \"::#\" + baseType.shortName;\n                        const nret = ctx.scopeManager.lookup(fullName);\n                        if (nret === null || !(nret instanceof FunctionLookUpResult)) {\n                            throw new SyntaxError(`the base class ${initItem.key.name}` +\n                                ` construtor parameters mismatch`, this);\n                        }\n                        baseStatements[i] = new ExpressionStatement(this.location,\n                            new CallExpression(this.location,\n                                Identifier.fromString(this.location, fullName),\n                                [\n                                    Identifier.fromString(this.location, \"this\"),\n                                    ...initItem.value,\n                                ]));\n                        hasFound = true;\n                    }\n                }\n                if (!hasFound) {\n                    throw new SyntaxError(`class ${initItem.key.name}` +\n                        ` is not base class of ${classType.shortName}`, this);\n                }\n            }\n        }\n\n        // default base class init\n        for (let i = 0; i < classType.inheritance.length; i++) {\n            if ( !baseStatements[i]) {\n                const baseType = classType.inheritance[i].classType;\n                const fullName = baseType.fullName + \"::#\" + baseType.shortName;\n                const nret = ctx.scopeManager.lookup(fullName);\n                if (nret === null || !(nret instanceof FunctionLookUpResult)) {\n                    throw new SyntaxError(`the base class ${baseType.shortName}` +\n                        ` contains not constructor`, this);\n                }\n                baseStatements[i] = new ExpressionStatement(this.location,\n                    new CallExpression(this.location,\n                        Identifier.fromString(this.location, fullName),\n                        [\n                            Identifier.fromString(this.location, \"this\"),\n                        ]));\n            }\n        }\n        const statements = [ ...baseStatements ] as Statement[];\n\n        for (const field of classType.fields) {\n            const left = new MemberExpression(this.location, Identifier.fromString(this.location, \"this\"),\n                true, Identifier.fromString(this.location, field.name));\n            if (initMap.get(field.name) !== undefined) {\n                statements.push(new ExpressionStatement(this.location,\n                    new AssignmentExpression(this.location, \"=\",\n                        left, initMap.get(field.name)!)));\n            } else if (field.initializer !== null) {\n                if (field.initializer instanceof ObjectInitializer) {\n                    if (!(field.type instanceof ClassType)) {\n                        throw new SyntaxError(`only class type could apply object initializer`, this);\n                    }\n                    const ctorName = field.type.fullName + \"::#\" + field.type.shortName;\n                    const callee = Identifier.fromString(this.location, ctorName);\n                    const thisPtr = new UnaryExpression(this.location, \"&\",\n                        left);\n                    const expr = new CallExpression(this.location, callee, [thisPtr, ...field.initializer.argus]);\n                    statements.push(new ExpressionStatement(this.location, expr));\n                } else {\n                    statements.push(new ExpressionStatement(this.location,\n                        new AssignmentExpression(this.location, \"=\",\n                            left, field.initializer)));\n                }\n            } else {\n                if (field.type instanceof ClassType) {\n                    const name = classType.fullName + \"#\" + classType.shortName;\n                    if (isFunctionExists(ctx, name, [new PointerType(classType)])) {\n                        statements.push(new ExpressionStatement(this.location,\n                            new CallExpression(this.location,\n                                Identifier.fromString(this.location, name),\n                                [new UnaryExpression(this.location, \"&\", left)],\n                            )));\n                    }\n                }\n            }\n        }\n\n        if (classType.requireVPtr) {\n            const vPtrExpr = new BinaryExpression(this.location, \"+\",\n                new AnonymousCastExpression(this.location,\n                    Identifier.fromString(this.location, \"this\"),\n                    new PointerType(PrimitiveTypes.char)),\n                IntegerConstant.fromNumber(this.location, classType.VPtrOffset));\n            const lhs = new UnaryExpression(this.location, \"*\", new AnonymousCastExpression(\n                this.location, vPtrExpr, new PointerType(PrimitiveTypes.int32)));\n            const vTableAddr = new WGetAddress(WMemoryLocation.DATA, this.location);\n            vTableAddr.offset = classType.vTablePtr;\n            const rhs = new AnonymousExpression(this.location, {\n                type: PrimitiveTypes.int32,\n                expr: vTableAddr,\n                isLeft: false,\n            });\n            statements.push(new ExpressionStatement(this.location, new AssignmentExpression(this.location,\n                \"=\", lhs, rhs,\n            )));\n        }\n\n        return statements;\n    }\n}\n\nexport class ConstructorInitializeItem extends Node {\n    public key: Identifier;\n    public value: Expression[];\n    public isType: boolean;\n\n    constructor(location: SourceLocation, key: Identifier, value: Expression[], isType: boolean) {\n        super(location);\n        this.key = key;\n        this.value = value;\n        this.isType = isType;\n    }\n}\n\nfunction testMatchClassName(fullName: string, classFullName: string, anyName: string) {\n    // to test the name in init list of ctor is one of the base class of this class\n    if (anyName.slice(0, 2) === \"::\") {\n        return fullName === anyName;\n    }\n    const tokens = classFullName.split(\"::\");\n    const scopeName = tokens.slice(0, tokens.length - 1).join(\"::\");\n    return (scopeName + \"::\" + anyName) === fullName;\n}\n","import {InternalError, SyntaxError} from \"../../common/error\";\nimport {ClassDirective, Directive, Node, SourceLocation} from \"../../common/node\";\nimport {FunctionEntity} from \"../../common/symbol\";\nimport {AccessControl} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {PointerType} from \"../../type/compound_type\";\nimport {CppFunctionType, FunctionType} from \"../../type/function_type\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {CompileContext} from \"../context\";\nimport {Identifier} from \"../expression/identifier\";\nimport {UnaryExpression} from \"../expression/unary_expression\";\nimport {CallExpression} from \"../function/call_expression\";\nimport {declareFunction, defineFunction, FunctionConfig} from \"../function/function\";\nimport {isFunctionExists} from \"../overload\";\nimport {CompoundStatement} from \"../statement/compound_statement\";\nimport {ExpressionStatement} from \"../statement/expression_statement\";\nimport {Statement} from \"../statement/statement\";\nimport {MemberExpression} from \"./member_expression\";\n\nexport class DestructorDeclaration extends ClassDirective {\n    public name: Identifier;\n    public body: CompoundStatement | null;\n    public isVirtual: boolean;\n\n    constructor(location: SourceLocation, name: Identifier, body: CompoundStatement | null, isVirtual: boolean) {\n        super(location);\n        this.name = name;\n        this.body = body;\n        this.isVirtual = isVirtual;\n    }\n\n    public getFunctionConfig(ctx: CompileContext, classType: ClassType, accessControl: AccessControl): FunctionConfig {\n        const name = this.name.getPlainName(ctx);\n        if (classType.shortName !== name) {\n            throw new SyntaxError(`invaild dtor name ${name}`, this);\n        }\n        const parameterTypes = [new PointerType(classType)];\n        const parameterNames = [\"this\"];\n        const parameterInits = [null];\n        const functionType = new FunctionType(PrimitiveTypes.void, parameterTypes, false);\n        functionType.cppFunctionType = CppFunctionType.Destructor;\n        functionType.referenceClass = classType;\n        const indexName = \"~\";\n        const fullName = ctx.scopeManager.getFullName(\"~\" + name) + \"@\" + functionType.toMangledName();\n        if (this.isVirtual) {\n            functionType.isVirtual = true;\n            classType.registerVFunction(ctx, indexName, fullName);\n        } else {\n            if (classType.getVCallInfo(indexName) !== null) {\n                functionType.isVirtual = true;\n                classType.registerVFunction(ctx, indexName, fullName);\n            }\n        }\n        return {\n            name: \"~\" + name,\n            functionType,\n            parameterNames,\n            parameterInits,\n            accessControl,\n            isLibCall: false,\n        };\n    }\n\n    public declare(ctx: CompileContext, classType: ClassType) {\n        const functionConfig = this.getFunctionConfig(ctx, classType, classType.accessControl);\n        declareFunction(ctx, functionConfig, this);\n    }\n\n    public codegen(ctx: CompileContext) {\n        const classType = ctx.scopeManager.lookup(this.name.getLookupName(ctx));\n        if (!classType) {\n            throw new SyntaxError(`unresolved name ${this.name.getLookupName(ctx)}`, this);\n        }\n        if (!(classType instanceof ClassType)) {\n            throw new SyntaxError(`name ${this.name.getLookupName(ctx)} is not a class`, this);\n        }\n        const functionConfig = this.getFunctionConfig(ctx, classType, AccessControl.Unknown);\n        if (this.body) {\n            const body: Directive[] = [...this.body.body, ...this.generateStatements(ctx, functionConfig)];\n            const oldItem = ctx.scopeManager.getOldOverloadSymbol(functionConfig.name\n                + \"@\" + functionConfig.functionType.toMangledName());\n            const activeScopes = (oldItem && oldItem instanceof FunctionEntity)\n                ? oldItem.declareActiveScopes : [];\n            defineFunction(ctx, functionConfig, body, activeScopes, this);\n        } else {\n            declareFunction(ctx, functionConfig, this);\n        }\n    }\n\n    private generateStatements(ctx: CompileContext, functionConfig: FunctionConfig): Statement[] {\n\n        if (functionConfig.functionType.cppFunctionType !== CppFunctionType.Destructor\n            || functionConfig.functionType.referenceClass === null) {\n            throw new InternalError(`getDtorStmts()`);\n        }\n\n        const dtorStmts = [] as Statement[];\n\n        const classType = functionConfig.functionType.referenceClass!;\n\n        for (const field of classType.fields) {\n            const left = new MemberExpression(this.location, Identifier.fromString(this.location, \"this\"),\n                true, Identifier.fromString(this.location, field.name));\n            if (field.type instanceof ClassType) {\n                const name = classType.fullName + \"~\" + classType.shortName;\n                if (isFunctionExists(ctx, name, [], classType)) {\n                    dtorStmts.push(new ExpressionStatement(this.location,\n                        new CallExpression(this.location,\n                            Identifier.fromString(this.location, name),\n                            [new UnaryExpression(this.location, \"&\", left)],\n                        )));\n                }\n            }\n        }\n\n        for (const item of classType.inheritance) {\n            const fullName = item.classType.fullName + \"::~\" + item.classType.shortName;\n            const nret = ctx.scopeManager.lookup(fullName);\n            if (nret !== null) {\n                dtorStmts.push(new ExpressionStatement(this.location,\n                    new CallExpression(this.location,\n                        new MemberExpression(this.location,\n                            Identifier.fromString(this.location, \"this\"),\n                            true, Identifier.fromString(this.location, \"~\" + item.classType.shortName)),\n                        [])));\n            }\n        }\n\n        return dtorStmts;\n    }\n\n}\n","import {InternalError, SyntaxError} from \"../../common/error\";\nimport {ClassDirective, Node, SourceLocation} from \"../../common/node\";\nimport {AddressType} from \"../../common/symbol\";\nimport {getAccessControlFromString} from \"../../type\";\nimport {ClassType, Inheritance} from \"../../type/class_type\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {WGetAddress, WGetFunctionAddress, WMemoryLocation} from \"../../wasm\";\nimport {WAddressHolder} from \"../address\";\nimport {CompileContext} from \"../context\";\nimport {Declaration} from \"../declaration/declaration\";\nimport {AnonymousExpression} from \"../expression/anonymous_expression\";\nimport {AssignmentExpression} from \"../expression/assignment_expression\";\nimport {Identifier} from \"../expression/identifier\";\nimport {FunctionDefinition} from \"../function/function_definition\";\nimport {ParameterList} from \"../function/parameter_list\";\nimport {CompoundStatement} from \"../statement/compound_statement\";\nimport {ExpressionStatement} from \"../statement/expression_statement\";\nimport {BaseSpecifier} from \"./base_specifier\";\nimport {ConstructorDeclaration} from \"./constructor_declaration\";\nimport {DestructorDeclaration} from \"./destructor_declaration\";\n\nexport class ClassSpecifier extends Node {\n    public typeName: string; // \"class\" / \"struct\" / \"union\"\n    public identifier: Identifier;\n    public declarations: ClassDirective[] | null;\n    public inherits: BaseSpecifier[];\n\n    constructor(location: SourceLocation, typeName: string,\n                identifier: Identifier,\n                declarations: ClassDirective[] | null,\n                inherits: BaseSpecifier[]) {\n        super(location);\n        this.typeName = typeName;\n        this.identifier = identifier;\n        this.declarations = declarations;\n        this.inherits = inherits;\n    }\n\n    public isVirtual(inheritance: Inheritance[]) {\n        if (this.declarations === null) {\n            throw new InternalError(`public isVirtual(inheritance: Inheritance[]) `);\n        }\n        for (const decl of this.declarations) {\n            if (decl instanceof Declaration || decl instanceof FunctionDefinition) {\n                if (decl.specifiers.specifiers.includes(\"virtual\")) {\n                    return true;\n                }\n            } else if ( decl instanceof DestructorDeclaration) {\n                if (decl.isVirtual) {\n                    return true;\n                }\n            }\n        }\n\n        for (const parent of inheritance) {\n            if (parent.classType.requireVPtr) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public codegen(ctx: CompileContext): ClassType {\n\n        const shortName = this.identifier.getShortName(ctx);\n        const fullName = this.identifier.getFullName(ctx);\n        const lookupName = this.identifier.getLookupName(ctx);\n\n        const oldItem = ctx.scopeManager.lookup(lookupName);\n\n        if (oldItem !== null) {\n            if (this.declarations === null) {\n                if (oldItem instanceof ClassType) {\n                    return oldItem;\n                } else {\n                    throw new SyntaxError(`conflict type of ${lookupName}`, this);\n                }\n            } else {\n                throw new SyntaxError(`redefine of ${lookupName}`, this);\n            }\n        }\n\n        const inheritance = this.inherits.map((x) => x.codegen(ctx));\n\n        const classType = new ClassType(shortName, fullName, ctx.fileName, [],\n            this.typeName === \"union\", inheritance);\n\n        if (this.declarations === null) {\n            // incomplete definition;\n            ctx.scopeManager.declare(lookupName, classType, this);\n            return classType;\n        }\n\n        const isVirtual = this.isVirtual(inheritance);\n        if (isVirtual) {\n            classType.setUpVPtr();\n        }\n\n        // find virtual\n\n        ctx.scopeManager.define(lookupName, classType, this);\n        const activeScopes = ctx.scopeManager.currentContext.activeScopes;\n        ctx.scopeManager.enterScope(fullName);\n        ctx.scopeManager.activeScopes(activeScopes);\n\n        ctx.scopeManager.currentContext.scope.classType = classType;\n        this.declarations.map((x) => x.declare(ctx, classType));\n        classType.initialize();\n        if (isVirtual) {\n            this.generateVTable(ctx, classType);\n        }\n        this.declarations.map((x) => x.codegen(ctx));\n        this.generateDefaultConstructor(ctx);\n        this.generateDefaultDestructor(ctx);\n        ctx.scopeManager.exitScope();\n\n        return classType;\n    }\n\n    public generateVTable(ctx: CompileContext, classType: ClassType) {\n        const vTablesize = 4 * classType.vTable.vFunctions.length;\n        classType.vTablePtr = ctx.memory.allocData(vTablesize);\n        for (let i = 0; i < classType.vTable.vFunctions.length; i++) {\n            const vTablePtrExpr = new WGetAddress(WMemoryLocation.DATA, this.location);\n            vTablePtrExpr.offset = classType.vTablePtr + i * 4;\n            const vTableExpr = new AnonymousExpression(this.location, {\n                type: PrimitiveTypes.int32,\n                expr: new WAddressHolder(vTablePtrExpr, AddressType.RVALUE, this.location),\n                isLeft: true,\n            });\n            const vFuncName = classType.vTable.vFunctions[i].fullName;\n            new ExpressionStatement(this.location, new AssignmentExpression(this.location,\n                \"=\",\n                vTableExpr,\n                new AnonymousExpression(this.location, {\n                    type: PrimitiveTypes.int32,\n                    isLeft: false,\n                    expr: new WGetFunctionAddress(vFuncName, this.location),\n                }))).codegen(ctx);\n        }\n    }\n\n    private generateDefaultConstructor(ctx: CompileContext) {\n        const shortName = this.identifier.getShortName(ctx);\n        const fullName = this.identifier.getFullName(ctx);\n        const item = ctx.scopeManager.lookup(fullName + \"::#\" + shortName);\n        if (item === null) {\n            new ConstructorDeclaration(this.location, this.identifier,\n                new ParameterList(this.location), [],\n                new CompoundStatement(this.location, [])).codegen(ctx);\n        }\n    }\n\n    private generateDefaultDestructor(ctx: CompileContext) {\n        const shortName = this.identifier.getShortName(ctx);\n        const fullName = this.identifier.getFullName(ctx);\n        const item = ctx.scopeManager.lookup(fullName + \"::~\" + shortName);\n        if (item === null) {\n            new DestructorDeclaration(this.location, this.identifier,\n                new CompoundStatement(this.location, []), false).codegen(ctx);\n        }\n    }\n}\n\nexport class AccessControlLabel extends ClassDirective {\n    public label: string;\n\n    constructor(location: SourceLocation, label: string) {\n        super(location);\n        this.label = label;\n    }\n\n    public codegen(ctx: CompileContext): void {\n        return;\n    }\n\n    public declare(ctx: CompileContext, classType: ClassType): void {\n        classType.accessControl = getAccessControlFromString(this.label);\n    }\n\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {Node, SourceLocation} from \"../../common/node\";\nimport {TemplateParameter} from \"../../common/template\";\nimport {Type} from \"../../type\";\nimport {CompileContext} from \"../context\";\nimport {Declarator} from \"../declaration/declarator\";\nimport {SpecifierList} from \"../declaration/specifier_list\";\nimport {AssignmentExpression} from \"../expression/assignment_expression\";\nimport {TemplateParameterDeclaration} from \"../template/type_parameter\";\n\nexport class ParameterDeclaration extends Node implements TemplateParameterDeclaration {\n    public specifiers: SpecifierList;\n    public declarator: Declarator | null;\n    public init: AssignmentExpression | null;\n\n    constructor(location: SourceLocation, specifiers: SpecifierList,\n                declarator: Declarator | null, init: AssignmentExpression | null) {\n        super(location);\n        this.specifiers = specifiers;\n        this.declarator = declarator;\n        this.init = init;\n    }\n\n    public getType(ctx: CompileContext): Type {\n        const baseType = this.specifiers.getType(ctx);\n        if (this.declarator) {\n            return this.declarator.getType(ctx, baseType);\n        } else {\n            return baseType;\n        }\n    }\n\n    public getName(ctx: CompileContext): string {\n        if (!this.declarator) {\n            throw new SyntaxError(`this parameter contains no name`, this);\n        }\n        return this.declarator.getNameRequired().getPlainName(ctx);\n    }\n\n    public getTemplateParameter(ctx: CompileContext): TemplateParameter {\n        if (!this.declarator) {\n            throw new SyntaxError(`unnamed TemplateParameter`, this);\n        }\n        return {\n            name: this.declarator.getNameRequired().getPlainName(ctx),\n            type: this.getType(ctx),\n            init: this.init ? this.init.evaluate(ctx) : null,\n        };\n    }\n}\n","import {Node, SourceLocation} from \"../../common/node\";\nimport {TemplateParameter} from \"../../common/template\";\nimport {TemplateType} from \"../../type/template_type\";\nimport {TypeName} from \"../class/type_name\";\nimport {CompileContext} from \"../context\";\nimport {Identifier} from \"../expression/identifier\";\n\nexport interface TemplateParameterDeclaration {\n    getTemplateParameter(ctx: CompileContext): TemplateParameter;\n}\n\nexport class TypeParameter extends Node implements TemplateParameterDeclaration {\n    public name: Identifier;\n    public init: TypeName | null;\n\n    constructor(location: SourceLocation, name: Identifier, init: TypeName | null) {\n        super(location);\n        this.name = name;\n        this.init = init;\n    }\n\n    public getTemplateParameter(ctx: CompileContext): TemplateParameter {\n        return {\n            name: this.name.getPlainName(ctx),\n            type: TemplateType.instance,\n            init: this.init ? this.init.deduceType(ctx) : null,\n        };\n    }\n}\n","import {InternalError, SyntaxError} from \"../../common/error\";\nimport {ClassDirective, SourceLocation} from \"../../common/node\";\nimport {ClassTemplate, FunctionTemplate} from \"../../common/template\";\nimport {AccessControl} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {UnresolvedFunctionOverloadType} from \"../../type/function_type\";\nimport {TemplateParameterPlaceHolderType} from \"../../type/template_type\";\nimport {ClassSpecifier} from \"../class/class_specifier\";\nimport {CompileContext} from \"../context\";\nimport {FunctionDefinition} from \"../function/function_definition\";\nimport {ParameterDeclaration} from \"../function/parameter_declaration\";\nimport {getShortName} from \"../scope\";\nimport {deduceFunctionTemplateParameters} from \"./template_deduce\";\nimport {TemplateParameterDeclaration, TypeParameter} from \"./type_parameter\";\n\nexport class TemplateDeclaration extends ClassDirective {\n    public decl: ClassSpecifier | FunctionDefinition;\n    public args: TemplateParameterDeclaration[];\n\n    constructor(location: SourceLocation, decl: ClassSpecifier | FunctionDefinition,\n                args: TemplateParameterDeclaration[]) {\n        super(location);\n        this.decl = decl;\n        this.args = args;\n    }\n\n    public getTemplateNames(): string[] {\n        if (this.decl instanceof FunctionDefinition) {\n            return [this.decl.declarator.getNameRequired().getLastID().name];\n        } else {\n            return [this.decl.identifier.getLastID().name];\n        }\n    }\n\n    public declareClassTemplateSpecialization(ctx: CompileContext): void {\n        if (!(this.decl instanceof ClassSpecifier)) {\n            throw new InternalError(`declareFunctionTemplateSpecialization(ctx: CompileContext): void {`);\n        }\n        const name = this.decl.identifier;\n        const lookupName = name.getLookupName(ctx);\n        const classTemplate = ctx.scopeManager.lookup(lookupName);\n        if (!(classTemplate instanceof ClassTemplate)) {\n            throw new SyntaxError(`${name.getLookupName(ctx)} is not a class template`, this);\n        }\n        const args = name.fillInBlank(ctx, name.getLastID().args, classTemplate);\n        const signature = args.map((x) => x.toString).join(\",\");\n        classTemplate.specializationMap.set(signature, this.decl);\n    }\n\n    public declareFunctionTemplateSpecialization(ctx: CompileContext): void {\n        if (!(this.decl instanceof FunctionDefinition)) {\n            throw new InternalError(`declareFunctionTemplateSpecialization(ctx: CompileContext): void {`);\n        }\n        const name = this.decl.declarator.getNameRequired();\n        const lookupType = name.deduceType(ctx);\n        if (!(lookupType instanceof UnresolvedFunctionOverloadType)) {\n            throw new SyntaxError(`${name.getLookupName(ctx)} is not a function template`, this);\n        }\n        const functionType = this.decl.deduceType(ctx);\n        const lookupResult = lookupType.functionLookupResult;\n        for (const item of lookupResult.functions) {\n            if (item instanceof FunctionTemplate) {\n                const params = deduceFunctionTemplateParameters(item, functionType,\n                    lookupResult.templateArguments, false);\n                if (params !== null) {\n                    // match_successful point;\n                    const signature = lookupResult.templateArguments.map((x) => x.toString()).join(\",\");\n                    if (item.specializationMap.has(signature)) {\n                        throw new SyntaxError(\"duplication Specialization\", this);\n                    }\n                    item.specializationMap.set(signature, this.decl);\n                    return;\n                }\n            }\n        }\n        throw new SyntaxError(`no matched function template`, this);\n    }\n\n    public declareFunctionTemplate(ctx: CompileContext): void {\n        if (!(this.decl instanceof FunctionDefinition)) {\n            throw new InternalError(`public declareFunctionTemplate(ctx: CompileContext): void {`);\n        }\n        const savedContext = ctx.scopeManager.currentContext;\n        const classType = savedContext.scope.classType;\n        ctx.scopeManager.enterUnnamedScope(true);\n        this.loadTemplateParameters(ctx);\n        const config = classType === null ?\n            this.decl.getFunctionConfig(ctx) :\n            this.decl.getMemberFunctionConfig(ctx, classType);\n        const realName = getShortName(config.name) + \"@\" + config.functionType.toMangledName();\n        const fullName = ctx.scopeManager.getFullName(realName);\n        const functionTemplate = new FunctionTemplate(\n            realName, fullName, config,\n            this.args.map((x) => x.getTemplateParameter(ctx)),\n            this.decl,\n            savedContext,\n            classType ? classType.accessControl : AccessControl.Public,\n        );\n        ctx.scopeManager.detachCurrentScope();\n        ctx.scopeManager.exitScope();\n        ctx.scopeManager.define(functionTemplate.getIndexName(), functionTemplate, this);\n    }\n\n    public declareClassTemplate(ctx: CompileContext): void {\n        if (!(this.decl instanceof ClassSpecifier)) {\n            throw new InternalError(` public declareClassTemplate(ctx: CompileContext): void `);\n        }\n        const savedContext = ctx.scopeManager.currentContext;\n        const classType = savedContext.scope.classType;\n        ctx.scopeManager.enterUnnamedScope(true);\n        this.loadTemplateParameters(ctx);\n        const realName = this.decl.identifier.getShortName(ctx);\n        const fullName = this.decl.identifier.getFullName(ctx);\n        const classTemplate = new ClassTemplate(\n            realName, fullName, ctx.fileName,\n            this.args.map((x) => x.getTemplateParameter(ctx)),\n            this.decl,\n            savedContext,\n            classType ? classType.accessControl : AccessControl.Public,\n        );\n        ctx.scopeManager.detachCurrentScope();\n        ctx.scopeManager.exitScope();\n        ctx.scopeManager.define(realName, classTemplate, this);\n    }\n\n    public codegen(ctx: CompileContext): void {\n        if (ctx.scopeManager.currentContext.scope.classType) {\n            return; // skip in class\n        }\n        if (this.args.length === 0) {\n            if (this.decl instanceof ClassSpecifier) {\n                this.declareClassTemplateSpecialization(ctx);\n            } else {\n                this.declareFunctionTemplateSpecialization(ctx);\n            }\n            return;\n        } else {\n            if (this.decl instanceof ClassSpecifier) {\n                this.declareClassTemplate(ctx);\n            } else {\n                this.declareFunctionTemplate(ctx);\n            }\n        }\n    }\n\n    public loadTemplateParameters(ctx: CompileContext) {\n        for (let i = 0; i < this.args.length; i++) {\n            const arg = this.args[i];\n            if (arg instanceof ParameterDeclaration) {\n                ctx.scopeManager.define(arg.getName(ctx), arg.getType(ctx), this);\n            } else if (arg instanceof TypeParameter) {\n                ctx.scopeManager.define(arg.name.getPlainName(ctx),\n                    new TemplateParameterPlaceHolderType(i), this);\n            } else {\n                throw new InternalError(`unreachable`);\n            }\n        }\n    }\n\n    public declare(ctx: CompileContext, classType: ClassType): void {\n        if (this.args.length === 0) {\n            if (this.decl instanceof ClassSpecifier) {\n                this.declareClassTemplateSpecialization(ctx);\n            } else {\n                this.declareFunctionTemplateSpecialization(ctx);\n            }\n            return;\n        } else {\n            if (this.decl instanceof ClassSpecifier) {\n                this.declareClassTemplate(ctx);\n            } else {\n                this.declareFunctionTemplate(ctx);\n            }\n        }\n    }\n\n}\n","import {Node, SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {TypeName} from \"../class/type_name\";\nimport {CompileContext} from \"../context\";\nimport {Expression} from \"../expression/expression\";\n\nexport type EvaluatedTemplateArgument = string | Type;\n\nexport class TemplateArgument extends Node {\n    public body: TypeName | Expression;\n\n    constructor(location: SourceLocation, body: TypeName | Expression) {\n        super(location);\n        this.body = body;\n    }\n\n    public evaluate(ctx: CompileContext): EvaluatedTemplateArgument {\n        if (this.body instanceof TypeName) {\n            return this.body.deduceType(ctx);\n        } else {\n            return this.body.evaluate(ctx);\n        }\n    }\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {WBr} from \"../../wasm\";\nimport {CompileContext} from \"../context\";\nimport {Statement} from \"./statement\";\n\nexport class BreakStatement extends Statement {\n    constructor(location: SourceLocation) {\n        super(location);\n    }\n\n    public codegen(ctx: CompileContext): void {\n        if (ctx.currentFuncContext.breakStack.length === 0) {\n            throw new SyntaxError(`break is not in while/do-while/for`, this);\n        }\n        const item = ctx.currentFuncContext.breakStack[ctx.currentFuncContext.breakStack.length - 1];\n        ctx.submitStatement(new WBr(ctx.currentFuncContext.blockLevel - item, this.location));\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {CompileContext} from \"../context\";\nimport {Identifier} from \"../expression/identifier\";\nimport {Declarator} from \"./declarator\";\n\nexport class IdentifierDeclarator extends Declarator {\n    public identifier: Identifier;\n\n    constructor(location: SourceLocation,\n                identifier: Identifier) {\n        super(location, null);\n        this.identifier = identifier;\n    }\n\n    public getType(ctx: CompileContext, baseType: Type): Type {\n        return this.declarator ? this.declarator.getType(ctx, baseType) : baseType;\n    }\n\n    public getName(): Identifier | null {\n        return this.identifier;\n    }\n\n}\n","import {InternalError, SyntaxError} from \"../../common/error\";\nimport {Node, SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {ArrayType} from \"../../type/compound_type\";\nimport {CompileContext} from \"../context\";\nimport {AssignmentExpression} from \"../expression/assignment_expression\";\nimport {Expression} from \"../expression/expression\";\nimport {IntegerConstant} from \"../expression/integer_constant\";\nimport {SubscriptExpression} from \"../expression/subscript_expression\";\nimport {ExpressionStatement} from \"../statement/expression_statement\";\n\nexport class InitializerList extends Node {\n    public items: InitializerListItem[];\n\n    constructor(location: SourceLocation, items: InitializerListItem[]) {\n        super(location);\n        this.items = items;\n    }\n\n    public initialize(ctx: CompileContext, node: Expression, type: Type) {\n        if ( !(type instanceof ArrayType )) {\n            throw new InternalError(\"InitializerList not support\");\n        }\n        this.initializeArray(ctx, node, type);\n    }\n\n    public initializeArray(ctx: CompileContext, node: Expression, type: ArrayType) {\n        for (let i = 0; i < this.items.length; i++) {\n            const item = this.items[i];\n            if ( item.initializer instanceof Expression ) {\n                new ExpressionStatement(this.location,\n                    new AssignmentExpression(this.location, \"=\",\n                        new SubscriptExpression(this.location,\n                            node,\n                            IntegerConstant.fromNumber(this.location, i)),\n                        item.initializer)).codegen(ctx);\n            } else {\n                if (!(type.elementType instanceof ArrayType) ) {\n                    throw new SyntaxError(`illegal inner initializer list`, node);\n                }\n                item.initializer.initializeArray(ctx,\n                    new SubscriptExpression(node.location,\n                        node,\n                        IntegerConstant.fromNumber(node.location, i)), type.elementType);\n            }\n        }\n    }\n}\n\nexport class InitializerListItem extends Node {\n    public initializer: Expression | InitializerList;\n\n    constructor(location: SourceLocation, initializer: Expression | InitializerList) {\n        super(location);\n        this.initializer = initializer;\n    }\n}\n","import {InternalError, SyntaxError} from \"../../common/error\";\nimport {Node, SourceLocation} from \"../../common/node\";\nimport {AddressType, Variable} from \"../../common/symbol\";\nimport {AccessControl, Type} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {ArrayType} from \"../../type/compound_type\";\nimport {FunctionType} from \"../../type/function_type\";\nimport {CompileContext} from \"../context\";\nimport {AssignmentExpression} from \"../expression/assignment_expression\";\nimport {Expression, recycleExpressionResult} from \"../expression/expression\";\nimport {Identifier} from \"../expression/identifier\";\nimport {UnaryExpression} from \"../expression/unary_expression\";\nimport {CallExpression} from \"../function/call_expression\";\nimport {declareFunction} from \"../function/function\";\nimport {Declarator} from \"./declarator\";\nimport {FunctionDeclarator} from \"./function_declarator\";\nimport {InitializerList} from \"./initializer_list\";\nimport {ObjectInitializer} from \"./object_initializer\";\n\nexport interface SpecifierInfo {\n    type: Type;\n    isLibCall: boolean;\n    isExtern: boolean;\n    isStatic: boolean;\n    accessControl: AccessControl;\n}\n\nexport class InitDeclarator extends Node {\n    public declarator: Declarator;\n    public initializer: Expression | ObjectInitializer | InitializerList | null;\n\n    constructor(location: SourceLocation, declarator: Declarator,\n                initializer: Expression | ObjectInitializer | InitializerList | null) {\n        super(location);\n        this.declarator = declarator;\n        this.initializer = initializer;\n    }\n\n    public initialize(ctx: CompileContext, info: SpecifierInfo) {\n        const type = this.declarator.getType(ctx, info.type);\n        const name = this.declarator.getNameRequired();\n        const shortName = name.getShortName(ctx);\n        if (this.initializer != null) {\n            if (info.isExtern) {\n                throw new SyntaxError(`extern vaiable could not have initializer`, this);\n            }\n            if (this.initializer instanceof InitializerList) {\n                this.initializer.initialize(ctx, name, type);\n            } else if (this.initializer instanceof ObjectInitializer) {\n                this.initializer.initialize(ctx, name, type);\n            } else {\n                const expr = new AssignmentExpression(this.location, \"=\",\n                    Identifier.fromString(this.location, shortName),\n                    this.initializer);\n                expr.isInitExpr = true;\n                recycleExpressionResult(ctx, this, expr.codegen(ctx));\n            }\n        } else if (type instanceof ClassType) {\n            const ctorName = type.fullName + \"::#\" + type.shortName;\n            const callee = Identifier.fromString(this.location, ctorName);\n            const thisPtr = new UnaryExpression(this.location, \"&\",\n                Identifier.fromString(this.location, shortName));\n            const expr = new CallExpression(this.location, callee, [thisPtr]);\n            recycleExpressionResult(ctx, this, expr.codegen(ctx));\n        }\n    }\n\n    public createVariable(ctx: CompileContext, info: SpecifierInfo): Variable {\n        const name = this.declarator.getNameRequired();\n        const shortName = name.getShortName(ctx);\n        const fullName = name.getFullName(ctx);\n        const type = this.declarator.getType(ctx, info.type);\n        let storageType = AddressType.STACK;\n        let location: number | string = 0;\n\n        if (ctx.scopeManager.isRoot() || info.isStatic) {\n            if (info.isExtern) {\n                storageType = AddressType.MEMORY_EXTERN;\n                location = fullName;\n            } else if (this.initializer !== null && !(type instanceof ArrayType)) {\n                storageType = AddressType.MEMORY_DATA;\n                location = ctx.memory.allocData(type.length);\n            } else {\n                storageType = AddressType.MEMORY_BSS;\n                location = ctx.memory.allocBss(type.length);\n            }\n        } else {\n            if (info.isExtern) {\n                throw new SyntaxError(\"local variable could not be extern:  \" + name, this);\n            }\n            // TODO:: support static function variable;\n            storageType = AddressType.STACK;\n            location = ctx.memory.allocStack(type.length);\n        }\n        return new Variable(\n            shortName, fullName, ctx.fileName,\n            type, storageType, location, info.accessControl);\n    }\n\n    public declareGlobal(ctx: CompileContext, info: SpecifierInfo, lookupName: string) {\n        const type = this.declarator.getType(ctx, info.type);\n\n        if (type instanceof ClassType && !type.isComplete) {\n            throw new SyntaxError(`cannot instance incomplete type`, this);\n        }\n\n        if (type instanceof FunctionType) {\n            const functionDeclarator = FunctionDeclarator.getFunctionDeclarator(this.declarator);\n            if (!functionDeclarator) {\n                throw new InternalError(`function is not a functionDeclarator`);\n            }\n            declareFunction(ctx, {\n                name: lookupName,\n                functionType: type,\n                parameterNames: [], // functionDeclarator.parameters.getNameList(ctx),\n                parameterInits: [], // functionDeclarator.parameters.getInitList(ctx),\n                accessControl: info.accessControl,\n                isLibCall: info.isLibCall,\n            }, this);\n        } else {\n            if (ctx.scopeManager.currentContext.scope.classType\n                && !info.isStatic) {\n                // if in class, we should skip\n                return;\n            }\n            const newItem = this.createVariable(ctx, info);\n            if (info.isExtern) {\n                ctx.scopeManager.declare(lookupName, newItem, this);\n            } else {\n                ctx.scopeManager.define(lookupName, newItem, this);\n            }\n        }\n    }\n\n    public declare(ctx: CompileContext, info: SpecifierInfo) {\n        const name = this.declarator.getNameRequired();\n        const lookupName = name.getLookupName(ctx);\n        this.declareGlobal(ctx, info, lookupName);\n        if (!ctx.scopeManager.currentContext.scope.classType) {\n            this.initialize(ctx, info);\n        }\n    }\n\n    public declareInClass(ctx: CompileContext, info: SpecifierInfo, classType: ClassType) {\n        const type = this.declarator.getType(ctx, info.type);\n        const name = this.declarator.getNameRequired();\n        const lookupName = name.getLookupName(ctx);\n        if (info.isStatic ) {\n            info.isExtern = true; // we only declare hereby\n            this.declareGlobal(ctx, info, lookupName);\n            if (this.initializer) {\n                throw new SyntaxError(`the static field could only be initialize outside the class`, this);\n            }\n        } else {\n            const plainName = name.getPlainName(ctx);\n            if (this.initializer instanceof InitializerList) {\n                // todo::\n                throw new SyntaxError(`unsupport initial list`, this);\n            }\n            const oldField = classType.fields.filter((field) => field.name === plainName);\n            if (oldField.length) {\n                throw new SyntaxError(`duplicated field name ${plainName}`, this);\n            }\n            classType.fields.push({\n                name: plainName,\n                type,\n                startOffset: classType.objectSize,\n                initializer: this.initializer,\n                accessControl: classType.accessControl,\n            });\n            if (!classType.isUnion) {\n                classType.objectSize += type.length;\n                classType.selfSize += type.length;\n            }\n        }\n    }\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {Node, SourceLocation} from \"../../common/node\";\nimport {AddressType, Variable} from \"../../common/symbol\";\nimport {AccessControl} from \"../../type\";\nimport {IntegerType, PrimitiveTypes} from \"../../type/primitive_type\";\nimport {WConst} from \"../../wasm\";\nimport {CompileContext} from \"../context\";\nimport {Expression} from \"../expression/expression\";\nimport {Identifier} from \"../expression/identifier\";\n\nexport class EnumSpecifier extends Node {\n    public identifier: Identifier;\n    public enumerators: Enumerator[] | null;\n\n    constructor(location: SourceLocation, identifier: Identifier, enumerators: Enumerator[] | null) {\n        super(location);\n        this.identifier = identifier;\n        this.enumerators = enumerators;\n    }\n\n    public codegen(ctx: CompileContext) {\n        if (this.enumerators != null) {\n            let now = -1, val = 0;\n            for (const enumerator of this.enumerators) {\n                now++;\n                if (enumerator.value === null) {\n                    val = now;\n                } else {\n                    const expr = enumerator.value.codegen(ctx);\n                    expr.expr = expr.expr.fold();\n                    if (!(expr.expr instanceof WConst) ||\n                        !(expr.type instanceof IntegerType)) {\n                        throw new SyntaxError(`enum value must be integer`, this);\n                    }\n                    val = parseInt(expr.expr.constant);\n                }\n                const shortName = enumerator.identifier.getPlainName(ctx);\n                const fullName = enumerator.identifier.getFullName(ctx);\n                ctx.scopeManager.declare(shortName, new Variable(\n                    shortName, fullName,\n                    ctx.fileName, PrimitiveTypes.int32,\n                    AddressType.CONSTANT, val, AccessControl.Public,\n                ), this);\n            }\n        }\n        if (this.identifier != null) {\n            ctx.scopeManager.declare(this.identifier.getLookupName(ctx), PrimitiveTypes.int32, this);\n        }\n        return PrimitiveTypes.int32;\n    }\n}\n\nexport class Enumerator extends Node {\n    public identifier: Identifier;\n    public value: Expression | null;\n\n    constructor(location: SourceLocation, identifier: Identifier, value: Expression | null) {\n        super(location);\n        this.identifier = identifier;\n        this.value = value;\n    }\n}\n","import {InternalError, SyntaxError} from \"../../common/error\";\nimport {Node, SourceLocation} from \"../../common/node\";\nimport {getPrimitiveTypeFromSpecifiers, isTypeSpecifier} from \"../../common/utils\";\nimport {Type} from \"../../type\";\nimport {ClassSpecifier} from \"../class/class_specifier\";\nimport {EnumSpecifier} from \"../class/enum_specifier\";\nimport {CompileContext} from \"../context\";\nimport {Identifier} from \"../expression/identifier\";\n\nexport type SpecifierType =\n    string\n    | Identifier\n    | ClassSpecifier\n    | EnumSpecifier;\n\nexport class SpecifierList extends Node {\n    public specifiers: SpecifierType[];\n\n    constructor(location: SourceLocation, specifiers: SpecifierType[]) {\n        super(location);\n        this.specifiers = specifiers;\n    }\n\n    public getType(ctx: CompileContext): Type {\n        let resultType: Type | null = null;\n        const typeNodes = this.specifiers.filter((x) => typeof(x) !== \"string\");\n        const stringNodes = this.specifiers.filter((x) => typeof(x) === \"string\") as string[];\n        if (typeNodes.length !== 0) {\n            if ( typeNodes.length !== 1) {\n                throw new SyntaxError(`illegal syntax`, this);\n            }\n            const node = typeNodes[0];\n            if ( node instanceof ClassSpecifier) {\n                resultType = node.codegen(ctx);\n            } else if ( node instanceof Identifier) {\n                resultType = node.deduceType(ctx);\n            } else if ( node instanceof EnumSpecifier) {\n                resultType = node.codegen(ctx);\n            } else {\n                throw new InternalError(`unsupport type`);\n            }\n        } else {\n            // primitive types\n            const typeNames = stringNodes.filter(isTypeSpecifier).sort();\n            resultType = getPrimitiveTypeFromSpecifiers(typeNames);\n        }\n        if (resultType == null) {\n            throw new SyntaxError(\"Illegal Return Type\", this);\n        }\n        if (stringNodes.indexOf(\"const\") !== -1) {\n            // TODO:: big bug\n            // alter on type may result in pollution\n            // resultType.isConst = true;\n        }\n        return resultType;\n    }\n}\n","import {Node, SourceLocation} from \"../../common/node\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {WBlock, WBr, WBrIf, WLoop, WStatement} from \"../../wasm\";\nimport {CompileContext} from \"../context\";\nimport {doConversion} from \"../conversion\";\nimport {Declaration} from \"../declaration/declaration\";\nimport {IdentifierDeclarator} from \"../declaration/identifier_declarator\";\nimport {InitDeclarator} from \"../declaration/init_declartor\";\nimport {SpecifierList} from \"../declaration/specifier_list\";\nimport {BinaryExpression} from \"../expression/binary_expression\";\nimport {Expression, recycleExpressionResult} from \"../expression/expression\";\nimport {Identifier} from \"../expression/identifier\";\nimport {IntegerConstant} from \"../expression/integer_constant\";\nimport {UnaryExpression} from \"../expression/unary_expression\";\nimport {CompoundStatement} from \"./compound_statement\";\nimport {Statement} from \"./statement\";\n\nexport class ForStatement extends Statement {\n    public init: Expression | Declaration | null;\n    public test: Expression | null;\n    public update: Expression | null;\n    public body: Statement;\n\n    constructor(location: SourceLocation,\n                init: Expression | Declaration | null,\n                test: Expression | null,\n                update: Expression | null,\n                body: Statement) {\n        super(location);\n        this.init = init;\n        this.test = test;\n        this.update = update;\n        this.body = body;\n    }\n\n    public codegen(ctx: CompileContext) {\n        ctx.enterScope();\n        if (this.init !== null) {\n            if (this.init instanceof Declaration) {\n                this.init.codegen(ctx);\n            } else {\n                recycleExpressionResult(ctx, this, this.init.codegen(ctx));\n            }\n        }\n\n        const outerBlockStatements: WStatement[] = [];\n        const innerBlockStatements: WStatement[] = [];\n        const loopStatements: WStatement[] = [];\n\n        const savedContainer = ctx.getStatementContainer();\n        // <-- inner block -->\n        ctx.setStatementContainer(innerBlockStatements);\n        ctx.currentFuncContext.continueStack.push(ctx.currentFuncContext.blockLevel + 3);\n        ctx.currentFuncContext.breakStack.push(ctx.currentFuncContext.blockLevel + 1);\n        ctx.currentFuncContext.blockLevel += 3;\n        if (this.body instanceof CompoundStatement) {\n            this.body.codegen(ctx);\n        } else {\n            this.body.codegen(ctx);\n        }\n        ctx.currentFuncContext.blockLevel += 3;\n        ctx.currentFuncContext.continueStack.pop();\n        ctx.currentFuncContext.breakStack.pop();\n        // <-- inner block -->\n\n        // <-- loop -->\n        ctx.setStatementContainer(loopStatements);\n        if (this.test !== null) {\n            const condition = new UnaryExpression(this.location,\n                \"!\", this.test).codegen(ctx);\n            condition.expr = doConversion(ctx, PrimitiveTypes.int32, condition, this);\n            condition.type = PrimitiveTypes.int32;\n            ctx.submitStatement(new WBrIf(1, condition.expr.fold(), this.location));\n        }\n        ctx.submitStatement(new WBlock(innerBlockStatements, this.location));\n        if (this.update !== null) {\n            recycleExpressionResult(ctx, this, this.update.codegen(ctx));\n        }\n        ctx.submitStatement(new WBr(0, this.location));\n        // <-- loop -->\n\n        // <-- outer block -->\n        ctx.setStatementContainer(outerBlockStatements);\n        ctx.submitStatement(new WLoop(loopStatements, this.location));\n        // <-- outer block -->\n        ctx.exitScope(this);\n        ctx.setStatementContainer(savedContainer);\n        ctx.submitStatement(new WBlock(outerBlockStatements, this.location));\n    }\n}\n\nexport function getForLoop(sizeExpr: Expression,\n                           statements: (idx: Identifier) => Statement[], node: Node): ForStatement {\n    const i = Identifier.fromString(node.location, \"i\");\n    return new ForStatement(node.location,\n        // i = 0\n        new Declaration(node.location, new SpecifierList(node.location, [\"int\"]), [new InitDeclarator(\n            node.location, new IdentifierDeclarator(node.location, i), IntegerConstant.ZeroConstant,\n        )]),\n        // i < size\n        new BinaryExpression(node.location, \"<\", i, sizeExpr),\n        // i ++\n        new UnaryExpression(node.location, \"++\", i),\n        new CompoundStatement(node.location, statements(i)));\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {IntegerType} from \"../../type/primitive_type\";\nimport {WConst} from \"../../wasm\";\nimport {CaseContext, CompileContext} from \"../context\";\nimport {Expression} from \"../expression/expression\";\nimport {FunctionLookUpResult} from \"../scope\";\nimport {Statement} from \"./statement\";\n\nexport class CaseStatement extends Statement {\n    public test: Expression;\n    public body: Statement;\n    constructor(location: SourceLocation, test: Expression, body: Statement) {\n        super(location);\n        this.test = test;\n        this.body = body;\n    }\n\n    public codegen(ctx: CompileContext): void {\n        if (ctx.currentFuncContext.switchContext === null) {\n            throw new SyntaxError(`case out of switch`, this);\n        }\n        const caseCtx: CaseContext = {value: null, statements: []};\n        ctx.currentFuncContext.switchContext.cases.push(caseCtx);\n        if (this.test !== null) {\n            const expr = this.test.codegen(ctx);\n            if (expr.expr instanceof FunctionLookUpResult) {\n                throw new SyntaxError(`func name not support`, this);\n            }\n            expr.expr = expr.expr.fold();\n            if (!(expr.expr instanceof WConst) || !(expr.type instanceof IntegerType)) {\n                throw new SyntaxError(`case value must be integer or enum`, this);\n            }\n            caseCtx.value = expr.expr;\n        }\n        ctx.setStatementContainer(caseCtx.statements);\n        ctx.currentFuncContext.blockLevel--;\n        this.body.codegen(ctx);\n    }\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {WBr} from \"../../wasm\";\nimport {CompileContext} from \"../context\";\nimport {Statement} from \"./statement\";\n\nexport class ContinueStatement extends Statement {\n    constructor(location: SourceLocation) {\n        super(location);\n    }\n\n    public codegen(ctx: CompileContext): void {\n        if (ctx.currentFuncContext.continueStack.length === 0) {\n            throw new SyntaxError(`continue is not in while/do-while/for`, this);\n        }\n        const item = ctx.currentFuncContext.continueStack[ctx.currentFuncContext.continueStack.length - 1];\n        ctx.submitStatement(new WBr(ctx.currentFuncContext.blockLevel - item, this.location));\n\n    }\n\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {ClassDirective, SourceLocation} from \"../../common/node\";\nimport {ClassType} from \"../../type/class_type\";\nimport {CompileContext} from \"../context\";\nimport {Identifier} from \"../expression/identifier\";\nimport {Statement} from \"./statement\";\n\nexport class UsingNamespaceStatement extends ClassDirective {\n    public namespace: Identifier;\n\n    constructor(location: SourceLocation, namespace: Identifier) {\n        super(location);\n        this.namespace = namespace;\n    }\n\n    public codegen(ctx: CompileContext): void {\n        const scope =\n            ctx.scopeManager.root.getScopeOfLookupName(this.namespace.getLookupName(ctx) + \"::a\");\n        if ( !scope) {\n            throw new SyntaxError(`${this.namespace.getFullName(ctx)} is not a namespace`, this);\n        }\n        ctx.scopeManager.currentContext.activeScopes.push(scope);\n    }\n\n    public declare(ctx: CompileContext, classType: ClassType): void {\n        this.codegen(ctx);\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {WBlock, WBrIf, WLoop, WStatement} from \"../../wasm\";\nimport {CompileContext} from \"../context\";\nimport {doConversion} from \"../conversion\";\nimport {Expression} from \"../expression/expression\";\nimport {Statement} from \"./statement\";\n\nexport class DoWhileStatement extends Statement {\n    public body: Statement;\n    public test: Expression;\n\n    constructor(location: SourceLocation, body: Statement, test: Expression) {\n        super(location);\n        this.body = body;\n        this.test = test;\n    }\n\n    public codegen(ctx: CompileContext) {\n        const doWhileLoop: WStatement[] = [];\n        const doWhileBlock: WStatement[] = [];\n\n        const savedContainer = ctx.getStatementContainer();\n\n        // <-- block -->\n        ctx.setStatementContainer(doWhileBlock);\n        ctx.currentFuncContext.continueStack.push(ctx.currentFuncContext.blockLevel + 2);\n        ctx.currentFuncContext.breakStack.push(ctx.currentFuncContext.blockLevel + 1);\n        ctx.currentFuncContext.blockLevel += 2;\n        this.body.codegen(ctx);\n        ctx.currentFuncContext.blockLevel -= 2;\n        ctx.currentFuncContext.continueStack.pop();\n        ctx.currentFuncContext.breakStack.pop();\n        // <-- block -->\n\n        // <-- loop -->\n        ctx.setStatementContainer(doWhileLoop);\n        ctx.submitStatement(new WBlock(doWhileBlock, this.location));\n        const condition = this.test.codegen(ctx);\n        condition.expr = doConversion(ctx, PrimitiveTypes.int32, condition, this);\n        condition.type = PrimitiveTypes.int32;\n        ctx.submitStatement(new WBrIf(0, condition.expr.fold(), this.location));\n        // <-- loop -->\n\n        ctx.setStatementContainer(savedContainer);\n        ctx.submitStatement(new WLoop(doWhileLoop, this.location));\n    }\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {AddressType} from \"../../common/symbol\";\nimport {IntegerType} from \"../../type/primitive_type\";\nimport {I32Binary, WBinaryOperation, WBlock} from \"../../wasm\";\nimport {WStatement, WBr, WBrIf} from \"../../wasm\";\nimport {WAddressHolder} from \"../address\";\nimport {CompileContext} from \"../context\";\nimport {doValueTransform} from \"../conversion\";\nimport {Expression} from \"../expression/expression\";\nimport {FunctionLookUpResult} from \"../scope\";\nimport {CaseStatement} from \"./case_statement\";\nimport {CompoundStatement} from \"./compound_statement\";\nimport {Statement} from \"./statement\";\n\nexport class SwitchStatement extends Statement {\n    public discriminant: Expression;\n    public body: CompoundStatement;\n\n    constructor(location: SourceLocation, discriminant: Expression, body: CompoundStatement) {\n        super(location);\n        this.discriminant = discriminant;\n        this.body = body;\n    }\n\n    public codegen(ctx: CompileContext) {\n        const savedSwitchContext = ctx.currentFuncContext.switchContext;\n        const savedStatementContainer = ctx.getStatementContainer();\n        const mockContainer: WStatement[] = [];\n        ctx.setStatementContainer(mockContainer);\n        ctx.currentFuncContext.switchContext = {cases: []};\n        if (mockContainer.length !== 0) {\n            throw new SyntaxError(`illegal content in switch out side all case`, this);\n        }\n        const caseCount = this.body.body.filter((x) => x instanceof CaseStatement).length;\n        let defaultBreakLevel = caseCount;\n        ctx.currentFuncContext.breakStack.push(ctx.currentFuncContext.blockLevel);\n        ctx.currentFuncContext.blockLevel += caseCount;\n        this.body.codegen(ctx);\n        const defaultBranches = ctx.currentFuncContext.switchContext.cases.filter((x) => x.value === null);\n        if (defaultBranches.length > 1) {\n            throw new SyntaxError(`only 1 default case is support`, this);\n        }\n        if (defaultBranches.length === 1) {\n            for (let i = 0; i < ctx.currentFuncContext.switchContext.cases.length; i++) {\n                if (ctx.currentFuncContext.switchContext.cases[i].value === null) {\n                    defaultBreakLevel = i;\n                    break;\n                }\n            }\n        }\n        const tmpVarLoc = ctx.memory.allocStack(4);\n        const tmpVarPtr = new WAddressHolder(tmpVarLoc, AddressType.STACK, this.location);\n        const cond = doValueTransform(ctx, this.discriminant.codegen(ctx), this);\n        if (!(cond.type instanceof IntegerType) || cond.expr instanceof FunctionLookUpResult) {\n            throw new SyntaxError(`illegal switch cond type`, this);\n        }\n        ctx.setStatementContainer(savedStatementContainer);\n        ctx.submitStatement(tmpVarPtr.createStore(ctx, cond.type, cond.expr, true));\n        let currentBlock = new WBlock([], this.location);\n        const condExpr = tmpVarPtr.createLoad(ctx, cond.type);\n        for (let i = 0; i < ctx.currentFuncContext.switchContext.cases.length; i++) {\n            const val = ctx.currentFuncContext.switchContext.cases[i].value;\n            if (val !== null) {\n                currentBlock.body.push(new WBrIf(i, new WBinaryOperation(\n                    I32Binary.eq,\n                    condExpr,\n                    val,\n                    this.location,\n                ), this.location));\n            }\n        }\n        currentBlock.body.push(new WBr(defaultBreakLevel, this.location));\n        for (let i = 0; i < ctx.currentFuncContext.switchContext.cases.length; i++) {\n            currentBlock = new WBlock([currentBlock,\n                ...ctx.currentFuncContext.switchContext.cases[i].statements], this.location);\n        }\n        ctx.submitStatement(currentBlock);\n        ctx.currentFuncContext.switchContext = savedSwitchContext;\n\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {WIfElseBlock} from \"../../wasm\";\nimport {WStatement} from \"../../wasm\";\nimport {CompileContext} from \"../context\";\nimport {doConversion} from \"../conversion\";\nimport {Expression} from \"../expression/expression\";\nimport {Statement} from \"./statement\";\n\nexport class IfStatement extends Statement {\n    public test: Expression;\n    public consequent: Statement;\n    public alternate: Statement | null;\n\n    constructor(location: SourceLocation, test: Expression, consequent: Statement, alternate: Statement | null) {\n        super(location);\n        this.test = test;\n        this.consequent = consequent;\n        this.alternate = alternate;\n    }\n\n    public codegen(ctx: CompileContext): void {\n        const thenStatements: WStatement[] = [];\n        const elseStatements: WStatement[] = [];\n        const condition = this.test.codegen(ctx);\n\n        condition.expr = doConversion(ctx, PrimitiveTypes.int32, condition, this);\n        condition.type = PrimitiveTypes.int32;\n\n        const savedContainer = ctx.getStatementContainer();\n        ctx.setStatementContainer(thenStatements);\n        ctx.currentFuncContext.blockLevel++;\n        this.consequent.codegen(ctx);\n        if (this.alternate !== null) {\n            ctx.setStatementContainer(elseStatements);\n            this.alternate.codegen(ctx);\n        }\n        ctx.setStatementContainer(savedContainer);\n        ctx.currentFuncContext.blockLevel--;\n        if (this.alternate !== null) {\n            ctx.submitStatement(new WIfElseBlock(condition.expr.fold(), thenStatements,\n                elseStatements, this.location));\n        } else {\n            ctx.submitStatement(new WIfElseBlock(condition.expr.fold(), thenStatements,\n                null, this.location));\n        }\n    }\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {CompileContext} from \"../context\";\nimport {Identifier} from \"../expression/identifier\";\nimport {Statement} from \"./statement\";\n\nexport class GotoStatement extends Statement {\n    public label: Identifier;\n\n    constructor(location: SourceLocation, label: Identifier) {\n        super(location);\n        this.label = label;\n    }\n\n    public codegen(ctx: CompileContext): void {\n        throw new SyntaxError(\"goto statement is not support currently\", this);\n\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {CompileContext} from \"../context\";\nimport {Identifier} from \"../expression/identifier\";\nimport {Statement} from \"./statement\";\n\nexport class LabeledStatement extends Statement {\n    public label: Identifier;\n    public body: Statement;\n\n    constructor(location: SourceLocation, label: Identifier, body: Statement) {\n        super(location);\n        this.label = label;\n        this.body = body;\n    }\n\n    public codegen(ctx: CompileContext): void {\n        this.body.codegen(ctx);\n    }\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {WBlock, WBr, WBrIf, WLoop, WStatement} from \"../../wasm\";\nimport {CompileContext} from \"../context\";\nimport {doConversion} from \"../conversion\";\nimport {Expression} from \"../expression/expression\";\nimport {UnaryExpression} from \"../expression/unary_expression\";\nimport {Statement} from \"./statement\";\n\nexport class WhileStatement extends Statement {\n    public test: Expression;\n    public body: Statement;\n\n    constructor(location: SourceLocation, test: Expression, body: Statement) {\n        super(location);\n        this.test = test;\n        this.body = body;\n    }\n    public codegen(ctx: CompileContext) {\n        const whileBlock: WStatement[] = [];\n        const whileLoop: WStatement[] = [];\n        const savedContainer = ctx.getStatementContainer();\n\n        // <-- loop -->\n        ctx.setStatementContainer(whileLoop);\n        const condition = new UnaryExpression(this.location,\n            \"!\", this.test).codegen(ctx);\n        condition.expr = doConversion(ctx, PrimitiveTypes.int32, condition, this);\n        condition.type = PrimitiveTypes.int32;\n        ctx.submitStatement(new WBrIf(1, condition.expr.fold(), this.location));\n        ctx.currentFuncContext.continueStack.push(ctx.currentFuncContext.blockLevel + 2);\n        ctx.currentFuncContext.breakStack.push(ctx.currentFuncContext.blockLevel + 1);\n        ctx.currentFuncContext.blockLevel += 2;\n        this.body.codegen(ctx);\n        ctx.currentFuncContext.blockLevel -= 2;\n        ctx.currentFuncContext.breakStack.pop();\n        ctx.currentFuncContext.continueStack.pop();\n        ctx.submitStatement(new WBr(0, this.location));\n        // <-- loop -->\n\n        // <-- block -->\n        ctx.setStatementContainer(whileBlock);\n        ctx.submitStatement(new WLoop(whileLoop, this.location));\n        // <-- block -->\n\n        ctx.setStatementContainer(savedContainer);\n        ctx.submitStatement(new WBlock(whileBlock, this.location));\n    }\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {ArrayType, ReferenceType} from \"../../type/compound_type\";\nimport {IntegerType} from \"../../type/primitive_type\";\nimport {WConst, WExpression} from \"../../wasm\";\nimport {CompileContext} from \"../context\";\nimport {Expression} from \"../expression/expression\";\nimport {Declarator} from \"./declarator\";\n\nexport class ArrayDeclarator extends Declarator {\n    public static: boolean;\n    public qualifiers: string[];\n    public length: Expression;\n    public variableLength: boolean;\n\n    constructor(location: SourceLocation, declarator: Declarator,\n                isStatic: boolean, qualifiers: string[], length: Expression,\n                variableLength: boolean) {\n        super(location, declarator);\n        this.static = isStatic;\n        this.qualifiers = qualifiers;\n        this.length = length;\n        this.variableLength = variableLength;\n    }\n\n    public getType(ctx: CompileContext, baseType: Type): Type {\n        if ( baseType instanceof ReferenceType) {\n            throw new SyntaxError(`there is no array of reference`, this);\n        }\n        if ( !this.length ) {\n            return new ArrayType(baseType, 0);\n        }\n        const length = this.length.codegen(ctx);\n        length.expr = length.expr.fold();\n        if (!(length.expr instanceof WConst)) {\n            throw new SyntaxError(\"var length array is not support currently\", this);\n        }\n        if (!(length.type instanceof IntegerType)) {\n            throw new SyntaxError(\"length of array must be integer\", this);\n        }\n        if (this.qualifiers.length !== 0) {\n            ctx.raiseWarning(\"unsupport array qualifier\", this);\n        }\n        const result = new ArrayType(baseType, parseInt(length.expr.constant));\n        return this.declarator ? this.declarator.getType(ctx, result) : result;\n    }\n}\n","import {LanguageError, SyntaxError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {PointerType} from \"../../type/compound_type\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {CompileContext} from \"../context\";\nimport {ArrayDeclarator} from \"../declaration/array_declarator\";\nimport {AnonymousExpression} from \"../expression/anonymous_expression\";\nimport {AssignmentExpression} from \"../expression/assignment_expression\";\nimport {BinaryExpression} from \"../expression/binary_expression\";\nimport {Expression, ExpressionResult, recycleExpressionResult} from \"../expression/expression\";\nimport {Identifier} from \"../expression/identifier\";\nimport {IntegerConstant} from \"../expression/integer_constant\";\nimport {CallExpression} from \"../function/call_expression\";\nimport {ExpressionStatement} from \"../statement/expression_statement\";\nimport {getForLoop} from \"../statement/for_statement\";\nimport {TypeName} from \"./type_name\";\n\nexport class NewExpression extends Expression {\n    public name: TypeName;\n    public arguments: Expression[];\n    public placement: Expression | null;\n    public arraySize: Expression | null;\n\n    constructor(location: SourceLocation, name: TypeName,\n                arguments_: Expression[], placement: Expression | null) {\n        super(location);\n        this.name = name;\n        this.arguments = arguments_;\n        this.placement = placement;\n        this.arraySize = null;\n        // do array transform\n        if (this.name.declarator instanceof ArrayDeclarator) {\n            this.arraySize = this.name.declarator.length;\n            this.name.declarator = null;\n        }\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        if ( !ctx.isCpp() ) {\n            throw new LanguageError(`new is noly support in c++`, this);\n        }\n        const ptrType = this.deduceType(ctx);\n        if (!(ptrType instanceof PointerType)) {\n            throw new SyntaxError(`new must be pointer`, this);\n        }\n        const itemType = ptrType.elementType;\n        const [ptrVarName] = ctx.allocTmpVar(ptrType, this);\n        if ( this.arraySize !== null ) {\n            const [sizeVarName] = ctx.allocTmpVar(PrimitiveTypes.int32, this);\n\n            const sizeExpr = IntegerConstant.fromNumber(this.location, itemType.length);\n\n            // size = sizeof(Type) * SizeExpression\n            const assignSizeExpr = new AssignmentExpression(this.location, \"=\",\n                Identifier.fromString(this.location, sizeVarName), this.arraySize).codegen(ctx);\n            recycleExpressionResult(ctx, this, assignSizeExpr);\n\n            // headPtr = (int *) malloc(size + 4)\n            const mallocExpr = new CallExpression(this.location, Identifier.fromString(this.location, \"::malloc_array\"),\n                [\n                    sizeExpr,\n                    Identifier.fromString(this.location, sizeVarName),\n                ]).codegen(ctx);\n            mallocExpr.type = ptrType;\n\n            const assignExpr = new AssignmentExpression(this.location, \"=\",\n                Identifier.fromString(this.location, ptrVarName),\n                new AnonymousExpression(this.location, mallocExpr)).codegen(ctx);\n            recycleExpressionResult(ctx, this, assignExpr);\n            // for(int i = 0; i < size; i++ )\n            if (itemType instanceof ClassType) {\n                const ctorName = itemType.fullName + \"::#\" + itemType.shortName;\n                const callee = Identifier.fromString(this.location, ctorName);\n                getForLoop(Identifier.fromString(this.location, sizeVarName), (i) => ([\n                    new ExpressionStatement(this.location,\n                        new CallExpression(this.location, callee, [\n                            new BinaryExpression(this.location, \"+\",\n                                Identifier.fromString(this.location, ptrVarName),\n                                i)]))]), this).codegen(ctx);\n            }\n        } else {\n            const mallocExpr = new CallExpression(this.location, Identifier.fromString(this.location, \"::malloc\"),\n                [IntegerConstant.fromNumber(this.location, itemType.length)]).codegen(ctx);\n            mallocExpr.type = ptrType;\n            const assignExpr = new AssignmentExpression(this.location, \"=\",\n                Identifier.fromString(this.location, ptrVarName),\n                new AnonymousExpression(this.location, mallocExpr)).codegen(ctx);\n            recycleExpressionResult(ctx, this, assignExpr);\n            if (itemType instanceof ClassType) {\n                const ctorName = itemType.fullName + \"::#\" + itemType.shortName;\n                const callee = Identifier.fromString(this.location, ctorName);\n                const ctorExpr = new CallExpression(this.location, callee, [\n                    Identifier.fromString(this.location, ptrVarName), ...this.arguments]).codegen(ctx);\n                recycleExpressionResult(ctx, this, ctorExpr);\n            }\n        }\n        return Identifier.fromString(this.location, ptrVarName).codegen(ctx);\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        return new PointerType(this.name.deduceType(ctx));\n    }\n\n}\n","import {LanguageError, SyntaxError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {CompileContext} from \"../context\";\nimport {Expression, ExpressionResult, recycleExpressionResult} from \"../expression/expression\";\nimport {Identifier} from \"../expression/identifier\";\nimport {UnaryExpression} from \"../expression/unary_expression\";\nimport {CallExpression} from \"../function/call_expression\";\n\nexport class ConstructorCallExpression extends Expression {\n    public name: Identifier;\n    public arguments: Expression[];\n\n    constructor(location: SourceLocation, name: Identifier, myArguments: Expression[]) {\n        super(location);\n        this.name = name;\n        this.arguments = myArguments;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        if ( !ctx.isCpp() ) {\n            throw new LanguageError(`constructor is noly support in c++`, this);\n        }\n        const classType = this.deduceType(ctx);\n        if (!(classType instanceof ClassType)) {\n            throw new SyntaxError(`constructor call must be class type`, this);\n        }\n        const ctorName = classType.fullName + \"::#\" + classType.shortName;\n        const callee = Identifier.fromString(this.location, ctorName);\n        const [tmpVarName] = ctx.allocTmpVar(classType, this);\n        const thisVar = Identifier.fromString(this.location, tmpVarName);\n        const thisPtr = new UnaryExpression(this.location, \"&\", thisVar);\n        recycleExpressionResult(ctx, this,\n            new CallExpression(this.location, callee, [thisPtr, ...this.arguments]).codegen(ctx));\n        return thisVar.codegen(ctx);\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        return this.name.deduceType(ctx);\n\n    }\n\n}\n","import {LanguageError, SyntaxError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {AddressType, Variable} from \"../../common/symbol\";\nimport {AccessControl, Type} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {PointerType} from \"../../type/compound_type\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {WConst, WType} from \"../../wasm\";\nimport {CompileContext} from \"../context\";\nimport {AnonymousExpression} from \"../expression/anonymous_expression\";\nimport {AssignmentExpression} from \"../expression/assignment_expression\";\nimport {BinaryExpression} from \"../expression/binary_expression\";\nimport {Expression, ExpressionResult, recycleExpressionResult} from \"../expression/expression\";\nimport {Identifier} from \"../expression/identifier\";\nimport {IntegerConstant} from \"../expression/integer_constant\";\nimport {UnaryExpression} from \"../expression/unary_expression\";\nimport {CallExpression} from \"../function/call_expression\";\nimport {ExpressionStatement} from \"../statement/expression_statement\";\nimport {getForLoop} from \"../statement/for_statement\";\nimport {MemberExpression} from \"./member_expression\";\n\nexport class DeleteExpression extends Expression {\n    public expr: Expression;\n    public isArrayDelete: boolean;\n\n    constructor(location: SourceLocation, expr: Expression, isArrayDelete: boolean) {\n        super(location);\n        this.expr = expr;\n        this.isArrayDelete = isArrayDelete;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        if (!ctx.isCpp()) {\n            throw new LanguageError(`delete is only support in c++`, this);\n        }\n        if (this.isArrayDelete) {\n            this.deleteArray(ctx);\n        } else {\n            this.deleteObject(ctx);\n        }\n        return {\n            type: PrimitiveTypes.void,\n            isLeft: true,\n            expr: new WConst(WType.none, \"1\", this.location),\n        };\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        return PrimitiveTypes.void;\n    }\n\n    private deleteObject(ctx: CompileContext): void {\n        const rightType = this.expr.deduceType(ctx);\n        if (!(rightType instanceof PointerType)) {\n            throw new SyntaxError(`you can only delete pointer, instead of ${rightType.toString()}`, this);\n        }\n        if (rightType.elementType instanceof ClassType) {\n            const tmpVarName = ctx.scopeManager.allocTmpVarName();\n            const tmpVar = new Variable(tmpVarName, tmpVarName, this.location.fileName, rightType,\n                AddressType.STACK, ctx.memory.allocStack(rightType.length), AccessControl.Public);\n            ctx.scopeManager.define(tmpVarName, tmpVar, this);\n\n            new AssignmentExpression(this.location, \"=\",\n                Identifier.fromString(this.location, tmpVarName), this.expr).codegen(ctx);\n\n            const memExpr =\n                new MemberExpression(this.location, Identifier.fromString(this.location, tmpVarName),\n                    true, Identifier.fromString(this.location, \"~\" + rightType.elementType.shortName));\n\n            memExpr.forceDynamic = true;\n\n            new ExpressionStatement(this.location, new CallExpression(this.location, memExpr,\n                [])).codegen(ctx);\n\n            new ExpressionStatement(this.location, new CallExpression(this.location,\n                Identifier.fromString(this.location, \"::free\"), [\n                    Identifier.fromString(this.location, tmpVarName),\n                ])).codegen(ctx);\n        } else {\n            new ExpressionStatement(this.location, new CallExpression(\n                this.location, Identifier.fromString(this.location, \"::free\"),\n                [this.expr],\n            )).codegen(ctx);\n        }\n    }\n\n    private deleteArray(ctx: CompileContext): void {\n        const rightType = this.expr.deduceType(ctx);\n        if (!(rightType instanceof PointerType)) {\n            throw new SyntaxError(`you can only delete pointer, instead of ${rightType.toString()}`, this);\n        }\n        const [ptrVarName] = ctx.allocTmpVar(rightType, this);\n        const [basePtrVarName] = ctx.allocTmpVar(new PointerType(PrimitiveTypes.int32), this);\n        const [sizeVarName] = ctx.allocTmpVar(PrimitiveTypes.int32, this);\n\n        // ptr = ptr\n        const assignPtrExpr = new AssignmentExpression(this.location, \"=\",\n            Identifier.fromString(this.location, ptrVarName), this.expr).codegen(ctx);\n        recycleExpressionResult(ctx, this, assignPtrExpr);\n\n        const tmpPtrExpr = Identifier.fromString(this.location, ptrVarName).codegen(ctx);\n        tmpPtrExpr.type = new PointerType(PrimitiveTypes.int32);\n\n        // basePtr = (int*)ptr - 1\n        const basePtrExpr = new AssignmentExpression(this.location, \"=\",\n            Identifier.fromString(this.location, basePtrVarName), new BinaryExpression(\n                this.location, \"-\", new AnonymousExpression(this.location, tmpPtrExpr),\n                IntegerConstant.OneConstant,\n            )).codegen(ctx);\n        recycleExpressionResult(ctx, this, basePtrExpr);\n\n        // size = *basePtr\n        const assignSizeExpr = new AssignmentExpression(this.location, \"=\",\n            Identifier.fromString(this.location, sizeVarName), new UnaryExpression(\n                this.location, \"*\", Identifier.fromString(this.location, basePtrVarName),\n            )).codegen(ctx);\n        recycleExpressionResult(ctx, this, assignSizeExpr);\n\n        if (rightType.elementType instanceof ClassType) {\n            // call dtor\n            const dtorName = \"~\" + rightType.elementType.shortName;\n            const callee = Identifier.fromString(this.location, dtorName);\n            const memExpr = (i: Identifier) => {\n                const expr = new MemberExpression(\n                    this.location, new BinaryExpression(this.location, \"+\",\n                        Identifier.fromString(this.location, ptrVarName),\n                        i), true, callee,\n                );\n                expr.forceDynamic = true;\n                return expr;\n            };\n            getForLoop(Identifier.fromString(this.location, sizeVarName), (i) => ([\n                new ExpressionStatement(this.location,\n                    new CallExpression(this.location, memExpr(i), []))]), this).codegen(ctx);\n\n        }\n\n        // free(basePtr)\n        new ExpressionStatement(this.location, new CallExpression(\n            this.location, Identifier.fromString(this.location, \"::free\"),\n            [Identifier.fromString(this.location, basePtrVarName)],\n        )).codegen(ctx);\n    }\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {Node, SourceLocation} from \"../../common/node\";\nimport {getAccessControlFromString} from \"../../type\";\nimport {ClassType, Inheritance} from \"../../type/class_type\";\nimport {CompileContext} from \"../context\";\nimport {Identifier} from \"../expression/identifier\";\n\nexport class BaseSpecifier extends Node {\n    public accessControl: string;\n    public className: Identifier;\n\n    constructor(location: SourceLocation, accessControl: string, className: Identifier) {\n        super(location);\n        this.accessControl = accessControl;\n        this.className = className;\n    }\n\n    public codegen(ctx: CompileContext): Inheritance {\n        const accessControl = getAccessControlFromString(this.accessControl);\n        const classType = ctx.scopeManager.lookup(this.className.getLookupName(ctx));\n        if (!(classType instanceof ClassType)) {\n            throw new SyntaxError(`you could not inherit type ${classType}, which is not a class type`, this);\n        }\n        if (!classType.isComplete) {\n            throw new SyntaxError(`you could not inherit type ${classType}, which is incomplete`, this);\n        }\n        return {\n            classType,\n            accessControl,\n        };\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {WConst} from \"../../wasm\";\nimport {CompileContext} from \"../context\";\nimport {Constant} from \"./constant\";\nimport {ExpressionResult} from \"./expression\";\n\nexport class FloatingConstant extends Constant {\n    public value: number;\n    public raw: string;\n    public suffix: string | null;\n\n    constructor(location: SourceLocation, value: number, raw: string, suffix: string | null) {\n        super(location);\n        this.value = value;\n        this.raw = raw;\n        this.suffix = suffix;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        const type = this.deduceType(ctx);\n        return {\n            type,\n            expr: new WConst(type.toWType(), this.raw, this.location),\n            isLeft: false,\n        };\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        if (this.suffix && this.suffix.toUpperCase() === \"F\") {\n            return PrimitiveTypes.float;\n        } else {\n            return PrimitiveTypes.double;\n        }\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {PointerType} from \"../../type/compound_type\";\nimport {CharType} from \"../../type/primitive_type\";\nimport {CompileContext} from \"../context\";\nimport {Expression, ExpressionResult} from \"./expression\";\nimport {WGetAddress, WMemoryLocation} from \"../../wasm\";\n\nconst __ccharptr = new PointerType(new CharType());\n\nexport class StringLiteral extends Expression {\n    public prefix: string | null;\n    public value: string;\n\n    constructor(location: SourceLocation, prefix: string | null, value: string) {\n        super(location);\n        this.prefix = prefix;\n        this.value = value;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        const expr = new WGetAddress(WMemoryLocation.DATA, this.location);\n        expr.offset = ctx.memory.allocString(this.value);\n        return {\n            type: __ccharptr,\n            expr,\n            isLeft: false,\n        };\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        return __ccharptr;\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {TypeName} from \"../class/type_name\";\nimport {CompileContext} from \"../context\";\nimport {doConversion} from \"../conversion\";\nimport {Expression, ExpressionResult} from \"./expression\";\n\nexport class CastExpression extends Expression {\n    public typeName: TypeName;\n    public operand: Expression;\n\n    constructor(location: SourceLocation, typeName: TypeName, operand: Expression) {\n        super(location);\n        this.typeName = typeName;\n        this.operand = operand;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        const type = this.deduceType(ctx);\n        const expr = this.operand.codegen(ctx);\n        return {\n            type,\n            expr: doConversion(ctx, type, expr, this, true),\n            isLeft: false,\n        };\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        return this.typeName.deduceType(ctx);\n    }\n\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {AddressType} from \"../../common/symbol\";\nimport {Type} from \"../../type\";\nimport {ClassType} from \"../../type/class_type\";\nimport {LeftReferenceType} from \"../../type/compound_type\";\nimport {ArithmeticType, PrimitiveTypes} from \"../../type/primitive_type\";\nimport {WConditionalExpression} from \"../../wasm\";\nimport {WAddressHolder} from \"../address\";\nimport {CompileContext} from \"../context\";\nimport {arithmeticDeduce, doConversion, doTypeTransfrom} from \"../conversion\";\nimport {Expression, ExpressionResult} from \"./expression\";\n\nexport class ConditionalExpression extends Expression {\n    public test: Expression;\n    public consequent: Expression;\n    public alternate: Expression;\n\n    constructor(location: SourceLocation, test: Expression, consequent: Expression, alternate: Expression) {\n        super(location);\n        this.test = test;\n        this.consequent = consequent;\n        this.alternate = alternate;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        const test = doConversion(ctx, PrimitiveTypes.int32, this.test.codegen(ctx), this);\n        const targetType = this.deduceType(ctx);\n\n        const left = this.consequent.codegen(ctx);\n        const right = this.alternate.codegen(ctx);\n        if (targetType instanceof ClassType) {\n            const refType = new LeftReferenceType(targetType);\n            return {\n                type: refType,\n                expr: new WAddressHolder(new WConditionalExpression(\n                    test,\n                    doConversion(ctx, refType, left, this, false, true),\n                    doConversion(ctx, refType, right, this, false, true),\n                    this.location,\n                ), AddressType.RVALUE, this.location),\n                isLeft: true,\n            };\n        } else {\n            return {\n                type: targetType,\n                expr: new WConditionalExpression(\n                    test,\n                    doConversion(ctx, targetType, left, this),\n                    doConversion(ctx, targetType, right, this),\n                    this.location,\n                ),\n                isLeft: false,\n            };\n        }\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        const leftType = doTypeTransfrom(this.consequent.deduceType(ctx));\n        const rightType = doTypeTransfrom(this.alternate.deduceType(ctx));\n        if (leftType instanceof ArithmeticType && rightType instanceof ArithmeticType) {\n            return arithmeticDeduce(leftType, rightType);\n        } else if (leftType.equals(rightType)) {\n            return leftType;\n        } else {\n            throw new SyntaxError(`the type between conditional expression is not same`, this);\n        }\n    }\n\n}\n","import {SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {PrimitiveTypes} from \"../../type/primitive_type\";\nimport {WConst, WType} from \"../../wasm\";\nimport {CompileContext} from \"../context\";\nimport {Constant} from \"./constant\";\nimport {ExpressionResult} from \"./expression\";\n\nexport class CharacterConstant extends Constant {\n    public value: string;\n    public prefix: string | null;\n\n    constructor(location: SourceLocation, value: string, prefix: string | null) {\n        super(location);\n        this.value = value;\n        this.prefix = prefix;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        return {\n            type: PrimitiveTypes.char,\n            expr: new WConst(WType.i32, this.value.charCodeAt(0).toString(), this.location),\n            isLeft: false,\n        };\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        return PrimitiveTypes.char;\n    }\n\n}\n","import {SyntaxError} from \"../../common/error\";\nimport {SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {WAddressHolder} from \"../address\";\nimport {CompileContext} from \"../context\";\nimport {AssignmentExpression} from \"./assignment_expression\";\nimport {BinaryExpression} from \"./binary_expression\";\nimport {Expression, ExpressionResult, recycleExpressionResult} from \"./expression\";\nimport {IntegerConstant} from \"./integer_constant\";\n\nexport class PostfixExpression extends Expression {\n    public operand: Expression;\n    public decrement: boolean;\n\n    constructor(location: SourceLocation, operand: Expression, decrement: boolean) {\n        super(location);\n        this.operand = operand;\n        this.decrement = decrement;\n    }\n\n    public codegen(ctx: CompileContext): ExpressionResult {\n        const ope = this.operand.codegen(ctx);\n        if (!ope.isLeft || !(ope.expr instanceof WAddressHolder)) {\n            throw new SyntaxError(`your could not ++ a left value`, this);\n        }\n        recycleExpressionResult(ctx, this, new AssignmentExpression(this.location,\n            \"=\", this.operand, new BinaryExpression(\n                this.location, this.decrement ? \"-\" : \"+\", this.operand, IntegerConstant.OneConstant,\n            )).codegen(ctx));\n        return ope;\n    }\n\n    public deduceType(ctx: CompileContext): Type {\n        return this.operand.deduceType(ctx);\n\n    }\n\n}\n","import {Directive, SourceLocation} from \"../../common/node\";\nimport {CompileContext} from \"../context\";\nimport {Identifier} from \"../expression/identifier\";\nimport {Scope} from \"../scope\";\n\nexport class NameSpaceBlock extends Directive {\n    public namespace: Identifier;\n    public statements: Directive[];\n\n    constructor(location: SourceLocation, namespace: Identifier, statements: Directive[]) {\n        super(location);\n        this.namespace = namespace;\n        this.statements = statements;\n    }\n\n    public codegen(ctx: CompileContext): void {\n        // TODO::\n        const newScope = new Scope(this.namespace.getPlainName(ctx),\n            ctx.scopeManager.currentContext.scope, ctx.isCpp());\n        ctx.scopeManager.currentContext.scope.children.push(newScope);\n        ctx.scopeManager.contextStack.push(ctx.scopeManager.currentContext);\n        ctx.scopeManager.currentContext = {\n            scope: newScope,\n            activeScopes: [...ctx.scopeManager.currentContext.activeScopes, newScope],\n        };\n        this.statements.map((x) => x.codegen(ctx));\n        ctx.exitScope(this);\n    }\n\n}\n","import {LanguageError, SyntaxError} from \"../../common/error\";\nimport {Node, SourceLocation} from \"../../common/node\";\nimport {Type} from \"../../type\";\nimport {LeftReferenceType, PointerType, ReferenceType} from \"../../type/compound_type\";\nimport {CompileContext} from \"../context\";\nimport {Declarator} from \"./declarator\";\n\nexport class PointerDeclarator extends Declarator {\n    public pointer: Pointer;\n\n    constructor(location: SourceLocation, declarator: Declarator, pointer: Pointer) {\n        super(location, declarator);\n        this.pointer = pointer;\n    }\n\n    public getType(ctx: CompileContext, baseType: Type): Type {\n        let pointer = this.pointer as Pointer | null;\n        let result = baseType;\n        while (pointer != null) {\n            if ( result instanceof ReferenceType) {\n                throw new SyntaxError(`there is no pointer/reference of reference`, this);\n            }\n            if ( pointer.type === \"*\" ) {\n                result = new PointerType(result);\n            } else if ( pointer.type === \"&\" ) {\n                if ( !ctx.isCpp() ) {\n                    throw new LanguageError(`reference is only supported in c++`, this);\n                }\n                result = new LeftReferenceType(result);\n            } else if ( pointer.type === \"&&\" ) {\n                throw new SyntaxError(`unsupport right value reference`, this);\n            }\n            pointer = pointer.pointer;\n        }\n        return this.declarator ? this.declarator.getType(ctx, result) : result;\n    }\n}\n\nexport class Pointer extends Node {\n    public qualifiers: string[];\n    public pointer: Pointer | null;\n    public type: string;\n\n    constructor(location: SourceLocation, qualifiers: string[], pointer: Pointer | null, type: string) {\n        super(location);\n        this.qualifiers = qualifiers;\n        this.pointer = pointer;\n        this.type = type;\n    }\n}\n","import {Directive, SourceLocation} from \"../../common/node\";\nimport {Node} from \"../../common/node\";\nimport {CompileContext} from \"../context\";\n\nexport class TranslationUnit extends Node {\n    public body: Directive[];\n\n    constructor(location: SourceLocation, body: Directive[]) {\n        super(location);\n        this.body = body;\n    }\n\n    public codegen(ctx: CompileContext) {\n        this.body.map((x) => x.codegen(ctx));\n    }\n}\n","export * from \"../common/node\";\nexport * from \"../codegen/template/function_template_instantiation\";\nexport * from \"../codegen/template/class_template_instantiation\";\nexport * from \"../codegen/template/template_declaration\";\nexport * from \"../codegen/template/template_argument\";\nexport * from \"../codegen/template/template_deduce\";\nexport * from \"../codegen/template/type_parameter\";\nexport * from \"../codegen/statement/break_statement\";\nexport * from \"../codegen/statement/expression_statement\";\nexport * from \"../codegen/statement/for_statement\";\nexport * from \"../codegen/statement/case_statement\";\nexport * from \"../codegen/statement/using_statement\";\nexport * from \"../codegen/statement/continue_statement\";\nexport * from \"../codegen/statement/using_namespace_statements\";\nexport * from \"../codegen/statement/dowhile_statement\";\nexport * from \"../codegen/statement/compound_statement\";\nexport * from \"../codegen/statement/statement\";\nexport * from \"../codegen/statement/switch_statement\";\nexport * from \"../codegen/statement/if_statement\";\nexport * from \"../codegen/statement/goto_statement\";\nexport * from \"../codegen/statement/labeled_statement\";\nexport * from \"../codegen/statement/while_statement\";\nexport * from \"../codegen/function/function\";\nexport * from \"../codegen/function/return_statement\";\nexport * from \"../codegen/function/function_definition\";\nexport * from \"../codegen/function/call_expression\";\nexport * from \"../codegen/class/new_expression\";\nexport * from \"../codegen/class/constructor_call_expression\";\nexport * from \"../codegen/class/class_specifier\";\nexport * from \"../codegen/class/member_expression\";\nexport * from \"../codegen/class/constructor_declaration\";\nexport * from \"../codegen/class/destructor_declaration\";\nexport * from \"../codegen/class/enum_specifier\";\nexport * from \"../codegen/class/delete_expression\";\nexport * from \"../codegen/class/destructor\";\nexport * from \"../codegen/class/base_specifier\";\nexport * from \"../codegen/class/type_name\";\nexport * from \"../codegen/expression/expression\";\nexport * from \"../codegen/expression/floating_constant\";\nexport * from \"../codegen/expression/assignment_expression\";\nexport * from \"../codegen/expression/identifier\";\nexport * from \"../codegen/expression/string_literal\";\nexport * from \"../codegen/expression/binary_expression\";\nexport * from \"../codegen/expression/constant\";\nexport * from \"../codegen/expression/unary_expression\";\nexport * from \"../codegen/expression/integer_constant\";\nexport * from \"../codegen/expression/cast_expression\";\nexport * from \"../codegen/expression/subscript_expression\";\nexport * from \"../codegen/expression/conditional_expression\";\nexport * from \"../codegen/expression/character_constant\";\nexport * from \"../codegen/expression/postfix_expression\";\nexport * from \"../codegen/expression/anonymous_expression\";\nexport * from \"../codegen/declaration/object_initializer\";\nexport * from \"../codegen/declaration/declarator\";\nexport * from \"../codegen/declaration/namepsace_block\";\nexport * from \"../codegen/declaration/function_declarator\";\nexport * from \"../codegen/declaration/identifier_declarator\";\nexport * from \"../codegen/declaration/specifier_list\";\nexport * from \"../codegen/declaration/declaration\";\nexport * from \"../codegen/declaration/initializer_list\";\nexport * from \"../codegen/declaration/init_declartor\";\nexport * from \"../codegen/function/parameter_declaration\";\nexport * from \"../codegen/declaration/array_declarator\";\nexport * from \"../codegen/declaration/pointer_declarator\";\nexport * from \"../codegen/function/parameter_list\";\nexport * from \"../codegen/declaration/translation_unit\";\n","/* tslint:disable */\n// generate from resource/grammar        \nexport default `{\n    function newPosition(position) {\n        // For compatibility with source map.\n        return new AST.Position(position.offset, position.line, position.column - 1);\n    }\n\n    function getLocation() {\n        const location_ = location();\n        return new AST.SourceLocation(options.fileName, text(), newPosition(location_.start), newPosition(location_.end));\n    }\n\n    function extractOptional(optional, index) {\n        return optional ? optional[index] : null;\n    }\n\n    function extractList(list, index) {\n        return list.map(element => element[index]);\n    }\n\n    function buildList(head, tail, index) {\n        return [head].concat(extractList(tail, index));\n    }\n\n    function buildBinaryExpression(head, tail) {\n        return tail.reduce((result, element) => new AST.BinaryExpression(getLocation(), element[1], result, element[3]), head);\n    }\n\n    /**\n     * @param {string} hexSequence\n     */\n    function parseUniversalCharacter(hexSequence) {\n        // SAFE_NUMBER: At most 0xFFFFFFFF.\n        const charCode = Number.parseInt(hexSequence, 16);\n        // The disallowed characters are the characters in the basic character set and the code positions reserved by\n        // ISO/IEC 10646 for control characters, the character DELETE, and the S-zone (reserved for use by UTF−16).\n        if ((charCode >= 0x0000 && charCode <= 0x001F)\n                || (charCode >= 0x007F && charCode <= 0x009F)\n                || (charCode >= 0xD800 && charCode <= 0xDFFF)) {\n            error('Disallowed character in universal character name: 0x' + hexSequence, getLocation());\n        }\n        return String.fromCharCode(charCode);\n    }\n\n    let scopeRoot = { parent: null, names: new Map() };\n    let currScope = scopeRoot;\n    let globalMap = new Map();\n\n    function enterScope() {\n        currScope = { parent: currScope, names: new Map() };\n    }\n\n    function exitScope() {\n        currScope = currScope.parent;\n    }\n\n    let ID_NAME = 0;\n    let TYPE_NAME = 1;\n    let TEMPLATE_FUNC_NAME = 2;\n    let TEMPLATE_CLASS_NAME = 3;\n\n    function getTypeOfName(name, type) {\n        let c = currScope;\n        while(c != null) {\n            if (c.names.has(name)) {\n                return c.names.get(name);\n            }\n            c = c.parent;\n        }\n        if(globalMap.has(name)){\n            return globalMap.get(name);\n        }\n        return ID_NAME;\n    }\n}\nStart = TranslationUnit\nClassSpecifier\n    = classKey:ClassKeyword _ identifier:TypeDeclarationIdentifier _ ih:BaseClause? _ ScopeStart _ declarations:StructDeclarationList? _ ScopeEnd {\n        return new AST.ClassSpecifier(getLocation(), classKey, identifier, declarations || [] , ih || []);\n    }\n    / classKey:ClassKeyword _ identifier:TypeDeclarationIdentifier {\n        return new AST.ClassSpecifier(getLocation(), classKey, identifier, null, []);\n    }\n\nClassKeyword\n    = ('struct' / 'class' / 'union') !IdentifierPart {\n        return text();\n    }\n\nBaseSpecifier\n    = lb:AccessControlKey? _ className:TypeIdentifier{\n        return new AST.BaseSpecifier(getLocation(), lb || \"\", className);\n    }\n\nBaseClause\n    = ':' _ head:BaseSpecifier tail:(_ ',' _ BaseSpecifier)* {\n        return buildList(head, tail, 1);\n    }\n\nStructDeclarationList\n    = head:StructDeclaration tail:(_ StructDeclaration)* {\n        return buildList(head, tail, 1);\n    }\n\nAccessControlKey = 'public' / 'private' / 'protect'\n\nStructDeclaration\n    = id:TypeIdentifier _ '(' _ param:ParameterList? _ ')' _ initList:ConstructorInitializeList? _ body:CompoundStatement{\n        return new AST.ConstructorDeclaration(getLocation(), id, param || new AST.ParameterList(getLocation()), initList || [], body);\n    }\n    / id:TypeIdentifier _ '(' _ param:ParameterList? _ ')' _ initList:ConstructorInitializeList? _ ';'{\n        return new AST.ConstructorDeclaration(getLocation(), id, param || new AST.ParameterList(getLocation()), initList || [], nul);\n    }\n    / isVirtual:'virtual'? _ '~' id:TypeIdentifier _ '(' _ ')' _ body:CompoundStatement{\n        return new AST.DestructorDeclaration(getLocation(), id, body, isVirtual === \"virtual\");\n    }\n    / isVirtual:'virtual'? _ '~' id:TypeIdentifier _ '(' _ ')' _ ';'{\n        return new AST.DestructorDeclaration(getLocation(), id, null, isVirtual === \"virtual\");\n    }\n    / label:AccessControlKey _ ':' {\n        return new AST.AccessControlLabel(getLocation(), label);\n    }\n    / decl:Declaration {\n        return decl;\n    }\n\nConstructorInitializeList\n    = ':' _ head:ConstructorInitializeItem _ tail:(_ ',' _ ConstructorInitializeItem)* {\n         return buildList(head, tail, 3);\n    }\n\nConstructorInitializeItem\n    = key:Identifier _ '(' _ value:ArgumentExpressionList _ ')' {\n        return new AST.ConstructorInitializeItem(getLocation(), key, value, false);\n    }\n    / key:TypeIdentifier _ '(' _ value:ArgumentExpressionList _ ')' {\n        return new AST.ConstructorInitializeItem(getLocation(), key, value, true);\n    }\n\n\nStructDeclaratorList\n    = head:StructDeclarator tail:(_ ',' _ StructDeclarator)* {\n        return buildList(head, tail, 3);\n    }\n\nStructDeclarator\n    = ':' _ width:ConstantExpression {\n        return new AST.StructDeclarator(getLocation(), null, width, null);\n    }\n    / declarator:Declarator _ initDeclarators:InitDeclaratorList? width:(_ ':' _ ConstantExpression)? {\n        return new AST.StructDeclarator(getLocation(), declarator, extractOptional(width, 3), initDeclarators);\n    }\n\nEnumSpecifier\n    = 'enum' !IdentifierPart _ identifier:Identifier? _ '{' _ enumerators:EnumeratorList _ ','? _ &!'}' {\n        return new AST.EnumSpecifier(getLocation(), identifier, enumerators);\n    }\n    / 'enum' !IdentifierPart _ identifier:Identifier {\n        return new AST.EnumSpecifier(getLocation(), identifier, null);\n    }\n\nEnumeratorList\n    = head:Enumerator tail:(_ comma:','? _ enumerator:Enumerator)* {\n        return buildList(head, tail, 3);\n    }\n\n// MODIFICATION: EnumerationConstant => Identifier\nEnumerator\n    = identifier:Identifier value:(_ '=' _ ConstantExpression)? {\n        return new AST.Enumerator(getLocation(), identifier, extractOptional(value, 3));\n    }\n\n\nConstant\n    = FloatingConstant\n    / IntegerConstant\n    / CharacterConstant\n\nIntegerConstant\n    // REORDER: HexadecimalConstant / OctalConstant\n    = integer:(constant:(DecimalConstant / HexadecimalConstant / OctalConstant) {\n        return {\n            base: constant.base,\n            value: constant.value,\n            raw: text()\n        }\n        }) suffix:$IntegerSuffix? {\n        if (suffix.toLowerCase().includes('u')) {\n            integer.value.unsigned = true;\n        }\n        return new AST.IntegerConstant(getLocation(), integer.base, integer.value, integer.raw, suffix || null);\n    }\n\nDecimalConstant\n    = NonzeroDigit Digit* {\n        // SAFE_NUMBER: Using Long.\n        return {\n            base: 10,\n            value: Long.fromString(text())\n        };\n    }\n\nOctalConstant\n    = '0' digits:$OctalDigit* {\n        // SAFE_NUMBER: Using Long.\n        return {\n            base: 8,\n            value: digits.length ? Long.fromString(digits, 8) : Long.ZERO\n        };\n    }\n\nHexadecimalConstant\n    = HexadecimalPrefix digits:$HexadecimalDigit+ {\n        // SAFE_NUMBER: Using Long.\n        return {\n            base: 16,\n            value: Long.fromString(digits, 16)\n        };\n    }\n\nFloatingConstant\n    = DecimalFloatingConstant\n\nDecimalFloatingConstant\n    = raw:$((FractionalConstant ExponentPart?) / (DigitSequence ExponentPart)) suffix:$FloatingSuffix? {\n        return new AST.FloatingConstant(getLocation(), Number.parseFloat(raw), raw, suffix || null);\n    }\n\nHexadecimalFractionalConstant\n    = HexadecimalDigitSequence '.' HexadecimalDigitSequence?\n    / '.' HexadecimalDigitSequence\n\nCharacterConstant\n    = prefix:$[LuU]? '\\\\'' value:CCharSequence '\\\\'' {\n        return new AST.CharacterConstant(getLocation(), value, prefix || null);\n    }\n\nEncodingPrefix\n    = 'u8'\n    / 'u'\n    / 'U'\n    / 'L'\n\nUniversalCharacterName\n    = '\\\\\\\\u' hexQuad:$HexQuad {\n        return parseUniversalCharacter(hexQuad);\n    }\n    / '\\\\\\\\U' hexQuads:$(HexQuad HexQuad) {\n        return parseUniversalCharacter(hexQuads);\n    }\n\nHexQuad\n    = HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit\n\nStringLiteral\n    = head:SingleStringLiteral tail:(_ SingleStringLiteral)* {\n        return buildList(head, tail, 1).reduce((left, right) => {\n            let prefix = null;\n            if (left.prefix !== right.prefix) {\n                if (left.prefix) {\n                    if (right.prefix) {\n                        error('Unsupported non-standard concatenation of string literals');\n                    } else {\n                        prefix = left.prefix;\n                    }\n                } else {\n                    prefix = right.prefix;\n                }\n            } else {\n                prefix = left.prefix;\n            }\n            const value = left.value.slice(0, -1) + right.value;\n            return new AST.StringLiteral(getLocation(), prefix, value);\n        });\n    }\n\nSingleStringLiteral\n    = prefix:$EncodingPrefix? '\"' value:SCharSequence? &!'\"' {\n        return new AST.StringLiteral(getLocation(), prefix || null, (value || '') + '\\\\0');\n    }\n\nSCharSequence\n    = chars:SChar+ {\n        return chars.join('');\n    }\n\nSChar\n    = [^\"\\\\\\\\\\\\n] // any member of the source character set except the double-quote \", backslash \\\\, or new-line character\n    / EscapeSequence\n\nUnaryOperator\n    = [*+\\\\-~!]\n    / SingleAnd\n\nCCharSequence\n    = chars:CChar+ {\n        return chars.join('');\n    }\n\nCChar\n    = [^'\\\\\\\\\\\\n] // any member of the source character set except the single-quote ', backslash \\\\, or new-line character\n    / EscapeSequence\n\nEscapeSequence\n    = SimpleEscapeSequence\n    / OctalEscapeSequence\n    / HexadecimalEscapeSequence\n    / UniversalCharacterName\n\nSimpleEscapeSequence\n    = ('\\\\\\\\\\\\''\n    / '\\\\\\\\\"'\n    / '\\\\\\\\?'\n    / '\\\\\\\\\\\\\\\\') {\n        return text().charAt(1);\n    }\n    / '\\\\\\\\a' {\n        return '\\\\x07';\n    }\n    / '\\\\\\\\b' {\n        return '\\\\b';\n    }\n    / '\\\\\\\\f' {\n        return '\\\\f';\n    }\n    / '\\\\\\\\n' {\n        return '\\\\n';\n    }\n    / '\\\\\\\\r' {\n        return '\\\\r';\n    }\n    / '\\\\\\\\t' {\n        return '\\\\t';\n    }\n    / '\\\\\\\\v' {\n        return '\\\\v';\n    }\n\nOctalEscapeSequence\n    = '\\\\\\\\' digits:$(OctalDigit OctalDigit? OctalDigit?) {\n        // SAFE_NUMBER: At most 0777.\n        return String.fromCharCode(Number.parseInt(digits, 8));\n    }\n\nHexadecimalEscapeSequence\n    = '\\\\\\\\x' digits:$HexadecimalDigit+ {\n        // TODO: Guard against very long digits.\n        return String.fromCharCode(Number.parseInt(digits, 16));\n    }\n\nBinaryExponentPart\n    = [pP] Sign? DigitSequence\n\nHexadecimalDigitSequence\n    = HexadecimalDigit+\n\nFloatingSuffix\n    = [flFL]\n\nFractionalConstant\n    = DigitSequence '.' DigitSequence?\n    / '.' DigitSequence\n\nExponentPart\n    = [eE] Sign? DigitSequence\n\nSign\n    = [+\\\\-]\n\nDigitSequence\n    = Digit+\n\nTranslationUnit\n    = list:DeclarationList{\n        return new AST.TranslationUnit(getLocation(), list);\n    }\n\nDeclarationList\n    = _ head:Declaration tail:(_ Declaration)* _ {\n        return buildList(head, tail, 1);\n    }\n\nDeclaration\n    = BlockDeclaration\n    / FunctionDefinition\n    / NamespaceDefinition\n    / TemplateDeclaration\n    / ExplicitInstantiation\n    / DeclarationMissingSemicolon\n\nBlockDeclaration\n    = SimpleDeclaration\n    / UsingStatements\n\nBlockDeclarationList\n    = head:BlockDeclaration tail:(_ BlockDeclaration)*{\n        return buildList(head, tail, 1);\n    }\n\nNamespaceDefinition\n    = 'namespace' _ name:Identifier _ '{' _ list:DeclarationList? _'}'{\n        currScope.names.set(name.getLastID().name, TYPE_NAME);\n        return new AST.NameSpaceBlock(getLocation(), name, list || []);\n    }\n\nSimpleDeclaration\n    = specifiers:DeclarationSpecifiers _ initDeclarators:InitDeclaratorList? _ ';' {\n        const declaration = new AST.Declaration(getLocation(), specifiers, initDeclarators || []);\n        declaration.getTypedefName().map(name => currScope.names.set(name, TYPE_NAME));\n        return declaration;\n    }\n\nDeclarationSpecifiers\n    = head:DeclarationSpecifier tail:(_ DeclarationSpecifier)* {\n        return new AST.SpecifierList(getLocation(), buildList(head, tail, 1));\n    }\n\nDeclarationSpecifier\n    = StorageClassSpecifier\n    / FunctionSpecifier\n    / TypeSpecifier\n\nTypeSpecifierList\n    = head:TypeSpecifier tail:( _ TypeSpecifier)* {\n        return buildList(head, tail, 3);\n    }\n\nTypeSpecifier\n    = ClassSpecifier\n    / EnumSpecifier\n    / SimpleTypeSpecifier\n    / TypenameSpecifier\n    / TypeQualifier\n\nSimpleTypeSpecifier\n    = PrimitiveTypeSpecifier\n    / TypeIdentifier\n\nTypenameSpecifier\n    = 'typename' id:TypeIdentifier{\n        return id;\n    }\n\nTypeQualifier\n    = ('const' / 'volatile') !IdentifierPart {\n        return text();\n    }\n\nTypeQualifierList\n    = head:TypeQualifier tail:(_ TypeQualifier)* {\n        return buildList(head, tail, 1);\n    }\n\nDeclarator\n    = pointer:(Pointer _)? declarator:DirectDeclarator {\n        return pointer ? new AST.PointerDeclarator(getLocation(), declarator, extractOptional(pointer, 0)) : declarator;\n    }\n\nDirectDeclarator\n    = head:(identifier:Identifier {\n        return new AST.IdentifierDeclarator(getLocation(), identifier);\n    } / '(' _ declarator:Declarator _ ')' {\n        return declarator;\n    } ) tail:(_ (\n        '[' _ length:AssignmentExpression? _ &!']' {\n            return {\n                location: getLocation(),\n                type: AST.ArrayDeclarator,\n                arguments: [false, [], length, false]\n            };\n        }\n        / '(' _ parameters: ParameterList? _ ')' {\n            return {\n                location: getLocation(),\n                type: AST.FunctionDeclarator,\n                arguments: [parameters || new AST.ParameterList(getLocation())]\n            }\n        }\n    ))* {\n        return extractList(tail, 1).reduce((result, element) => new element.type(element.location, result, ...element.arguments), head);\n    }\n\nPointer\n    = '*' _ qualifiers:TypeQualifierList? _ pointer:Pointer? {\n        return new AST.Pointer(getLocation(), qualifiers || [], pointer, '*');\n    }\n    /\n    '&' _ qualifiers:TypeQualifierList? _ pointer:Pointer? {\n        return new AST.Pointer(getLocation(), qualifiers || [], pointer, '&');\n    }\n    /\n    '&&' _ qualifiers:TypeQualifierList? _ pointer:Pointer? {\n        return new AST.Pointer(getLocation(), qualifiers || [], pointer, '&&');\n    }\n\nDeclarationWithoutSemicolon\n    = specifiers:DeclarationSpecifiers _ initDeclarators:InitDeclaratorList?\n\nDeclarationMissingSemicolon\n    = decl:DeclarationWithoutSemicolon {\n        error('Missing \\\\';\\\\' at end of declaration');\n    }\n\nFunctionSpecifier = ('inline' / '__libcall')\n\nInitDeclaratorList\n    = head:InitDeclarator tail:(_ ',' _ InitDeclarator)* {\n        return buildList(head, tail, 3);\n    }\n\nInitDeclarator\n    = declarator:Declarator initializer:CppInitializer? {\n        return new AST.InitDeclarator(getLocation(), declarator, initializer || null);\n    }\n    \nCppInitializer\n    = _'=' _ init:Initializer{\n        return init;\n    }\n    / _ '(' _ arguments_:ArgumentExpressionList? _ ')' {\n        return new AST.ObjectInitializer(getLocation(),  arguments_ || []);  \n    }\n\n\nParameterList\n    = head:ParameterDeclaration tail:(_ ',' _ ParameterDeclaration)* ellipsis:(_ ',' _ '...')? {\n        return new AST.ParameterList(getLocation(), buildList(head, tail, 3), !!ellipsis);\n    }\n\nParameterDeclaration\n    = specifiers:DeclarationSpecifiers _ declarator:(Declarator / AbstractDeclarator)? init:( _ '=' _ AssignmentExpression)?{\n        return new AST.ParameterDeclaration(getLocation(), specifiers, declarator, init ? init[3] : null);\n    }\n\nIdentifierList\n    = head:Identifier tail:(_ ',' _ Identifier)* {\n        return buildList(head, tail, 3);\n    }\n\n\nInitializer\n    = AssignmentExpression\n    / '{' _ initializerList:InitializerList _ ','? _ &!'}' {\n        return initializerList;\n    }\n\nInitializerList\n    = head:InitializerListItem tail:(_ ',' _ InitializerListItem)* {\n        return new AST.InitializerList(getLocation(), buildList(head, tail, 3));\n    }\n\nInitializerListItem\n    = designators:(Designation _)? initializer:Initializer {\n        return new AST.InitializerListItem(getLocation(), initializer);\n    }\n\nDesignation\n    = designators:DesignatorList _ '=' {\n        return designators;\n    }\n\nDesignatorList\n    = head:Designator tail:(_ Designator)* {\n        return buildList(head, tail, 1);\n    }\n\nDesignator\n    = '[' _ subscript:ConstantExpression _ &!']' {\n        return new AST.SubscriptDesignator(getLocation(), subscript);\n    }\n    / '.' _ member:Identifier {\n        return new AST.MemberDesignator(getLocation(), member);\n    }\n\nFunctionDefinition\n    = specifiers:DeclarationSpecifiers _ declarator:Declarator _ body:CompoundStatement {\n        return new AST.FunctionDefinition(getLocation(), specifiers, declarator, body);\n    }\n\nNewTypeName\n    =  specifierQualifiers:DeclarationSpecifiers _ declarator:NewDeclarator? {\n        return new AST.TypeName(getLocation(), specifierQualifiers, declarator)\n    }\n\nTypeName\n    = specifierQualifiers:DeclarationSpecifiers _ declarator:AbstractDeclarator? {\n        return new AST.TypeName(getLocation(), specifierQualifiers, declarator)\n    }\n\nNewDeclarator\n    = pointer:Pointer declarator:(_ DirectNewDeclarator)? {\n        return new AST.PointerDeclarator(getLocation(), null, pointer, extractOptional(declarator, 1));\n    }\n    / declarator:DirectNewDeclarator {\n        return declarator;\n    }\n\nAbstractDeclarator\n    = pointer:Pointer declarator:(_ DirectAbstractDeclarator)? {\n        return new AST.PointerDeclarator(getLocation(), null, pointer, extractOptional(declarator, 1));\n    }\n    / declarator:DirectAbstractDeclarator {\n        return declarator;\n    }\n\nDirectNewDeclarator\n    = head:(element:DirectNewDeclaratorElement {\n            return new element.type(getLocation(), null, ...element.arguments)\n        }\n    ) tail:(_ DirectNewDeclaratorElement)* {\n        return extractList(tail, 1).reduce((result, element) => new element.type(element.location, result, ...element.arguments), head);\n    }\n\nDirectAbstractDeclarator\n    = head:(\n        '(' _ declarator:AbstractDeclarator _ ')' {\n            return declarator;\n        }\n        / element:DirectAbstractDeclaratorElement {\n            return new element.type(getLocation(), null, ...element.arguments)\n        }\n    ) tail:(_ DirectAbstractDeclaratorElement)* {\n        return extractList(tail, 1).reduce((result, element) => new element.type(element.location, result, ...element.arguments), head);\n    }\n\nDirectNewDeclaratorElement\n    = '[' _ length:AssignmentExpression? _ &!']' {\n        return {\n            location: getLocation(),\n            type: AST.ArrayDeclarator,\n            arguments: [false, [], length, false]\n        };\n    }\n\nDirectAbstractDeclaratorElement\n    = '(' _ parameters:ParameterList? _ ')' {\n        return {\n            location: getLocation(),\n            type: AST.FunctionDeclarator,\n            arguments: [parameters || new AST.ParameterList(getLocation())]\n        }\n    }\n    / DirectNewDeclaratorElement\nTryBlock\n    = 'try' _ body:CompoundStatement _ handlers:HandlerSeq {\n        return new AST.TryBlock(getLocation(), body, handlers);\n    }\n\nHandlerSeq\n    = head:ExceptionHandler tail:(_ ExceptionHandler)* {\n        return buildList(head, tail, 1);\n    }\n\nExceptionHandler\n    = 'catch' _ '(' _ decl:ExceptionDeclaration _ ')' _ body:CompoundStatement {\n        return new AST.ExceptionHandler(getLocation(), decl, body);\n    }\n\nExceptionDeclaration\n \t= specifiers:DeclarationSpecifiers _ declarator:Declarator {\n \t    return new AST.ExceptionDeclaration(getLocation(), specifiers, declarator);\n \t}\n \t/ specifiers:DeclarationSpecifiers _ declarator:AbstractDeclarator {\n \t    return new AST.ExceptionDeclaration(getLocation(), specifiers, declarator);\n \t}\n\nThrowExpression\n \t= 'throw' _ body:AssignmentExpression? {\n \t    return new AST.ThrowExpression(getLocation(), body);\n \t}\nExpression\n    = head:AssignmentExpression tail:(_ ',' _ AssignmentExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nAssignmentExpression\n    = left:UnaryExpression _ operator:AssignmentOperator _ right:AssignmentExpression {\n        return new AST.AssignmentExpression(getLocation(), operator, left, right);\n    }\n    / ConditionalExpression\n\nConditionalExpression\n    = test:LogicalOrExpression _ '?' _ consequent:Expression _ &!':' _ alternate:ConditionalExpression {\n        return new AST.ConditionalExpression(getLocation(), test, consequent, alternate);\n    }\n    / LogicalOrExpression\n\n\nConstructorCallExpression\n    = name:TypeIdentifier  _ '(' _ arguments_:ArgumentExpressionList? _ &!')' {\n        return new AST.ConstructorCallExpression(getLocation(), name, arguments_ || []);\n    }\n\nPostfixExpression\n    = head:( PrimaryExpression / ConstructorCallExpression ) tail:(_ (\n        '[' _ subscript:Expression _ &!']' {\n            return {\n                type: AST.SubscriptExpression,\n                arguments: [subscript]\n            };\n        }\n        / '(' _ arguments_:ArgumentExpressionList? _ ')' {\n            return {\n                type: AST.CallExpression,\n                arguments: [arguments_ || []]\n            };\n        }\n        / operator:('.' / '->') _ member:Identifier {\n            return {\n                type: AST.MemberExpression,\n                arguments: [operator === '->', member]\n            };\n        }\n        / operator:('++' / '--') {\n            return {\n                type: AST.PostfixExpression,\n                arguments: [operator === '--']\n            };\n        }\n    ))* {\n        return extractList(tail, 1).reduce((result, element) => new element.type(getLocation(), result, ...element.arguments), head);\n    }\n\nArgumentExpressionList\n    = head:AssignmentExpression tail:(_ ',' _ AssignmentExpression)* {\n        return buildList(head, tail, 3);\n    }\n\nUnaryExpression\n    = operator:('++' / '--') _ operand:UnaryExpression {\n        return new AST.UnaryExpression(getLocation(), operator, operand);\n    }\n    / operator:UnaryOperator _ operand:CastExpression { //Hack: when parse '&' operator, the operator variable will be array of 2 elements\n        return new AST.UnaryExpression(getLocation(), operator[0], operand);\n    }\n    / operator:'sizeof' !IdentifierPart _ operand:UnaryExpression {\n        return new AST.UnaryExpression(getLocation(), operator, operand);\n    }\n    / operator:'sizeof' _ '(' _ operand:TypeName _ ')' {\n        return new AST.UnaryExpression(getLocation(), operator, operand);\n    }\n    / PostfixExpression\n    / NewExpression\n    / DeleteExpression\n\nCastExpression\n    = '(' _ typeName:TypeName _ ')' _ operand:CastExpression {\n        return new AST.CastExpression(getLocation(), typeName, operand);\n    }\n    / UnaryExpression\n\nMultiplicativeExpression\n    = head:CastExpression tail:(_ [*/%] _ CastExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nAdditiveExpression\n    = head:MultiplicativeExpression tail:(_ [+\\\\-] _ MultiplicativeExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nShiftExpression\n    = head:AdditiveExpression tail:(_ ('<<' / '>>') _ AdditiveExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nRelationalExpression\n    = head:ShiftExpression tail:(_ ('<=' / '>=' / '<' / '>') _ ShiftExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nEqualityExpression\n    = head:RelationalExpression tail:(_ ('==' / '!=') _ RelationalExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nAndExpression\n    = head:EqualityExpression tail:(_ SingleAnd _ EqualityExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nExclusiveOrExpression\n    = head:AndExpression tail:(_ '^' _ AndExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nInclusiveOrExpression\n    = head:ExclusiveOrExpression tail:(_ '|' _ ExclusiveOrExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nLogicalAndExpression\n    = head:InclusiveOrExpression tail:(_ AndAnd _ InclusiveOrExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nLogicalOrExpression\n    = head:LogicalAndExpression tail:(_ '||' _ LogicalAndExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nConstantExpression\n    = ConditionalExpression\n\nPrimaryExpression\n    = Identifier\n    / Constant\n    / StringLiteral\n    / '(' _ expression:Expression _ &!')' {\n        return expression;\n    }\n\n\n\nNewPlacement\n    = '(' _  item:AssignmentExpression _ ')' {\n        return item;\n    }\n\nNewInitializer\n    = '(' _ arguments_:ArgumentExpressionList? _ ')' {\n        return arguments_;\n    }\n\nNewExpression\n    = '::'? 'new' !IdentifierPart _ placement:NewPlacement? _ type:NewTypeName _ initializer:NewInitializer?{\n        return new AST.NewExpression(getLocation(), type, initializer || [], placement || null);\n    }\n    / '::'? 'new' !IdentifierPart _ placement:NewPlacement? _ '(' _ name:TypeName _ ')' _ initializer:NewInitializer?{\n        return new AST.NewExpression(getLocation(), type, initializer || [], placement || null);\n    }\n\nDeleteExpression\n    = 'delete' _ expr:AssignmentExpression {\n        return new AST.DeleteExpression(getLocation(), expr, false);\n    }\n    / 'delete[]' _ expr:AssignmentExpression {\n        return new AST.DeleteExpression(getLocation(), expr, true);\n    }\nId\n    = !Keyword head:IdentifierNondigit tail:IdentifierPart* {\n        return new AST.SingleIdentifier(getLocation(), head + tail.join(''), AST.IDType.ID, []);\n    }\n\nSingleIdentifier\n    = id:Id &{\n        return getTypeOfName(id.name) === ID_NAME;\n    } {\n        return id;\n    }\n    / 'operator' _ ope:OverloadOperator {\n        return new AST.SingleIdentifier(getLocation(), \"#\" + ope, AST.IDType.ID, []);\n    }\n    / '~' name:TypeIdentifier {\n        const result = name.clone();\n        result.getLastID().name = '~' + result.identifier.name;\n        result.getLastID().type = AST.IDType.TYPE;\n        return result;\n    }\n\nSingleTypeIdentifier\n    =  id:Id &{\n        return getTypeOfName(id.name) === TYPE_NAME;\n    } {\n        id.type = AST.IDType.TYPE;\n        return id;\n    }\n\nSingleTemplateFuncIdentifier\n    =  id:Id &{\n        return getTypeOfName(id.name) === TEMPLATE_FUNC_NAME;\n    } {\n        id.type = AST.IDType.T_FUNC;\n        return id;\n    }\n\nSingleTemplateClassIdentifier\n    =  id:Id &{\n        return getTypeOfName(id.name) === TEMPLATE_CLASS_NAME;\n    } {\n        id.type = AST.IDType.T_CLASS;\n        return id;\n    }\n\nUnifiedIdentifier\n    = SingleTypeIdentifier/ TemplateClassInstanceIdentifier\n\nIdentifier\n    = isFullName:'::'? namespace:(UnifiedIdentifier '::')* name:(SingleIdentifier/TemplateFuncInstanceIdentifier) {\n        return new AST.Identifier(getLocation(), namespace.map(x=>x[0]).concat([name]), isFullName);\n    }\n\nTypeIdentifier\n    = isFullName:'::'? namespace:(UnifiedIdentifier '::')* name:UnifiedIdentifier {\n        return new AST.Identifier(getLocation(), namespace.map(x=>x[0]).concat([name]), isFullName);\n    }\n\nTemplateFuncIdentifier\n    = isFullName:'::'? namespace:(UnifiedIdentifier '::')* name:SingleTemplateFuncIdentifier {\n        return new AST.Identifier(getLocation(), namespace.map(x=>x[0]).concat([name]), isFullName);\n    }\n\nTemplateClassIdentifier\n    = isFullName:'::'? namespace:(SingleTypeIdentifier '::')* name:SingleTemplateClassIdentifier {\n        return new AST.Identifier(getLocation(), namespace.map(x=>x[0]).concat([name]), isFullName);\n    }\n\nTypeDeclarationIdentifier\n    = identifier:Identifier{\n        if( options.isCpp ) {\n            globalMap.set(identifier.getLastID().name, TYPE_NAME);\n            currScope.names.set(identifier.getLastID().name, TYPE_NAME);\n        }\n        return identifier;\n    }\n\nWhiteSpace = [ \\\\t\\\\n\\\\v\\\\f]\n\n_ = WhiteSpace*\n\nKeyword\n    = ('auto'\n    / 'break'\n    / 'case'\n    / 'char'\n    / 'const'\n    / 'continue'\n    / 'default'\n    / 'double'\n    / 'do'\n    / 'else'\n    / 'enum'\n    / 'extern'\n    / 'float'\n    / 'for'\n    / 'goto'\n    / 'if'\n    / 'inline'\n    / 'int'\n    / 'long'\n    / 'register'\n    / 'restrict'\n    / 'return'\n    / 'short'\n    / 'signed'\n    / 'sizeof'\n    / 'static'\n    / 'struct'\n    / 'switch'\n    / 'typedef'\n    / 'union'\n    / 'unsigned'\n    / 'void'\n    / 'volatile'\n    / 'while'\n    / 'class'\n    / 'new'\n    / 'delete'\n    / 'operator'\n    / 'override'\n    / 'template'\n    / 'typename'\n    / 'namespace'\n    / 'using') !IdentifierPart\n\nStorageClassSpecifier\n    = ('typedef'\n    / 'extern'\n    / 'static'\n    / 'virtual'\n    / 'auto'\n    / 'register') !IdentifierPart {\n        return text();\n    }\n\nPrimitiveTypeSpecifier\n    = ('void'\n    / 'char'\n    / 'short'\n    / 'int'\n    / 'long'\n    / 'float'\n    / 'double'\n    / 'signed'\n    / 'unsigned'\n    / 'bool') !IdentifierPart {\n        return text();\n     }\n\nOverloadOperator\n    = '+' / '-' / '*' / '/' / '%' / '&' / '<' / '>' / '<=' / '>=' / '==' / '!='\n    / '|' / '^' / '!' / '~' / '&&' / '||' / '>>' / '<<' / '++' / '--'\n    /'()' / '[]' / '->'\n    / AssignmentOperator\n\nAssignmentOperator\n    = '=' !'=' {\n        return text();\n    }\n    / '*='\n    / '/='\n    / '%='\n    / '+='\n    / '-='\n    / '<<='\n    / '>>='\n    / '&='\n    / '^='\n    / '|='\n\nAndAnd\n    = '&&'\n\nSingleAnd\n    = '&'!'&'\n\nHexadecimalPrefix\n    = '0x'\n    / '0X'\n\nNonzeroDigit\n    = [1-9]\n\nOctalDigit\n    = [0-7]\n\nHexadecimalDigit\n    = [0-9a-fA-F]\n\nIntegerSuffix\n    = UnsignedSuffix (LongLongSuffix / LongSuffix)?\n    / (LongLongSuffix / LongSuffix) UnsignedSuffix?\n\nUnsignedSuffix\n    = [uU]\n\nLongSuffix\n    = [lL]\n\nLongLongSuffix\n    = 'll'\n    / 'LL'\n\nIdentifierPart\n    = IdentifierNondigit\n    / Digit\n\nIdentifierNondigit\n    = UniversalCharacterName\n    / Nondigit\n\nNondigit\n    = [_a-zA-Z]\n\nDigit\n    = [0-9]\n\nStatement\n    = CaseStatement\n    / SelectionStatement\n    / IterationStatement\n    / JumpStatement\n    / CompoundStatement\n    / LabeledStatement\n    / ExpressionStatement\n    / UsingStatements\n\n// ADDED\nCaseStatement\n    = 'case' !IdentifierPart _ test:ConstantExpression _ &!':' _ body:Statement {\n        return new AST.CaseStatement(getLocation(), test, body);\n    }\n    / 'default' !IdentifierPart _ &!':' _ body:Statement {\n        return new AST.CaseStatement(getLocation(), null, body)\n    }\n\n// MODIFICATION: No case or default.\nLabeledStatement\n    = label:Identifier _ ':' _ body:Statement {\n        return new AST.LabeledStatement(getLocation(), label, body);\n    }\n\nScopeStart\n    = '{' {\n        enterScope();\n        return getLocation();\n    }\n\nScopeEnd\n    = &!'}' {\n        exitScope();\n        return getLocation();\n    }\n\nCompoundStatement\n    = left:ScopeStart _ body:BlockItemList? _ right:ScopeEnd {\n        return new AST.CompoundStatement(getLocation(), body || []);\n    }\n\nBlockItemList\n    = head:BlockItem tail:(_ BlockItem)* {\n        return buildList(head, tail, 1);\n    }\n\nBlockItem\n    = Statement\n    / Declaration\n    / Expression { // ExpressionStatementMissingSemicolon\n        error('Missing \\\\';\\\\' at end of statement');\n    }\n    / DeclarationMissingSemicolon\n\nExpressionStatement\n    = expression:(Expression _)? ';' {\n        return expression ? new AST.ExpressionStatement(getLocation(), extractOptional(expression, 0))\n                : new AST.NullStatement(getLocation());\n    }\n\nSelectionStatement\n    = 'if' !IdentifierPart _ &!'(' _ test:Expression _ &!')' _ consequent:Statement alternate:(_ 'else' !IdentifierPart _ Statement)? {\n        return new AST.IfStatement(getLocation(), test, consequent, extractOptional(alternate, 4));\n    }\n    / 'switch' !IdentifierPart _ &!'(' _ discriminant:Expression _ &!')' _ body:Statement {\n        return new AST.SwitchStatement(getLocation(), discriminant, body);\n    }\n\nIterationStatement\n    = 'while' !IdentifierPart _ &!'(' _ test:Expression _ &!')' _ body:Statement {\n        return new AST.WhileStatement(getLocation(), test, body);\n    }\n    / 'do' !IdentifierPart _ body:Statement _ 'while' !IdentifierPart _ &!'(' _ test:Expression _ &!')' _ &!';' {\n        return new AST.DoWhileStatement(getLocation(), body, test);\n    }\n    / 'for' !IdentifierPart _ &!'(' _ init:(Declaration / expression:Expression? _ ';' {\n        return expression;\n    } / (DeclarationWithoutSemicolon / Expression) {\n        error('Missing \\\\';\\\\'');\n    }) _ test:Expression? _ &!';' _ update:Expression? _ &!')' _ body:Statement {\n        return new AST.ForStatement(getLocation(), init, test, update, body);\n    }\n\nJumpStatement\n    = 'goto' !IdentifierPart _ label:Identifier _ &!';' {\n        return new AST.GotoStatement(getLocation(), label);\n    }\n    / 'continue' !IdentifierPart _ &!';' {\n        return new AST.ContinueStatement(getLocation());\n    }\n    / 'break' !IdentifierPart _ &!';' {\n        return new AST.BreakStatement(getLocation());\n    }\n    / 'return' !IdentifierPart _ argument:Expression? _ &!';' {\n        return new AST.ReturnStatement(getLocation(), argument);\n    }\n\n\nUsingStatements\n    = 'using' _ name:Identifier _ '=' _ decl:TypeName _ ';'{\n        currScope.names.set(name.getLastID().name, TYPE_NAME);\n        return new AST.UsingStatement(getLocation(), name, decl);\n    }\n    / 'using' _ name:(Identifier/TypeIdentifier/TemplateClassIdentifier/TemplateFuncIdentifier) _ ';'{\n        return new AST.UsingStatement(getLocation(), name);\n    }\n    / 'using' _ 'namespace' _ name:TypeIdentifier _ ';'{\n        return new AST.UsingNamespaceStatement(getLocation(), name);\n    }\nTemplateDeclaration\n    = 'template' _ '<' _ &{\n        enterScope();\n        return true;\n    } param:TemplateParameterList? _ &!'>' _ decl:(ClassSpecifierWithSemi/FunctionDefinition) {\n        exitScope();\n        const result = new AST.TemplateDeclaration(getLocation(), decl, param || []);\n        const names = result.getTemplateNames();\n        const typeId = (decl instanceof AST.FunctionDefinition) ? TEMPLATE_FUNC_NAME : TEMPLATE_CLASS_NAME;\n        names.map(name => {currScope.names.set(name, typeId);\n        if(typeId === TEMPLATE_CLASS_NAME) globalMap.set(name, typeId);});\n        return result;\n    }\n\nClassSpecifierWithSemi\n    = id:ClassSpecifier _ ';' {\n        return id;\n    }\n\nTemplateParameterList\n    = head:TemplateParameter tail:(_ ',' _ TemplateParameter)* {\n        return buildList(head, tail, 3);\n    }\n\nTemplateParameter\n    = TypeParameter\n    / ParameterDeclaration;\n\nTypeNameKeyword = 'class' / 'typename'\n\n// TODO:: identifier is optional?\nTypeParameter\n    = TypeNameKeyword _ id:TypeDeclarationIdentifier init:( _ '=' _ TypeName)? {\n        return new AST.TypeParameter(getLocation(), id, init ? init[3] : null);\n    }\n\nTemplateFuncInstanceIdentifier\n    = id:SingleTemplateFuncIdentifier opt:(_ '<' _ TemplateArgumentList? _ &!'>' _ )? {\n        id.type = AST.IDType.T_FUNC_INS;\n        id.args = opt ? (opt[3] || []) : [];\n        return id;\n    }\n\nTemplateClassInstanceIdentifier\n    = id:SingleTemplateClassIdentifier opt:(_ '<' _ TemplateArgumentList? _ &!'>' _ )? {\n        id.type = AST.IDType.T_CLASS_INS;\n        id.args = opt ? (opt[3] || []) : [];\n        return id;\n    }\n\nTemplateArgumentList\n    = head:TemplateArgument tail:(_ ',' _ TemplateArgument)* {\n        return buildList(head, tail, 3);\n    }\n\nTemplateArgument\n    = item:TypeName {\n        return new AST.TemplateArgument(getLocation(), item);\n    }\n    / item:AdditiveExpression {\n        return new AST.TemplateArgument(getLocation(), item);\n    }\n\nExplicitInstantiation\n    = FunctionTemplateInstantiation\n    / ClassTemplateInstantiation\n\nFunctionTemplateInstantiation\n    = 'template' _ specifiers:DeclarationSpecifiers _ declarator:Declarator _ ';'{\n        return new AST.FunctionTemplateInstantiation(getLocation(), specifiers, declarator);\n    }\n\nClassTemplateInstantiation\n    = 'template' _ spec:ClassSpecifier _ ';'{\n        return new AST.ClassTemplateInstantiation(getLocation(), spec);\n    }`        \n","import * as fs from \"fs\";\nimport * as Long_ from \"long\";\nimport * as PegJs from \"pegjs\";\nimport {SyntaxError, TypeError} from \"../common/error\";\nimport {Node} from \"../common/node\";\nimport * as CTree_ from \"./ast\";\nimport CGrammar from \"./c.lang\";\n\nfunction parseUniversalCharacter(hexSequence: string) {\n    // SAFE_NUMBER: At most 0xFFFFFFFF.\n    const charCode = Number.parseInt(hexSequence, 16);\n    return String.fromCharCode(charCode);\n}\nconst Helper_ = {\n    parseUniversalCharacter,\n};\n\nfunction loadParser(source: string, query: any) {\n    const Long = Long_;\n    const AST = CTree_;\n\n    // cache\n    if ((global as any)[\"window\"] === undefined && fs.existsSync(\"/tmp/\" + query.parserName + \".js\")) {\n        const newCode = fs.readFileSync(\"/tmp/\" + query.parserName + \".js\", \"utf8\");\n        // if( \"TranslationUnitPegParser\" !== query.parserName)\n        // return eval(newCode);\n    }\n    source = source.replace(/&!'((\\\\.|[^'])*)'/g, (match,\n                                                   rule) => `(expected:'${rule}'? {\n        if (!expected) {${rule.includes(\"}\") ? \"/*{*/\" : \"\"}\n            error('Missing \\\\\\'${rule}\\\\\\'');\n        }\n        return expected;\n    })`);\n    query.output = \"source\";\n    query.cache = !!query.cache;\n    query.optimize = query.optimize || \"speed\";\n    query.trace = !!query.trace;\n    if (typeof query.allowedStartRules === \"string\") {\n        query.allowedStartRules = [query.allowedStartRules];\n    }\n\n    const code = PegJs.generate(source, query);\n    // if ((global as any)[\"window\"] === undefined) {\n    //     console.log(\"fuck\");\n    //     fs.writeFileSync(\"/tmp/\" + query.parserName + \".js\", code);\n    // }\n    return eval(code as any);\n}\n\nconst ConstantExpressionPegParser = loadParser(CGrammar,\n    {parserName: \"ConstantExpression\", allowedStartRules: \"ConstantExpression\"});\nconst TranslationUnitPegParser = loadParser(CGrammar,\n    {parserName: \"TranslationUnitPegParser\"});\n\nfunction wrapPegParser(parser: any) {\n    return {\n        parse(source: string, options: any) {\n            try {\n                return parser.parse(source, options);\n            } catch (e) {\n                if (e instanceof parser.SyntaxError) {\n                    throw new SyntaxError(e.message, {\n                        location: e.location as any,\n                    } as Node);\n                } else {\n                    throw e;\n                }\n            }\n        },\n    };\n}\n\nexport const ConstantExpressionParser = wrapPegParser(ConstantExpressionPegParser);\nexport const CParser = wrapPegParser(TranslationUnitPegParser);\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 08/07/2018\n */\nimport {SourceNode} from \"source-map\";\nimport {PreprocessError} from \"../common/error\";\nimport {parseMarco} from \"./index\";\n\nexport interface Marco {\n    name: string;\n    parameters: string[] | null;\n    target: string;\n    parsedTarget: Array<string | number>;\n}\n\nexport interface Position {\n    line: number;\n    column: number;\n}\n\nexport enum PreprocessStatus {\n    ON_IF,\n    ON_ELSE,\n}\n\nexport class PreprocessContext {\n    public node: SourceNode;\n    public sourceFileName: string;\n    public generatedFileName: string;\n    public marcoMap: Map<string, Marco>;\n    public skipBlock: boolean;\n    public status: Array<[PreprocessStatus, boolean]>;\n    public targetLine: number;\n    public targetColumn: number;\n    public onMultiLineComment: boolean;\n\n    constructor(fileName: string, marcoMap: Map<string, Marco>) {\n        this.sourceFileName = fileName;\n        this.generatedFileName = fileName.replace(\".cpp\", \".ii\");\n        this.node = new SourceNode(1, 0, this.generatedFileName);\n        this.marcoMap = marcoMap;\n        this.skipBlock = false;\n        this.status = [];\n        this.targetLine = 0;\n        this.targetColumn = 0;\n        this.onMultiLineComment = false;\n    }\n\n    public defineMarco(name: string, parameters: string[] | null, target: string) {\n        target = target.trim();\n        if (this.marcoMap.has(name)) {\n            throw new PreprocessError(`marco ${name} is already defined`);\n        }\n        if (parameters === null) {\n            const parsedTarget = parseMarco([], target);\n            this.marcoMap.set(name, {name, parameters, target, parsedTarget});\n        } else {\n            const parsedTarget = parseMarco(parameters, target);\n            this.marcoMap.set(name, {name, parameters, target, parsedTarget});\n        }\n\n    }\n\n    public undefineMarco(name: string) {\n        if (!this.marcoMap.has(name)) {\n            throw new PreprocessError(`marco ${name} is not defined`);\n        }\n        this.marcoMap.delete(name);\n    }\n\n    public append(str: string, sourceStartPosition: Position) {\n        this.node.add(new SourceNode(\n            sourceStartPosition.line + 1,\n            sourceStartPosition.column,\n            this.sourceFileName, str));\n    }\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 07/07/2018\n */\nimport {CodeWithSourceMap} from \"source-map\";\nimport {PreprocessError} from \"../common/error\";\nimport {Headers} from \"../library\";\nimport {Marco, Position, PreprocessContext, PreprocessStatus} from \"./context\";\n\nfunction doPreprocessCommand(ctx: PreprocessContext, line: string, lineIdx: number) {\n    const tokens = line.split(/\\s|<|\"/);\n    if (tokens[0] === \"#define\") {\n        if (!ctx.skipBlock) {\n            const match = /#define\\s+([a-zA-Z0-9_]+)\\s*(\\(([^)]*)\\))?\\s*(\\s.+)?\\s*$/.exec(line);\n            if (!match) {\n                throw new PreprocessError(`illegal define: ${line}`);\n            } else if (match[3] && match[4]) {\n                const parameters = match[3].split(\",\").map((x) => x.trim());\n                ctx.defineMarco(match[1], parameters, match[4]);\n            } else if (match[4]) {\n                ctx.defineMarco(match[1], null, match[4]);\n            } else {\n                ctx.defineMarco(match[1], null, \"\");\n            }\n        }\n    } else if (tokens[0] === \"#undef\") {\n        if (!ctx.skipBlock) {\n            if (tokens.length !== 2) {\n                throw new PreprocessError(`illegal undefine: ${line}`);\n            } else {\n                ctx.undefineMarco(tokens[1]);\n            }\n        }\n    } else if (tokens[0] === \"#include\") {\n        if (!ctx.skipBlock) {\n            let fileName = \"\";\n            if (line.includes(\"\\\"\")) {\n                const match = /\"(.*)\"/.exec(line);\n                if (match && match[1]) {\n                    fileName = match[1];\n                } else {\n                    throw new PreprocessError(`illegal include: ${line}`);\n                }\n            } else {\n                const match = /<(.*)>/.exec(line);\n                if (match && match[1]) {\n                    fileName = match[1];\n                } else {\n                    throw new PreprocessError(`illegal include: ${line}`);\n                }\n            }\n            let header = Headers.get(fileName);\n            if (!header) {\n                if (fileName.charAt(0) === \"c\") {\n                    header = Headers.get(fileName.slice(1) + \".h\");\n                }\n                if (!header) {\n                    throw new PreprocessError(`header ${fileName} does not exist`);\n                }\n            }\n            const {code} = doPreprocess(fileName, header, ctx.marcoMap);\n            ctx.append(code, {line: lineIdx, column: 0});\n        }\n    } else if (tokens[0] === \"#if\") {\n        throw new PreprocessError(`unsupport #if`);\n    } else if (tokens[0] === \"#elif\") {\n        throw new PreprocessError(`unsupport #elif`);\n    } else if (tokens[0] === \"#ifdef\") {\n        if (ctx.marcoMap.has(tokens[1])) {\n            ctx.skipBlock = false;\n            ctx.status.push([PreprocessStatus.ON_IF, false]);\n        } else {\n            ctx.skipBlock = true;\n            ctx.status.push([PreprocessStatus.ON_IF, true]);\n        }\n    } else if (tokens[0] === \"#ifndef\") {\n        if (!ctx.marcoMap.has(tokens[1])) {\n            ctx.skipBlock = false;\n            ctx.status.push([PreprocessStatus.ON_IF, false]);\n        } else {\n            ctx.skipBlock = true;\n            ctx.status.push([PreprocessStatus.ON_IF, true]);\n        }\n    } else if (tokens[0] === \"#else\") {\n        if (ctx.status.length > 0 &&\n            ctx.status[ctx.status.length - 1][0] === PreprocessStatus.ON_IF) {\n            const item = ctx.status[ctx.status.length - 1];\n            ctx.skipBlock = !item[1];\n            item[0] = PreprocessStatus.ON_ELSE;\n        } else {\n            throw new PreprocessError(`unmatch #else`);\n        }\n    } else if (tokens[0] === \"#endif\") {\n        if (ctx.status.length > 0) {\n            const item = ctx.status.pop()!;\n            if (ctx.status.length > 0) {\n                ctx.skipBlock = ctx.status[ctx.status.length - 1][1];\n            } else {\n                ctx.skipBlock = false;\n            }\n        } else {\n            throw new PreprocessError(`unmatch #endif`);\n        }\n    } else if (tokens[0] === \"#line\") {\n        throw new PreprocessError(`unsupport #line`);\n    } else if (tokens[0] === \"#error\") {\n        throw new PreprocessError(`Error : ${line}`);\n    } else if (tokens[0] === \"#progma\") {\n        return;\n    } else if (tokens[0] === \"#\") {\n        return;\n    } else {\n        throw new PreprocessError(`unsupport directive ${line}`);\n    }\n}\n\nconst Tokenizer = /([\\\\~!@#$|%^&*()+-={}[\\]:\";'<>?,.\\/]|[A-Za-z_0-9]+|\"[^\"]*\"|'[^']*'|\\n|[ \\t]+)/y;\n\nfunction tokenize(str: string): string[] {\n    let match = Tokenizer.exec(str);\n    const tokens: string[] = [];\n    while (match) {\n        tokens.push(match[1]);\n        match = Tokenizer.exec(str);\n    }\n    return tokens;\n}\n\nexport function parseMarco(parameters: string[], target: string): Array<string | number> {\n    const tokens = tokenize(target);\n    const result = [];\n    let buffer = \"\";\n    for (let i = 0; i < tokens.length; i++) {\n        const token = tokens[i];\n        if (i + 2 < tokens.length &&\n            token === \"#\" &&\n            tokens[i + 1] === \"#\" &&\n            parameters.includes(tokens[i + 2])) {\n            if (buffer.length !== 0) {\n                result.push(buffer);\n                buffer = \"\";\n            }\n            result.push(parameters.indexOf(tokens[i + 2]));\n            i = i + 2;\n        } else if (i + 1 < tokens.length &&\n            token === \"#\" &&\n            parameters.includes(tokens[i + 1])) {\n            result.push(buffer + \"\\\"\");\n            buffer = \"\\\"\";\n            result.push(parameters.indexOf(tokens[i + 1]));\n            i = i + 1;\n        } else if (parameters.includes(token)) {\n            if (buffer.length !== 0) {\n                result.push(buffer);\n                buffer = \"\";\n            }\n            result.push(parameters.indexOf(token));\n        } else {\n            buffer += token;\n        }\n    }\n    if (buffer.length !== 0) {\n        result.push(buffer);\n    }\n    return result;\n}\n\nfunction doMarcoReplace(marco: Marco, argus: string[]): string {\n    return marco.parsedTarget\n        .map((x) => {\n            if (typeof(x) === \"string\") {\n                return x;\n            } else {\n                return argus[x];\n            }\n        }).join(\"\");\n}\n\nfunction preprocessBlock(ctx: PreprocessContext, line: string, blockStartLine: number) {\n    const tokens = tokenize(line);\n    if (tokens[tokens.length - 1] !== \"\\n\") {\n        tokens.push(\"\\n\");\n    }\n    let buffer = \"\", onSkip = 0;\n    if (ctx.onMultiLineComment) {\n        onSkip = 2;\n    }\n    let sourceLocation: Position = {\n        line: blockStartLine,\n        column: 0,\n    }, bufferStartLocation: Position = {\n        line: sourceLocation.line,\n        column: sourceLocation.column,\n    };\n\n    function submitBuffer() {\n        if (buffer.length > 0) {\n            ctx.append(buffer, bufferStartLocation);\n            buffer = \"\";\n            bufferStartLocation = {\n                line: sourceLocation.line,\n                column: sourceLocation.column,\n            };\n        }\n    }\n\n    for (let i = 0; i < tokens.length - 1; i++) {\n        const token = tokens[i];\n\n        function updateSourceMap(info: string) {\n            if (info === \"\\n\") {\n                sourceLocation.line++;\n                sourceLocation.column = 0;\n            } else {\n                sourceLocation.column += info.length;\n            }\n        }\n\n        if (onSkip === 1) {\n            if (token === \"\\n\") {\n                buffer += token;\n                onSkip = 0;\n            }\n            updateSourceMap(token);\n            continue;\n        } else if (onSkip === 2) {\n            if (token === \"*\" && tokens[i + 1] === \"/\") {\n                onSkip = 0;\n                ctx.onMultiLineComment = false;\n                i++;\n            }\n            updateSourceMap(token);\n            continue;\n        }\n        const item = ctx.marcoMap.get(token);\n\n        function nextToken() {\n            i++;\n            while (i < tokens.length && /^\\s*$/.test(tokens[i])) {\n                i++;\n            }\n            if (i >= tokens.length) {\n                return null;\n            }\n            return tokens[i];\n        }\n\n        if (item) {\n            if (item.parameters === null) {\n                submitBuffer();\n                buffer = item.target;\n                updateSourceMap(token);\n                submitBuffer();\n            } else {\n                const savedI = i;\n                const savedSourceLocation = {\n                    line: sourceLocation.line,\n                    column: sourceLocation.column,\n                };\n                if (nextToken() !== \"(\") {\n                    i = savedI;\n                    sourceLocation = savedSourceLocation;\n                    buffer += token;\n                    updateSourceMap(tokens[i]);\n                    continue;\n                }\n                const argus: string[] = [];\n                const brace: { [key: string]: number } = {\"(\": 0, \"[\": 0, \"{\": 0};\n                let seek = \",\";\n                for (let j = 0; j < item.parameters.length; j++) {\n                    if (j === item.parameters.length - 1) {\n                        seek = \")\";\n                    }\n                    let word: string | null = nextToken();\n                    let subBuffer = \"\";\n                    while (!(word === seek &&\n                        Object.keys(brace)\n                            .map((x) => brace[x])\n                            .every((x) => x === 0))) {\n                        if (word === null) {\n                            i = savedI;\n                            sourceLocation = savedSourceLocation;\n                            updateSourceMap(tokens[i]);\n                            buffer += token;\n                            continue;\n                        }\n                        if (brace.hasOwnProperty(word!)) {\n                            brace[word]++;\n                        }\n                        if (word === \")\") {\n                            brace[\"(\"]--;\n                        }\n                        if (word === \"]\") {\n                            brace[\"[\"]--;\n                        }\n                        if (word === \"{\") {\n                            brace[\"{\"]--;\n                        }\n                        subBuffer += word;\n                        word = nextToken();\n                    }\n                    argus.push(subBuffer);\n                }\n                submitBuffer();\n                buffer = doMarcoReplace(item, argus);\n                for (let j = savedI; j <= i; j++) {\n                    updateSourceMap(tokens[j]);\n                }\n                submitBuffer();\n                continue;\n            }\n        } else if (token === \"/\" && tokens[i + 1] === \"/\") {\n            submitBuffer();\n            onSkip = 1;\n        } else if (token === \"/\" && tokens[i + 1] === \"*\") {\n            submitBuffer();\n            onSkip = 2;\n            ctx.onMultiLineComment = true;\n        } else if ( token === \"\\n\" ) {\n            buffer += token;\n            submitBuffer();\n        } else {\n            buffer += token;\n        }\n        updateSourceMap(token);\n    }\n    buffer += \"\\n\";\n    submitBuffer();\n    return \"\";\n}\n\nfunction doPreprocess(fileName: string, source: string, marcoMap: Map<string, Marco>) {\n    // todo:: .H buffer\n    const ctx = new PreprocessContext(fileName, marcoMap);\n    const lines = source.split(\"\\n\");\n    let block = \"\", line = \"\";\n    let blockStartLine = 0;\n    for (let i = 0; i < lines.length; i++) {\n        line = line + lines[i];\n        if (line.charAt(line.length - 1) === \"\\\\\") {\n            line = line.substring(0, line.length - 1);\n        } else if (line.charAt(0) === \"#\") {\n            if (ctx.onMultiLineComment) {\n                block += line + \"\\n\";\n                line = \"\";\n            } else {\n                if (block !== \"\") {\n                    if (!ctx.skipBlock) {\n                        preprocessBlock(ctx, block, blockStartLine);\n                    }\n                    block = \"\";\n                }\n                doPreprocessCommand(ctx, line, i);\n                line = \"\";\n                blockStartLine = i + 1;\n            }\n        } else {\n            block += line + \"\\n\";\n            line = \"\";\n        }\n    }\n    preprocessBlock(ctx, block, blockStartLine);\n    return ctx.node.toStringWithSourceMap();\n}\n\nexport function preprocess(fileName: string, source: string): CodeWithSourceMap {\n    const marcoMap = new Map<string, Marco>();\n    return doPreprocess(fileName, source, marcoMap);\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 06/07/2018\n */\nimport {RuntimeError} from \"../common/error\";\nimport {Runtime} from \"./runtime\";\n\nexport abstract class HeapAllocator {\n    public abstract init(vm: Runtime): void;\n    public abstract allocHeap(vm: Runtime, size: number): number;\n    public abstract getBlockSize(vm: Runtime, offset: number): number;\n    public abstract freeHeap(vm: Runtime, offset: number): void;\n}\n\nexport class LinkedHeapAllocator extends HeapAllocator {\n\n    constructor() {\n        super();\n    }\n\n    // +0 tag (0 => occupied, 1 => free);\n    // +4 block size (not include meta)\n\n    public init(vm: Runtime): void {\n        vm.heapPointer += 0;\n    }\n\n    public allocHeap(vm: Runtime, size: number): number {\n        let ptr = vm.heapStart;\n        while (ptr < vm.heapPointer) {\n            const tag = vm.memory.getUint32(ptr);\n            const blkSize = vm.memory.getUint32(ptr + 4);\n            if (tag === 1 && blkSize >= size + 8) {\n                vm.memory.setUint32(ptr, 0);\n                vm.memory.setUint32(ptr + 4, size);\n                vm.memory.setUint32(ptr + size + 8, 1);\n                vm.memory.setUint32(ptr + size + 8 + 4, blkSize - size - 8);\n                return ptr + 8;\n            } else if (tag === 1 && blkSize >= size) {\n                vm.memory.setUint32(ptr, 0);\n                return ptr + 8;\n            }\n            ptr = ptr + blkSize + 8;\n        }\n        if (vm.sp - vm.heapPointer <= size + 8) {\n            throw new RuntimeError(`out of memory`);\n        } else {\n            const offset = vm.heapPointer;\n            vm.memory.setUint32(vm.heapPointer, 0);\n            vm.memory.setUint32(vm.heapPointer + 4, size);\n            vm.heapPointer += size + 8;\n            return offset + 8;\n        }\n    }\n\n    public getBlockSize(vm: Runtime, offset: number): number {\n        if ( !( offset >= vm.heapStart && offset <= vm.heapPointer)) {\n            throw new RuntimeError(`free a blk not be malloc`);\n        }\n        let ptr = vm.heapStart, lastPtr = 0;\n        while (ptr < offset - 8) {\n            const blkSize = vm.memory.getUint32(ptr + 4);\n            lastPtr = ptr;\n            ptr = ptr + blkSize + 8;\n        }\n        if ( ptr !== offset - 8) {\n            throw new RuntimeError(`free a blk not be malloc`);\n        }\n        return vm.memory.getUint32(ptr + 4);\n    }\n\n    public freeHeap(vm: Runtime, offset: number): void {\n        if ( !( offset >= vm.heapStart && offset <= vm.heapPointer)) {\n            throw new RuntimeError(`free a blk not be malloc`);\n        }\n        let ptr = vm.heapStart, lastPtr = 0;\n        while (ptr < offset - 8) {\n            const blkSize = vm.memory.getUint32(ptr + 4);\n            lastPtr = ptr;\n            ptr = ptr + blkSize + 8;\n        }\n        if ( ptr !== offset - 8) {\n            throw new RuntimeError(`free a blk not be malloc`);\n        }\n        const lastTag = vm.memory.getUint32(lastPtr);\n        const thisSize = vm.memory.getUint32(ptr + 4);\n        const nextTag = vm.memory.getUint32(ptr + 8 + thisSize);\n        if (lastTag === 1) {\n            const lastSize = vm.memory.getUint32(lastPtr + 4);\n            let newSize = lastSize + thisSize + 8;\n            if ( nextTag === 1 ) {\n                newSize += vm.memory.getUint32(ptr + 8 + thisSize + 4) + 8;\n            }\n            vm.memory.setUint32(lastPtr, 1);\n            vm.memory.setUint32(lastPtr + 4, newSize);\n        } else {\n            let newSize = thisSize;\n            if ( nextTag === 1 ) {\n                newSize += vm.memory.getUint32(ptr + 8 + thisSize + 4) + 8;\n            }\n            vm.memory.setUint32(ptr, 1);\n            vm.memory.setUint32(ptr + 4, newSize);\n        }\n    }\n}\n\nexport class FastHeapAllocator extends LinkedHeapAllocator {\n\n    private sizeLimit: number[];\n    private poolSize: number[];\n    private poolPtr: number[];\n    private pool: Array<Set<number>>;\n    private MAGIC_NUMBER: number;\n\n    constructor() {\n        super();\n        this.sizeLimit = [32, 128, 512];\n        this.poolSize =  [64, 1, 1];\n        this.MAGIC_NUMBER = 12450;\n        this.pool = [];\n        this.poolPtr = [];\n    }\n\n    public init(vm: Runtime): void {\n        super.init(vm);\n        this.pool = this.sizeLimit.map((_, i) => this.createPool(vm, i));\n    }\n\n    public allocHeap(vm: Runtime, size: number): number {\n        if ( size > this.sizeLimit[this.sizeLimit.length - 1]) {\n            return super.allocHeap(vm, size);\n        } else {\n           let idx = 0;\n           while ( this.sizeLimit[idx] < size ) { idx ++; }\n           const pool = this.pool[idx];\n           if (pool.size <= 0) {\n               this.extendPool(vm, idx);\n           }\n           const offset = pool.keys().next().value;\n           pool.delete(offset);\n           return offset;\n        }\n    }\n\n    public freeHeap(vm: Runtime, offset: number): void {\n        const tag = vm.memory.getUint32(offset - 4);\n        if ( tag >= this.MAGIC_NUMBER) {\n            const idx = tag - this.MAGIC_NUMBER;\n            if (idx < 0 || idx >= this.pool.length) {\n                throw new RuntimeError(`free a blk not be malloc`);\n            }\n            this.pool[idx].add(offset);\n        } else {\n            super.freeHeap(vm, offset);\n        }\n    }\n\n    public getBlockSize(vm: Runtime, offset: number): number {\n        const tag = vm.memory.getUint32(offset - 4);\n        if ( tag >= this.MAGIC_NUMBER) {\n            const idx = tag - this.MAGIC_NUMBER;\n            if (idx < 0 || idx >= this.pool.length) {\n                throw new RuntimeError(`free a blk not be malloc`);\n            }\n            return this.poolSize[idx];\n        } else {\n            return super.getBlockSize(vm, offset);\n        }\n    }\n\n    private createPool(vm: Runtime, index: number): Set<number> {\n        const size = this.sizeLimit[index];\n        const poolSize = this.poolSize[index];\n        const result = new Set<number>();\n        const memory = super.allocHeap(vm, (size + 4) * poolSize);\n        this.poolPtr.push(memory);\n        for (let i = 0; i < poolSize; i++) {\n            const offset = memory + i * (size + 4);\n            vm.memory.setUint32(offset, this.MAGIC_NUMBER + index);\n            result.add(offset + 4);\n        }\n        return result;\n    }\n\n    private extendPool(vm: Runtime, index: number) {\n        const size = this.sizeLimit[index];\n        const poolSize = this.poolSize[index];\n        const pool = this.pool[index];\n        this.poolSize[index] *= 2;\n        const memory = super.allocHeap(vm, (size + 4) * poolSize);\n        this.poolPtr.push(memory);\n        for (let i = 0; i < poolSize; i++) {\n            const offset = memory + i * (size + 4);\n            vm.memory.setUint32(offset, this.MAGIC_NUMBER + index);\n            pool.add(offset + 4);\n        }\n    }\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 14/07/2018\n */\nimport {fromBytesToString} from \"../common/utils\";\nimport {FastHeapAllocator, HeapAllocator} from \"./allocator\";\nimport {VMFile} from \"./vmfile\";\n\nexport interface ImportObject {\n    [module: string]: {\n        [name: string]: any,\n    };\n}\n\nexport interface RuntimeOptions {\n    heapStart: number;\n    importObjects: ImportObject;\n    memorySize: number;\n    files: VMFile[];\n    entry: string;\n}\n\nexport abstract class Runtime {\n    public memory: DataView;\n    public memoryUint8Array: Uint8Array;\n    public memoryBuffer: ArrayBuffer;\n    public heapStart: number;\n    public heapPointer: number;\n\n    public entry: string;\n    public importObjects: ImportObject;\n    public files: VMFile[];\n    public heapAllocator: HeapAllocator;\n\n    constructor(options: RuntimeOptions) {\n        this.memoryBuffer = new ArrayBuffer(options.memorySize);\n        this.memoryUint8Array = new Uint8Array(this.memoryBuffer);\n        this.memory = new DataView(this.memoryBuffer);\n        this.heapStart = options.heapStart;\n        this.heapPointer = options.heapStart;\n        this.importObjects = options.importObjects;\n        this.files = options.files;\n        this.heapAllocator = new FastHeapAllocator();\n        this.entry = options.entry;\n    }\n\n    public abstract async run(): Promise<void>;\n\n    public abstract get sp(): number;\n\n    public abstract set sp(value: number);\n\n    public abstract printStack(): void;\n\n    public readMemoryString(ptr: number): string {\n        return fromBytesToString(this.memory, ptr);\n    }\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 14/07/2018\n */\nimport \"babel-polyfill\";\nimport {Runtime, RuntimeOptions} from \"./runtime\";\n\nexport interface NativeRuntimeOptions extends RuntimeOptions {\n    code: ArrayBuffer;\n}\n\nexport class NativeRuntime extends Runtime {\n\n    public wasmMemory: WebAssembly.Memory;\n    public instance: WebAssembly.Instance | null;\n    public code: ArrayBuffer;\n    public options: NativeRuntimeOptions;\n\n    constructor(options: NativeRuntimeOptions) {\n        super(options);\n\n        this.code = options.code;\n        this.options = options;\n\n        // wrap importObject\n        this.wasmMemory = new WebAssembly.Memory(\n            {\n                initial: 1,\n                maximum: options.memorySize / 65536,\n            });\n        if (!this.importObjects.hasOwnProperty(\"system\")) {\n            this.importObjects[\"system\"] = {};\n        }\n        const that = this;\n        const oldImportObject = this.importObjects;\n        this.importObjects = {};\n        for (const moduleName of Object.keys(oldImportObject)) {\n            const module = oldImportObject[moduleName];\n            this.importObjects[moduleName] = {};\n            for (const funcName of Object.keys(module)) {\n                const func = module[funcName] as Function;\n                this.importObjects[moduleName][funcName] = function() {\n                    return func.apply(that, Array.from(arguments));\n                };\n            }\n        }\n\n        this.importObjects[\"system\"][\"memory\"] = this.wasmMemory;\n        this.memoryBuffer = this.wasmMemory.buffer;\n        this.memory = new DataView(this.memoryBuffer);\n        this.memoryUint8Array = new Uint8Array(this.memoryBuffer);\n        this.instance = null;\n\n    }\n\n    public async run(): Promise<void> {\n        this.heapStart = this.heapPointer = this.options.heapStart;\n        const asm = await WebAssembly.instantiate(this.code, this.importObjects);\n        this.instance = asm.instance;\n        const initSp = parseInt(((this.wasmMemory.buffer.byteLength - 1) / 4) + \"\") * 4;\n        this.sp = initSp;\n        this.heapAllocator.init(this);\n        asm.instance.exports[\"$start\"]();\n        this.sp = initSp;\n        asm.instance.exports[this.entry]();\n        // this.instance = null;\n        this.files.map((file) => file.flush());\n    }\n\n    public get sp(): number {\n        return this.instance!.exports.$get_sp();\n    }\n\n    public set sp(value: number) {\n        this.instance!.exports.$set_sp(value);\n    }\n\n    public printStack() {\n        return;\n    }\n\n}\n","import Long = require(\"long\");\nimport {FunctionLookUpResult, Scope, ScopeManager} from \"../codegen/scope\";\nimport {AddressType, Variable} from \"../common/symbol\";\nimport {ArrayType, PointerType, ReferenceType} from \"../type/compound_type\";\nimport {\n    CharType, Int16Type, Int32Type, Int64Type,\n    UnsignedCharType,\n    UnsignedInt16Type,\n    UnsignedInt32Type,\n    UnsignedInt64Type,\n} from \"../type/primitive_type\";\nimport {\n    Control,\n    F32,\n    F32Binary, F32Convert,\n    F32Unary, F64,\n    F64Binary, F64Convert,\n    F64Unary, I32,\n    I32Binary, I32Convert,\n    I32Unary, I64,\n    I64Binary,\n    I64Convert,\n    I64Unary, WASMJSON, WASMJSONFunction, WLoadIns, WStoreIns,\n    WType,\n} from \"../wasm\";\nimport {doBinaryCompute, doLongBinaryCompute, doLongUnaryCompute, doUnaryCompute} from \"../wasm/tool/calculator\";\nimport {Runtime, RuntimeOptions} from \"./runtime\";\n\ntype WASMNumber = number | Long;\n\nexport interface StackItem {\n    fn: WASMJSONFunction;\n    pc: number;\n    sp: number;\n    locals: WASMNumber[];\n    stack: WASMNumber[];\n    controlFlow: number[];\n}\n\nexport interface JSRuntimeOptions extends RuntimeOptions {\n    program: WASMJSON;\n    scope: Scope;\n    entryFileName: string;\n}\n\nexport interface JSRuntimeItemInfo {\n    name: string;\n    type: string;\n    value: string;\n    size: number;\n    location: number | null;\n}\n\nexport class JSRuntime extends Runtime {\n    public program: WASMJSON;\n    public stack: StackItem[];\n    public stackTop: StackItem;\n    public globals: WASMNumber[];\n    public convertArray: ArrayBuffer;\n    public convertDataView: DataView;\n    public options: JSRuntimeOptions;\n    public spIndex: number;\n    public returnValue: number;\n    public rootScope: Scope;\n    public scopeManager: ScopeManager;\n\n    constructor(options: JSRuntimeOptions) {\n        super(options);\n        this.options = options;\n        this.program = options.program;\n        this.rootScope = options.scope;\n        this.scopeManager = new ScopeManager(true);\n        this.scopeManager.root = this.rootScope;\n\n        this.stack = [];\n        this.spIndex = -1;\n        for (let i = 0; i < this.program.globals.length; i++) {\n            if (this.program.globals[i].name === \"$sp\") {\n                this.spIndex = i;\n            }\n        }\n        if (this.spIndex === - 1) {\n            throw new Error(\"no $sp found\");\n        }\n        this.globals = this.program.globals.map((x) => {\n            if (x.type === WType.i64) {\n                return Long.fromString(x.init);\n            } else if (x.type === WType.i32) {\n                return parseInt(x.init);\n            } else {\n                return parseFloat(x.init);\n            }\n        });\n        this.returnValue = 0;\n        this.convertArray = new ArrayBuffer(64);\n        this.convertDataView = new DataView(this.convertArray);\n        for (const seg of this.program.data) {\n            this.memoryUint8Array.set(new Uint8Array(seg.data), seg.offset);\n        }\n        for (const fn of this.program.functions) {\n            fn.scope = fn.name.substring(0, 2) === \"::\" ?\n                this.rootScope.getScopeOfLookupName(fn.name + \"::a\") : null;\n        }\n        this.stack = [{\n            fn: this.program.functions[0],\n            pc: 0,\n            sp: this.sp,\n            locals: [],\n            stack: [],\n            controlFlow: [],\n        }];\n        this.stackTop = this.stack[0];\n    }\n\n    public get sp(): number {\n        return this.globals[this.spIndex] as number;\n    }\n\n    public set sp(value: number) {\n        this.globals[this.spIndex] = value;\n    }\n\n    public runStep(): boolean {\n        // fetch\n        const ins = this.stackTop.fn.codes[this.stackTop.pc];\n        // console.log(OpCodes.get(ins[0]));\n        // console.log({\n        //     pc: this.stackTop.pc,\n        //     sp: this.sp,\n        // });\n        // decode & compute\n        if (I32Binary.hasOwnProperty(ins[0]) || F32Binary.hasOwnProperty(ins[0]) || F64Binary.hasOwnProperty(ins[0])) {\n            const b = this.stackTop.stack[this.stackTop.stack.length - 1] as number;\n            const a = this.stackTop.stack[this.stackTop.stack.length - 2] as number;\n            this.stackTop.stack.pop();\n            this.stackTop.stack[this.stackTop.stack.length - 1] = doBinaryCompute(ins[0], a, b);\n        } else if (I64Binary.hasOwnProperty(ins[0])) {\n            const b = this.stackTop.stack[this.stackTop.stack.length - 1] as Long;\n            const a = this.stackTop.stack[this.stackTop.stack.length - 2] as Long;\n            this.stackTop.stack.pop();\n            this.stackTop.stack[this.stackTop.stack.length - 1] = doLongBinaryCompute(ins[0], a, b);\n        } else if (I32Unary.hasOwnProperty(ins[0]) || F32Unary.hasOwnProperty(ins[0])\n            || F64Unary.hasOwnProperty(ins[0])) {\n            const a = this.stackTop.stack[this.stackTop.stack.length - 1] as number;\n            this.stackTop.stack[this.stackTop.stack.length - 1] = doUnaryCompute(ins[0], a);\n        } else if (I64Unary.hasOwnProperty(ins[0])) {\n            const a = this.stackTop.stack[this.stackTop.stack.length - 1] as Long;\n            this.stackTop.stack[this.stackTop.stack.length - 1] = doLongUnaryCompute(ins[0], a);\n        } else if (I32Convert.hasOwnProperty(ins[0]) || F32Convert.hasOwnProperty(ins[0])\n            || F64Convert.hasOwnProperty(ins[0])) {\n            if (ins[0] === I32Convert.wrap$i64 || ins[0] === F32Convert.convert_s$i64\n                || ins[0] === F32Convert.convert_u$i64 || ins[0] === F64Convert.convert_s$i64\n                || ins[0] === F64Convert.convert_u$i64) {\n                const a = this.stackTop.stack[this.stackTop.stack.length - 1] as Long;\n                this.stackTop.stack[this.stackTop.stack.length - 1] = a.toNumber();\n            } else if (ins[0] === I32Convert.trunc_s$f32 || ins[0] === I32Convert.trunc_s$f64\n                || ins[0] === I32Convert.trunc_u$f32 || ins[0] === I32Convert.trunc_u$f64) {\n                const a = this.stackTop.stack[this.stackTop.stack.length - 1] as number;\n                this.stackTop.stack[this.stackTop.stack.length - 1] = a | 0;\n            } else if (ins[0] === I32Convert.reinterpret$f32) {\n                const a = this.stackTop.stack[this.stackTop.stack.length - 1] as number;\n                this.convertDataView.setFloat32(0, a);\n                this.stackTop.stack[this.stackTop.stack.length - 1] = this.convertDataView.getInt32(0);\n            } else if (ins[0] === F32Convert.reinterpret$i32) {\n                const a = this.stackTop.stack[this.stackTop.stack.length - 1] as number;\n                this.convertDataView.setInt32(0, a);\n                this.stackTop.stack[this.stackTop.stack.length - 1] = this.convertDataView.getFloat32(0);\n            } else if (ins[0] === F64Convert.reinterpret$i64) {\n                const a = this.stackTop.stack[this.stackTop.stack.length - 1] as Long;\n                this.convertDataView.setUint32(0, a.high);\n                this.convertDataView.setUint32(4, a.low);\n                this.stackTop.stack[this.stackTop.stack.length - 1] = this.convertDataView.getFloat64(0);\n            }\n        } else if (I64Convert.hasOwnProperty(ins[0])) {\n            if (ins[0] === I64Convert.reinterpret$f64) {\n                const a = this.stackTop.stack[this.stackTop.stack.length - 1] as number;\n                this.convertDataView.setFloat64(0, a);\n                this.stackTop.stack[this.stackTop.stack.length - 1] =\n                    Long.fromBits(this.convertDataView.getUint32(4), this.convertDataView.getUint32(0));\n            } else {\n                const a = this.stackTop.stack[this.stackTop.stack.length - 1] as number;\n                this.stackTop.stack[this.stackTop.stack.length - 1] = Long.fromNumber(a);\n            }\n        } else if (ins[0] === I32.const || ins[0] === F32.const || ins[0] === F64.const) {\n            this.stackTop.stack.push(ins[1] as number);\n        } else if (ins[0] === I64.const) {\n            this.stackTop.stack.push(Long.fromString(ins[1] as string));\n        } else if (WLoadIns.has(ins[0])) {\n            const addr = (this.stackTop.stack[this.stackTop.stack.length - 1] as number) + (ins[1] as number);\n            let data: number = 0;\n            if (ins[0] === I32.load8_s || ins[0] === I64.load8_s) {\n                data = this.memory.getInt8(addr);\n            } else if (ins[0] === I32.load8_u || ins[0] === I64.load8_u) {\n                data = this.memory.getUint8(addr);\n            } else if (ins[0] === I32.load16_s || ins[0] === I64.load16_s) { data = this.memory.getInt16(addr, true);\n            } else if (ins[0] === I32.load16_u || ins[0] === I64.load16_u) { data = this.memory.getUint16(addr, true);\n            } else if (ins[0] === I32.load || ins[0] === I64.load32_s) { data = this.memory.getInt32(addr, true);\n            } else if (ins[0] === I64.load32_u) { data = this.memory.getUint32(addr, true);\n            } else if (ins[0] === F32.load) { data = this.memory.getFloat32(addr, true);\n            } else if (ins[0] === F64.load) { data = this.memory.getFloat64(addr, true);\n            }\n\n            if (ins[0] === I64.load) {\n                this.stackTop.stack[this.stackTop.stack.length - 1] = Long.fromBits(\n                    this.memory.getUint32(addr, true),\n                    this.memory.getUint32(addr + 4, true),\n                );\n            } else if (ins[0] === I64.load32_u || ins[0] === I64.load32_s || ins[0] === I64.load16_u ||\n                ins[0] === I64.load16_s || ins[0] === I64.load8_u || ins[0] === I64.load8_s) {\n                this.stackTop.stack[this.stackTop.stack.length - 1] = Long.fromNumber(data);\n            } else {\n                this.stackTop.stack[this.stackTop.stack.length - 1] = data;\n            }\n        } else if (WStoreIns.has(ins[0])) {\n            const data = this.stackTop.stack.pop() as WASMNumber;\n            const addr = (this.stackTop.stack.pop() as number) + (ins[1] as number);\n            this.stackTop.stack.pop();\n            if (ins[0] === I32.store8) {\n                this.memory.setUint8(addr, data as number);\n            } else if (ins[0] === I32.store16) { this.memory.setUint16(addr, data as number, true);\n            } else if (ins[0] === I32.store) { this.memory.setInt32(addr, data as number, true);\n            } else if (ins[0] === F32.store) { this.memory.setFloat32(addr, data as number, true);\n            } else if (ins[0] === F64.store) {this.memory.setFloat64(addr, data as number, true);\n            } else if (ins[0] === I64.store8) { this.memory.setUint8(addr, (data as Long).toNumber());\n            } else if (ins[0] === I64.store16) { this.memory.setUint16(addr, (data as Long).toNumber(), true);\n            } else if (ins[0] === I64.store32) { this.memory.setUint32(addr, (data as Long).toNumber(), true);\n            } else if (ins[0] === I64.store) {\n                this.memory.setUint32(addr, (data as Long).low, true);\n                this.memory.setUint32(addr + 4, (data as Long).high, true);\n            }\n        } else if (ins[0] === Control.set_local) {\n            this.stackTop.locals[ins[1] as number] = this.stackTop.stack.pop() as WASMNumber;\n        } else if (ins[0] === Control.tee_local) {\n            this.stackTop.locals[ins[1] as number] = this.stackTop.stack[this.stackTop.stack.length - 1];\n        } else if (ins[0] === Control.set_global) {\n            const data = this.stackTop.stack.pop() as WASMNumber;\n            this.globals[ins[1] as number] = data;\n        } else if (ins[0] === Control.get_local) {\n            this.stackTop.stack.push(this.stackTop.locals[ins[1] as number]);\n        } else if (ins[0] === Control.get_global) {\n            this.stackTop.stack.push(this.globals[ins[1] as number]);\n        } else if (ins[0] === Control.drop) {\n            this.stackTop.stack.pop();\n        } else if (ins[0] === Control.nop) {\n            // pass\n        } else if (ins[0] === Control.block) {\n            this.stackTop.controlFlow.push(ins[1] as number);\n        } else if (ins[0] === Control.loop) {\n            this.stackTop.controlFlow.push(this.stackTop.pc + 1);\n        } else if (ins[0] === Control.br || ins[0] === Control.br_if) {\n            const cond = (ins[0] === Control.br) ? true : this.stackTop.stack.pop() as number;\n            if (cond) {\n                for (let i = 0; i < ins[1]; i++) { this.stackTop.controlFlow.pop(); }\n                this.stackTop.pc = this.stackTop.controlFlow[this.stackTop.controlFlow.length - 1] as number - 1;\n            }\n        } else if (ins[0] === Control.if) {\n            this.stackTop.controlFlow.push(this.stackTop.pc);\n            const cond = this.stackTop.stack.pop() as number;\n            if (!cond) {\n                // if false, jump to else + 1 or end + 1\n                if (this.stackTop.fn.codes[ins[1] as number][0] === Control.else) {\n                    this.stackTop.pc = ins[1] as number;\n                } else {\n                    this.stackTop.pc = ins[1] as number - 1;\n                }\n            }\n        } else if (ins[0] === Control.else) {\n            this.stackTop.pc = ins[1] as number - 1;\n        } else if (ins[0] === Control.end) {\n            this.stackTop.controlFlow.pop();\n        } else if (ins[0] === Control.call || ins[0] === Control.call_indirect) {\n            const funcIdx = ins[0] === Control.call_indirect ?\n                this.stackTop.stack.pop() as number\n                : ins[1] as number;\n            const funcType = this.program.types[funcIdx];\n            const args: WASMNumber[] = [];\n\n            for (let i = 1; i < funcType.length; i++) {\n                args.push(this.stackTop.stack.pop()!);\n            }\n            args.reverse(); // inverse call std\n            if (funcIdx >= this.program.imports.length) {\n                // internal call\n                const fn = this.program.functions[funcIdx - this.program.imports.length];\n                this.stack.push({\n                    fn,\n                    pc: -1,\n                    sp: this.sp,\n                    stack: [],\n                    controlFlow: [],\n                    locals: args,\n                });\n                this.stackTop = this.stack[this.stack.length - 1];\n                for (let i = 0; i < this.stackTop.fn.locals.length; i++) {\n                    if (this.stackTop.fn.locals[i] === WType.i64) {\n                        this.stackTop.locals.push(Long.fromNumber(0));\n                    } else {\n                        this.stackTop.locals.push(0);\n                    }\n                }\n            } else {\n                // external call\n                const funcMeta = this.program.imports[funcIdx];\n                const func = this.importObjects[funcMeta.module][funcMeta.name];\n                const ret = func.apply(this, args) as number;\n                if (funcType.charAt(0) === \"i\" || funcType.charAt(0) === \"f\" || funcType.charAt(0) === \"d\") {\n                    this.stackTop.stack.push(ret);\n                } else if (funcType.charAt(0) === \"l\") {\n                    this.stackTop.stack.push(Long.fromNumber(ret));\n                }\n            }\n        } else if (ins[0] === Control.return) {\n            let ret: WASMNumber = 0;\n            const isVoid = this.stackTop.fn.type.charAt(0) === \"v\";\n            if (!isVoid) {\n                ret = this.stackTop.stack.pop()!;\n            }\n            this.stack.pop();\n            if (this.stack.length === 0) {\n                if (ret instanceof Long) { ret = ret.toNumber(); }\n                this.returnValue = ret;\n                return false;\n            }\n            this.stackTop = this.stack[this.stack.length - 1];\n            if (!isVoid) {\n                this.stackTop.stack.push(ret);\n            }\n        } else if (ins[0] === Control.br_table || ins[0] === Control.select) {\n            throw new Error(\"WASM not support\");\n        }\n\n        // next\n        this.stackTop.pc ++;\n        return true;\n    }\n\n    public prepareRunFunction(entry: string, initHeap: boolean = false) {\n        if (!this.program.exports.hasOwnProperty(entry)) {\n            throw new Error(`no entry:${entry} found`);\n        }\n        this.sp = parseInt(((this.memory.buffer.byteLength - 1) / 4) + \"\") * 4;\n        if (initHeap) {\n            this.heapAllocator.init(this);\n        }\n        const fn = this.program.functions[this.program.exports[entry] - this.program.imports.length];\n        this.stack = [{\n            fn,\n            pc: 0,\n            sp: this.sp,\n            locals: [],\n            stack: [],\n            controlFlow: [],\n        }];\n        this.stackTop = this.stack[this.stack.length - 1];\n    }\n\n    public runFunction(entry: string, initHeap: boolean = false) {\n        this.prepareRunFunction(entry, initHeap);\n        while (this.runStep()) { continue; }\n    }\n\n    // run according to c++ abi\n    public async run(): Promise<void> {\n        this.heapStart = this.heapPointer = this.options.heapStart;\n        this.runFunction(\"$start\", true);\n        this.runFunction(this.entry, false);\n        this.files.map((file) => file.flush());\n    }\n\n    public getCurrentLine() {\n        return this.stackTop.fn.codes[this.stackTop.pc][2];\n    }\n\n    public prepareRunSingleStepMode() {\n        this.heapStart = this.heapPointer = this.options.heapStart;\n        this.runFunction(\"$start\", true);\n        this.prepareRunFunction(this.entry, false);\n    }\n\n    public runSingleStepMode(): boolean {\n        while (this.runStep()) {\n            if (this.stackTop.fn.fileName === this.options.entryFileName\n                && this.stackTop.fn.lineIdx.has(this.stackTop.pc)) {\n                this.files.map((file) => file.flush());\n                return true;\n            }\n        }\n        this.files.map((file) => file.flush());\n        return false;\n    }\n\n    public padDigits(str: string, digits: number) {\n        return Array(Math.max(digits - str.length + 1, 0)).join(\"0\") + str;\n    }\n\n    public formatVariableOutput(v: Variable, value: number | Long): string {\n        if (v.type instanceof PointerType || v.type instanceof ReferenceType) {\n            return \"0x\" + this.padDigits(value.toString(16), 8);\n        } else {\n            return value.toString();\n        }\n    }\n\n    public getValueOfVariableFromAddress(v: Variable, addr: number): string {\n        if (v.type instanceof UnsignedCharType) {\n            return this.formatVariableOutput(v, this.memory.getUint8(addr));\n        } else if (v.type instanceof UnsignedInt16Type) {\n            return  this.formatVariableOutput(v, this.memory.getUint16(addr, true));\n        } else if (v.type instanceof UnsignedInt32Type) {\n            return  this.formatVariableOutput(v, this.memory.getUint32(addr, true));\n        } else if (v.type instanceof UnsignedInt64Type) {\n            return  this.formatVariableOutput(v, Long.fromBits(this.memory.getUint32(addr, true),\n                this.memory.getUint32(addr + 4, true),\n                true));\n        } else if (v.type instanceof CharType) {\n            return  this.formatVariableOutput(v, this.memory.getInt8(addr));\n        } else if (v.type instanceof Int16Type) {\n            return  this.formatVariableOutput(v, this.memory.getInt16(addr, true));\n        } else if (v.type instanceof Int32Type) {\n            return  this.formatVariableOutput(v, this.memory.getInt32(addr, true));\n        } else if (v.type instanceof Int64Type) {\n            return  this.formatVariableOutput(v, Long.fromBits(this.memory.getUint32(addr, true),\n                this.memory.getUint32(addr + 4, true)));\n        } else if (v.type instanceof PointerType) {\n            return this.formatVariableOutput(v, this.memory.getUint32(addr, true));\n        } else {\n            return \"N/A\";\n        }\n    }\n\n    public getValueOfVariable(v: Variable, stack: StackItem | null): string {\n        switch (v.addressType) {\n            case AddressType.LOCAL:\n                if (!stack) { return \"N/A\"; }\n                return this.formatVariableOutput(v, stack.locals[v.location as number]);\n            case AddressType.GLOBAL:\n                return  this.formatVariableOutput(v, this.globals[v.location as number]);\n            case AddressType.GLOBAL_SP:\n                return this.getValueOfVariableFromAddress(v,\n                    this.sp + (v.location as number));\n            case AddressType.STACK:\n                if (!stack) { return \"N/A\"; }\n                return this.getValueOfVariableFromAddress(v,\n                    stack.sp + (v.location as number));\n            case AddressType.MEMORY_DATA:\n                return this.getValueOfVariableFromAddress(v,\n                    this.stackTop.fn.dataStart + (v.location as number));\n            case AddressType.MEMORY_BSS:\n                return this.getValueOfVariableFromAddress(v,\n                    this.stackTop.fn.bssStart + (v.location as number));\n            default:\n                return \"N/A\";\n        }\n    }\n\n    public getLocationOfVariable(v: Variable, stack: StackItem | null): number | null {\n        switch (v.addressType) {\n            case AddressType.GLOBAL_SP:\n                return this.sp + (v.location as number);\n            case AddressType.STACK:\n                if (!stack) { return null; }\n                return stack.sp + (v.location as number);\n            case AddressType.MEMORY_DATA:\n                return this.stackTop.fn.dataStart + (v.location as number);\n            case AddressType.MEMORY_BSS:\n                return this.stackTop.fn.bssStart + (v.location as number);\n            default:\n                return null;\n        }\n    }\n\n    public getSubScopeInfo(result: JSRuntimeItemInfo[], scope: Scope, stack: StackItem | null) {\n        for (const item of scope.map) {\n            for (const subItem of item[1]) {\n                if (subItem instanceof Variable) {\n                    result.push({\n                        name: subItem.shortName,\n                        size: subItem.type.length,\n                        type: subItem.type.toString(),\n                        value: this.getValueOfVariable(subItem, stack),\n                        location: this.getLocationOfVariable(subItem, stack),\n                    });\n                }\n            }\n        }\n        for (const subScope of scope.children) {\n            if (subScope.isInnerScope) {\n                this.getSubScopeInfo(result, subScope, stack);\n            }\n        }\n    }\n\n    public getScopeInfo(scope: Scope, stack: StackItem | null): JSRuntimeItemInfo[] {\n        const result: JSRuntimeItemInfo[] = [];\n        if (!scope) { return []; }\n        this.getSubScopeInfo(result, scope, stack);\n        return result;\n    }\n\n    public printStack() {\n        console.log(\"==== WebCpp Stack Dumper ====\");\n        console.log(\"sp=\", this.stackTop.sp);\n        const intervals = [] as JSRuntimeItemInfo[];\n        for (const item of this.stack) {\n            if (item.fn.scope) {\n                const scopeInfo = this.getScopeInfo(item.fn.scope, item);\n                // console.log(\"==>\" + item.fn.name);\n                intervals.push({\n                    location: item.sp,\n                    name: item.fn.name,\n                    type: item.locals.map((x) => x.toString()).join(\",\"),\n                    value: \"\",\n                    size: 0,\n                });\n                for (const a of scopeInfo) {\n                    if (a.location !== null) {\n                        intervals.push(a);\n                    }\n                    // console.log(a.name, \" \", a.type, \" \", a.location, \" \", a.value, \" \", a.size);\n                }\n            }\n        }\n        const newIntervals = intervals.sort((a, b) => {\n            return a.location! - b.location!;\n        });\n        let last = -1;\n        for (const a of newIntervals) {\n            if (a.location !== last && last !== -1) {\n                console.log(`${last}-${a.location!} >>>>unknown`);\n            }\n            console.log(`${a.location}-${a.location! + a.size}`, a.name, \" \", a.type, \" \", a.value);\n            last = a.location! + a.size;\n        }\n        if (last !== this.memory.byteLength) {\n            console.log(`${last}-${this.memory.byteLength} >>>>unknown`);\n        }\n        return;\n    }\n\n}\n","/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 06/07/2018\n */\nimport {InternalError} from \"../common/error\";\nimport {fromBytesToString} from \"../common/utils\";\n\nexport abstract class VMFile {\n\n    public abstract read(buffer: ArrayBuffer, offset: number, size: number): number;\n\n    public abstract write(buffer: ArrayBuffer): number;\n\n    public abstract flush(): number;\n\n}\n\nexport class NoInputFile extends VMFile {\n    public read(buffer: ArrayBuffer, offset: number, size: number): number {\n        return 0;\n    }\n\n    public write(buffer: ArrayBuffer): number {\n        throw new InternalError(`NoInputFile is not support write`);\n    }\n\n    public flush(): number {\n        return 0;\n    }\n}\n\nexport class CommandOutputFile extends VMFile {\n    public buffer: string;\n\n    constructor() {\n        super();\n        this.buffer = \"\";\n    }\n\n    public read(buffer: ArrayBuffer, offset: number, size: number): number {\n        throw new InternalError(`CommandOutputFile is not support read`);\n    }\n\n    public write(buffer: ArrayBuffer): number {\n        this.buffer += fromBytesToString(new DataView(buffer), 0, buffer.byteLength);\n        if (this.buffer.includes(\"\\n\")) {\n            const lines = this.buffer.split(\"\\n\");\n            this.buffer = lines[lines.length - 1];\n            lines.slice(0, lines.length - 1).map((line) => console.log(line));\n        }\n        return buffer.byteLength;\n    }\n\n    public flush(): number {\n        const len = this.buffer.length;\n        if ( this.buffer.length === 0 ) {\n            return 0;\n        }\n        console.log(this.buffer);\n        this.buffer = \"\";\n        return len;\n    }\n}\n\nexport class StringInputFile extends VMFile {\n    public str: string;\n    public offset: number;\n\n    constructor(str: string) {\n        super();\n        this.str = str;\n        this.offset = 0;\n    }\n\n    public flush(): number {\n        return 0;\n    }\n\n    public read(buffer: ArrayBuffer, offset: number, size: number): number {\n        let bytes = 0;\n        for (let i = 0; i < size; i++) {\n            if (this.offset >= this.str.length) { return bytes; }\n            new DataView(buffer).setUint8(offset + i, this.str.charCodeAt(this.offset));\n            this.offset ++;\n            bytes++;\n        }\n        return bytes;\n    }\n\n    public write(buffer: ArrayBuffer): number {\n        throw new InternalError(`NoInputFile is not support write`);\n    }\n}\n\nexport class StringOutputFile extends VMFile {\n    public output: string[];\n\n    constructor(output: string[]) {\n        super();\n        this.output = output;\n    }\n\n    public read(buffer: ArrayBuffer, offset: number, size: number): number {\n        throw new InternalError(`CommandOutputFile is not support read`);\n    }\n\n    public write(buffer: ArrayBuffer): number {\n        this.output[0] += fromBytesToString(new DataView(buffer), 0, buffer.byteLength);\n        return buffer.byteLength;\n    }\n\n    public flush(): number {\n        return 0;\n    }\n}\n\nexport class CallbackOutputFile extends VMFile {\n    public callback: (content: string) => void;\n\n    constructor(callback: (content: string) => void) {\n        super();\n        this.callback = callback;\n    }\n\n    public read(buffer: ArrayBuffer, offset: number, size: number): number {\n        throw new InternalError(`CommandOutputFile is not support read`);\n    }\n\n    public write(buffer: ArrayBuffer): number {\n        this.callback(fromBytesToString(new DataView(buffer), 0, buffer.byteLength));\n        return buffer.byteLength;\n    }\n\n    public flush(): number {\n        return 0;\n    }\n}\n","import {SourceMapConsumer} from \"source-map\";\nimport {codegen} from \"../codegen\";\nimport {CompileContext} from \"../codegen/context\";\nimport {CompilerError, PreprocessError} from \"../common/error\";\nimport {BinaryObject} from \"../common/object\";\nimport {Impls, JsAPIMap} from \"../library\";\nimport {link} from \"../linker\";\nimport {CParser} from \"../parser\";\nimport {preprocess} from \"../preprocessor\";\nimport {CallbackOutputFile, StringInputFile} from \"../runtime/vmfile\";\n\n/**\n *  @file\n *  @author zcy <zurl@live.com>\n *  Created at 04/08/2018\n */\n\nexport function getDebugSymbols(name: string, source: string, options: any = {}) {\n    options.fileName = name;\n    const {code, map} = preprocess(name, source);\n    try {\n        const translationUnit = CParser.parse(code, options);\n        const ctx = new CompileContext(name, options, source, map);\n        codegen(translationUnit, ctx);\n        const binary = link(\"main.cpp\", [...precompiledObjects, ctx.toCompiledObject()], options);\n        return {\n            pre: code,\n            asm: binary.dumpInfo,\n        };\n    } catch (e) {\n        const sm = new SourceMapConsumer(map.toString());\n        if (e instanceof CompilerError) {\n            const newStart = sm.originalPositionFor(e.location.start);\n            e.errorLine = source.split(\"\\n\")[newStart.line];\n            e.location.start.line = newStart.line;\n            e.location.start.column = newStart.column;\n        }\n        throw e;\n    }\n}\n\nfunction compile(name: string, source: string, options: any = {}) {\n    options.fileName = name;\n    const {code, map} = preprocess(name, source);\n    try {\n        const translationUnit = CParser.parse(code, options);\n        const ctx = new CompileContext(name, options, source, map);\n        codegen(translationUnit, ctx);\n        return ctx.toCompiledObject();\n    } catch (e) {\n        const sm = new SourceMapConsumer(map.toString());\n        if (e instanceof CompilerError) {\n            const newStart = sm.originalPositionFor(e.location.start);\n            e.errorLine = source.split(\"\\n\")[newStart.line];\n            e.location.start.line = newStart.line;\n            e.location.start.column = newStart.column;\n        }\n        throw e;\n    }\n}\nconst precompiledObjects = Array.from(Impls.keys()).map((x) => compile(x, Impls.get(x)!, {isCpp: true}));\n\n// const LibraryObjects = precompileLibrarys();\n\nexport function compileFile(sourceFileName: string, source: string, isCpp: boolean = true): BinaryObject {\n    const object = compile(sourceFileName, source, {isCpp});\n    const binary = link(\"main.cpp\", [...precompiledObjects, object], {});\n    return binary;\n}\n\nexport const importObj: any = {system: {}};\nfor (const key of Object.keys(JsAPIMap)) {\n    importObj[\"system\"][\"::\" + key] = JsAPIMap[key];\n}\n\nexport {CompilerError} from \"../common/error\";\nexport {NativeRuntime} from \"../runtime/native_runtime\";\nexport {JSRuntime} from \"../runtime/js_runtime\";\nexport {VMFile, StringOutputFile, StringInputFile, CallbackOutputFile, NoInputFile} from \"../runtime/vmfile\";\n"]}