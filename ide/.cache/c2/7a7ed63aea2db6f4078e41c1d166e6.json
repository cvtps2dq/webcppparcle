{"id":"zrEC","dependencies":[{"name":"/Users/tyamackovm/Desktop/Work/Start1T/webcpp/webcppparcle/tsconfig.json","includedInParent":true,"mtime":1722523452290},{"name":"/Users/tyamackovm/Desktop/Work/Start1T/webcpp/webcppparcle/package.json","includedInParent":true,"mtime":1722527743495},{"name":"/Users/tyamackovm/Desktop/Work/Start1T/webcpp/webcppparcle/ide/.browserslistrc","includedInParent":true,"mtime":1722523452209}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.default=\"{\\n    function newPosition(position) {\\n        // For compatibility with source map.\\n        return new AST.Position(position.offset, position.line, position.column - 1);\\n    }\\n\\n    function getLocation() {\\n        const location_ = location();\\n        return new AST.SourceLocation(options.fileName, text(), newPosition(location_.start), newPosition(location_.end));\\n    }\\n\\n    function extractOptional(optional, index) {\\n        return optional ? optional[index] : null;\\n    }\\n\\n    function extractList(list, index) {\\n        return list.map(element => element[index]);\\n    }\\n\\n    function buildList(head, tail, index) {\\n        return [head].concat(extractList(tail, index));\\n    }\\n\\n    function buildBinaryExpression(head, tail) {\\n        return tail.reduce((result, element) => new AST.BinaryExpression(getLocation(), element[1], result, element[3]), head);\\n    }\\n\\n    /**\\n     * @param {string} hexSequence\\n     */\\n    function parseUniversalCharacter(hexSequence) {\\n        // SAFE_NUMBER: At most 0xFFFFFFFF.\\n        const charCode = Number.parseInt(hexSequence, 16);\\n        // The disallowed characters are the characters in the basic character set and the code positions reserved by\\n        // ISO/IEC 10646 for control characters, the character DELETE, and the S-zone (reserved for use by UTF−16).\\n        if ((charCode >= 0x0000 && charCode <= 0x001F)\\n                || (charCode >= 0x007F && charCode <= 0x009F)\\n                || (charCode >= 0xD800 && charCode <= 0xDFFF)) {\\n            error('Disallowed character in universal character name: 0x' + hexSequence, getLocation());\\n        }\\n        return String.fromCharCode(charCode);\\n    }\\n\\n    let scopeRoot = { parent: null, names: new Map() };\\n    let currScope = scopeRoot;\\n    let globalMap = new Map();\\n\\n    function enterScope() {\\n        currScope = { parent: currScope, names: new Map() };\\n    }\\n\\n    function exitScope() {\\n        currScope = currScope.parent;\\n    }\\n\\n    let ID_NAME = 0;\\n    let TYPE_NAME = 1;\\n    let TEMPLATE_FUNC_NAME = 2;\\n    let TEMPLATE_CLASS_NAME = 3;\\n\\n    function getTypeOfName(name, type) {\\n        let c = currScope;\\n        while(c != null) {\\n            if (c.names.has(name)) {\\n                return c.names.get(name);\\n            }\\n            c = c.parent;\\n        }\\n        if(globalMap.has(name)){\\n            return globalMap.get(name);\\n        }\\n        return ID_NAME;\\n    }\\n}\\nStart = TranslationUnit\\nClassSpecifier\\n    = classKey:ClassKeyword _ identifier:TypeDeclarationIdentifier _ ih:BaseClause? _ ScopeStart _ declarations:StructDeclarationList? _ ScopeEnd {\\n        return new AST.ClassSpecifier(getLocation(), classKey, identifier, declarations || [] , ih || []);\\n    }\\n    / classKey:ClassKeyword _ identifier:TypeDeclarationIdentifier {\\n        return new AST.ClassSpecifier(getLocation(), classKey, identifier, null, []);\\n    }\\n\\nClassKeyword\\n    = ('struct' / 'class' / 'union') !IdentifierPart {\\n        return text();\\n    }\\n\\nBaseSpecifier\\n    = lb:AccessControlKey? _ className:TypeIdentifier{\\n        return new AST.BaseSpecifier(getLocation(), lb || \\\"\\\", className);\\n    }\\n\\nBaseClause\\n    = ':' _ head:BaseSpecifier tail:(_ ',' _ BaseSpecifier)* {\\n        return buildList(head, tail, 1);\\n    }\\n\\nStructDeclarationList\\n    = head:StructDeclaration tail:(_ StructDeclaration)* {\\n        return buildList(head, tail, 1);\\n    }\\n\\nAccessControlKey = 'public' / 'private' / 'protect'\\n\\nStructDeclaration\\n    = id:TypeIdentifier _ '(' _ param:ParameterList? _ ')' _ initList:ConstructorInitializeList? _ body:CompoundStatement{\\n        return new AST.ConstructorDeclaration(getLocation(), id, param || new AST.ParameterList(getLocation()), initList || [], body);\\n    }\\n    / id:TypeIdentifier _ '(' _ param:ParameterList? _ ')' _ initList:ConstructorInitializeList? _ ';'{\\n        return new AST.ConstructorDeclaration(getLocation(), id, param || new AST.ParameterList(getLocation()), initList || [], nul);\\n    }\\n    / isVirtual:'virtual'? _ '~' id:TypeIdentifier _ '(' _ ')' _ body:CompoundStatement{\\n        return new AST.DestructorDeclaration(getLocation(), id, body, isVirtual === \\\"virtual\\\");\\n    }\\n    / isVirtual:'virtual'? _ '~' id:TypeIdentifier _ '(' _ ')' _ ';'{\\n        return new AST.DestructorDeclaration(getLocation(), id, null, isVirtual === \\\"virtual\\\");\\n    }\\n    / label:AccessControlKey _ ':' {\\n        return new AST.AccessControlLabel(getLocation(), label);\\n    }\\n    / decl:Declaration {\\n        return decl;\\n    }\\n\\nConstructorInitializeList\\n    = ':' _ head:ConstructorInitializeItem _ tail:(_ ',' _ ConstructorInitializeItem)* {\\n         return buildList(head, tail, 3);\\n    }\\n\\nConstructorInitializeItem\\n    = key:Identifier _ '(' _ value:ArgumentExpressionList _ ')' {\\n        return new AST.ConstructorInitializeItem(getLocation(), key, value, false);\\n    }\\n    / key:TypeIdentifier _ '(' _ value:ArgumentExpressionList _ ')' {\\n        return new AST.ConstructorInitializeItem(getLocation(), key, value, true);\\n    }\\n\\n\\nStructDeclaratorList\\n    = head:StructDeclarator tail:(_ ',' _ StructDeclarator)* {\\n        return buildList(head, tail, 3);\\n    }\\n\\nStructDeclarator\\n    = ':' _ width:ConstantExpression {\\n        return new AST.StructDeclarator(getLocation(), null, width, null);\\n    }\\n    / declarator:Declarator _ initDeclarators:InitDeclaratorList? width:(_ ':' _ ConstantExpression)? {\\n        return new AST.StructDeclarator(getLocation(), declarator, extractOptional(width, 3), initDeclarators);\\n    }\\n\\nEnumSpecifier\\n    = 'enum' !IdentifierPart _ identifier:Identifier? _ '{' _ enumerators:EnumeratorList _ ','? _ &!'}' {\\n        return new AST.EnumSpecifier(getLocation(), identifier, enumerators);\\n    }\\n    / 'enum' !IdentifierPart _ identifier:Identifier {\\n        return new AST.EnumSpecifier(getLocation(), identifier, null);\\n    }\\n\\nEnumeratorList\\n    = head:Enumerator tail:(_ comma:','? _ enumerator:Enumerator)* {\\n        return buildList(head, tail, 3);\\n    }\\n\\n// MODIFICATION: EnumerationConstant => Identifier\\nEnumerator\\n    = identifier:Identifier value:(_ '=' _ ConstantExpression)? {\\n        return new AST.Enumerator(getLocation(), identifier, extractOptional(value, 3));\\n    }\\n\\n\\nConstant\\n    = FloatingConstant\\n    / IntegerConstant\\n    / CharacterConstant\\n\\nIntegerConstant\\n    // REORDER: HexadecimalConstant / OctalConstant\\n    = integer:(constant:(DecimalConstant / HexadecimalConstant / OctalConstant) {\\n        return {\\n            base: constant.base,\\n            value: constant.value,\\n            raw: text()\\n        }\\n        }) suffix:$IntegerSuffix? {\\n        if (suffix.toLowerCase().includes('u')) {\\n            integer.value.unsigned = true;\\n        }\\n        return new AST.IntegerConstant(getLocation(), integer.base, integer.value, integer.raw, suffix || null);\\n    }\\n\\nDecimalConstant\\n    = NonzeroDigit Digit* {\\n        // SAFE_NUMBER: Using Long.\\n        return {\\n            base: 10,\\n            value: Long.fromString(text())\\n        };\\n    }\\n\\nOctalConstant\\n    = '0' digits:$OctalDigit* {\\n        // SAFE_NUMBER: Using Long.\\n        return {\\n            base: 8,\\n            value: digits.length ? Long.fromString(digits, 8) : Long.ZERO\\n        };\\n    }\\n\\nHexadecimalConstant\\n    = HexadecimalPrefix digits:$HexadecimalDigit+ {\\n        // SAFE_NUMBER: Using Long.\\n        return {\\n            base: 16,\\n            value: Long.fromString(digits, 16)\\n        };\\n    }\\n\\nFloatingConstant\\n    = DecimalFloatingConstant\\n\\nDecimalFloatingConstant\\n    = raw:$((FractionalConstant ExponentPart?) / (DigitSequence ExponentPart)) suffix:$FloatingSuffix? {\\n        return new AST.FloatingConstant(getLocation(), Number.parseFloat(raw), raw, suffix || null);\\n    }\\n\\nHexadecimalFractionalConstant\\n    = HexadecimalDigitSequence '.' HexadecimalDigitSequence?\\n    / '.' HexadecimalDigitSequence\\n\\nCharacterConstant\\n    = prefix:$[LuU]? '\\\\'' value:CCharSequence '\\\\'' {\\n        return new AST.CharacterConstant(getLocation(), value, prefix || null);\\n    }\\n\\nEncodingPrefix\\n    = 'u8'\\n    / 'u'\\n    / 'U'\\n    / 'L'\\n\\nUniversalCharacterName\\n    = '\\\\\\\\u' hexQuad:$HexQuad {\\n        return parseUniversalCharacter(hexQuad);\\n    }\\n    / '\\\\\\\\U' hexQuads:$(HexQuad HexQuad) {\\n        return parseUniversalCharacter(hexQuads);\\n    }\\n\\nHexQuad\\n    = HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit\\n\\nStringLiteral\\n    = head:SingleStringLiteral tail:(_ SingleStringLiteral)* {\\n        return buildList(head, tail, 1).reduce((left, right) => {\\n            let prefix = null;\\n            if (left.prefix !== right.prefix) {\\n                if (left.prefix) {\\n                    if (right.prefix) {\\n                        error('Unsupported non-standard concatenation of string literals');\\n                    } else {\\n                        prefix = left.prefix;\\n                    }\\n                } else {\\n                    prefix = right.prefix;\\n                }\\n            } else {\\n                prefix = left.prefix;\\n            }\\n            const value = left.value.slice(0, -1) + right.value;\\n            return new AST.StringLiteral(getLocation(), prefix, value);\\n        });\\n    }\\n\\nSingleStringLiteral\\n    = prefix:$EncodingPrefix? '\\\"' value:SCharSequence? &!'\\\"' {\\n        return new AST.StringLiteral(getLocation(), prefix || null, (value || '') + '\\\\0');\\n    }\\n\\nSCharSequence\\n    = chars:SChar+ {\\n        return chars.join('');\\n    }\\n\\nSChar\\n    = [^\\\"\\\\\\\\\\\\n] // any member of the source character set except the double-quote \\\", backslash \\\\, or new-line character\\n    / EscapeSequence\\n\\nUnaryOperator\\n    = [*+\\\\-~!]\\n    / SingleAnd\\n\\nCCharSequence\\n    = chars:CChar+ {\\n        return chars.join('');\\n    }\\n\\nCChar\\n    = [^'\\\\\\\\\\\\n] // any member of the source character set except the single-quote ', backslash \\\\, or new-line character\\n    / EscapeSequence\\n\\nEscapeSequence\\n    = SimpleEscapeSequence\\n    / OctalEscapeSequence\\n    / HexadecimalEscapeSequence\\n    / UniversalCharacterName\\n\\nSimpleEscapeSequence\\n    = ('\\\\\\\\\\\\''\\n    / '\\\\\\\\\\\"'\\n    / '\\\\\\\\?'\\n    / '\\\\\\\\\\\\\\\\') {\\n        return text().charAt(1);\\n    }\\n    / '\\\\\\\\a' {\\n        return '\\\\x07';\\n    }\\n    / '\\\\\\\\b' {\\n        return '\\\\b';\\n    }\\n    / '\\\\\\\\f' {\\n        return '\\\\f';\\n    }\\n    / '\\\\\\\\n' {\\n        return '\\\\n';\\n    }\\n    / '\\\\\\\\r' {\\n        return '\\\\r';\\n    }\\n    / '\\\\\\\\t' {\\n        return '\\\\t';\\n    }\\n    / '\\\\\\\\v' {\\n        return '\\\\v';\\n    }\\n\\nOctalEscapeSequence\\n    = '\\\\\\\\' digits:$(OctalDigit OctalDigit? OctalDigit?) {\\n        // SAFE_NUMBER: At most 0777.\\n        return String.fromCharCode(Number.parseInt(digits, 8));\\n    }\\n\\nHexadecimalEscapeSequence\\n    = '\\\\\\\\x' digits:$HexadecimalDigit+ {\\n        // TODO: Guard against very long digits.\\n        return String.fromCharCode(Number.parseInt(digits, 16));\\n    }\\n\\nBinaryExponentPart\\n    = [pP] Sign? DigitSequence\\n\\nHexadecimalDigitSequence\\n    = HexadecimalDigit+\\n\\nFloatingSuffix\\n    = [flFL]\\n\\nFractionalConstant\\n    = DigitSequence '.' DigitSequence?\\n    / '.' DigitSequence\\n\\nExponentPart\\n    = [eE] Sign? DigitSequence\\n\\nSign\\n    = [+\\\\-]\\n\\nDigitSequence\\n    = Digit+\\n\\nTranslationUnit\\n    = list:DeclarationList{\\n        return new AST.TranslationUnit(getLocation(), list);\\n    }\\n\\nDeclarationList\\n    = _ head:Declaration tail:(_ Declaration)* _ {\\n        return buildList(head, tail, 1);\\n    }\\n\\nDeclaration\\n    = BlockDeclaration\\n    / FunctionDefinition\\n    / NamespaceDefinition\\n    / TemplateDeclaration\\n    / ExplicitInstantiation\\n    / DeclarationMissingSemicolon\\n\\nBlockDeclaration\\n    = SimpleDeclaration\\n    / UsingStatements\\n\\nBlockDeclarationList\\n    = head:BlockDeclaration tail:(_ BlockDeclaration)*{\\n        return buildList(head, tail, 1);\\n    }\\n\\nNamespaceDefinition\\n    = 'namespace' _ name:Identifier _ '{' _ list:DeclarationList? _'}'{\\n        currScope.names.set(name.getLastID().name, TYPE_NAME);\\n        return new AST.NameSpaceBlock(getLocation(), name, list || []);\\n    }\\n\\nSimpleDeclaration\\n    = specifiers:DeclarationSpecifiers _ initDeclarators:InitDeclaratorList? _ ';' {\\n        const declaration = new AST.Declaration(getLocation(), specifiers, initDeclarators || []);\\n        declaration.getTypedefName().map(name => currScope.names.set(name, TYPE_NAME));\\n        return declaration;\\n    }\\n\\nDeclarationSpecifiers\\n    = head:DeclarationSpecifier tail:(_ DeclarationSpecifier)* {\\n        return new AST.SpecifierList(getLocation(), buildList(head, tail, 1));\\n    }\\n\\nDeclarationSpecifier\\n    = StorageClassSpecifier\\n    / FunctionSpecifier\\n    / TypeSpecifier\\n\\nTypeSpecifierList\\n    = head:TypeSpecifier tail:( _ TypeSpecifier)* {\\n        return buildList(head, tail, 3);\\n    }\\n\\nTypeSpecifier\\n    = ClassSpecifier\\n    / EnumSpecifier\\n    / SimpleTypeSpecifier\\n    / TypenameSpecifier\\n    / TypeQualifier\\n\\nSimpleTypeSpecifier\\n    = PrimitiveTypeSpecifier\\n    / TypeIdentifier\\n\\nTypenameSpecifier\\n    = 'typename' id:TypeIdentifier{\\n        return id;\\n    }\\n\\nTypeQualifier\\n    = ('const' / 'volatile') !IdentifierPart {\\n        return text();\\n    }\\n\\nTypeQualifierList\\n    = head:TypeQualifier tail:(_ TypeQualifier)* {\\n        return buildList(head, tail, 1);\\n    }\\n\\nDeclarator\\n    = pointer:(Pointer _)? declarator:DirectDeclarator {\\n        return pointer ? new AST.PointerDeclarator(getLocation(), declarator, extractOptional(pointer, 0)) : declarator;\\n    }\\n\\nDirectDeclarator\\n    = head:(identifier:Identifier {\\n        return new AST.IdentifierDeclarator(getLocation(), identifier);\\n    } / '(' _ declarator:Declarator _ ')' {\\n        return declarator;\\n    } ) tail:(_ (\\n        '[' _ length:AssignmentExpression? _ &!']' {\\n            return {\\n                location: getLocation(),\\n                type: AST.ArrayDeclarator,\\n                arguments: [false, [], length, false]\\n            };\\n        }\\n        / '(' _ parameters: ParameterList? _ ')' {\\n            return {\\n                location: getLocation(),\\n                type: AST.FunctionDeclarator,\\n                arguments: [parameters || new AST.ParameterList(getLocation())]\\n            }\\n        }\\n    ))* {\\n        return extractList(tail, 1).reduce((result, element) => new element.type(element.location, result, ...element.arguments), head);\\n    }\\n\\nPointer\\n    = '*' _ qualifiers:TypeQualifierList? _ pointer:Pointer? {\\n        return new AST.Pointer(getLocation(), qualifiers || [], pointer, '*');\\n    }\\n    /\\n    '&' _ qualifiers:TypeQualifierList? _ pointer:Pointer? {\\n        return new AST.Pointer(getLocation(), qualifiers || [], pointer, '&');\\n    }\\n    /\\n    '&&' _ qualifiers:TypeQualifierList? _ pointer:Pointer? {\\n        return new AST.Pointer(getLocation(), qualifiers || [], pointer, '&&');\\n    }\\n\\nDeclarationWithoutSemicolon\\n    = specifiers:DeclarationSpecifiers _ initDeclarators:InitDeclaratorList?\\n\\nDeclarationMissingSemicolon\\n    = decl:DeclarationWithoutSemicolon {\\n        error('Missing \\\\';\\\\' at end of declaration');\\n    }\\n\\nFunctionSpecifier = ('inline' / '__libcall')\\n\\nInitDeclaratorList\\n    = head:InitDeclarator tail:(_ ',' _ InitDeclarator)* {\\n        return buildList(head, tail, 3);\\n    }\\n\\nInitDeclarator\\n    = declarator:Declarator initializer:CppInitializer? {\\n        return new AST.InitDeclarator(getLocation(), declarator, initializer || null);\\n    }\\n    \\nCppInitializer\\n    = _'=' _ init:Initializer{\\n        return init;\\n    }\\n    / _ '(' _ arguments_:ArgumentExpressionList? _ ')' {\\n        return new AST.ObjectInitializer(getLocation(),  arguments_ || []);  \\n    }\\n\\n\\nParameterList\\n    = head:ParameterDeclaration tail:(_ ',' _ ParameterDeclaration)* ellipsis:(_ ',' _ '...')? {\\n        return new AST.ParameterList(getLocation(), buildList(head, tail, 3), !!ellipsis);\\n    }\\n\\nParameterDeclaration\\n    = specifiers:DeclarationSpecifiers _ declarator:(Declarator / AbstractDeclarator)? init:( _ '=' _ AssignmentExpression)?{\\n        return new AST.ParameterDeclaration(getLocation(), specifiers, declarator, init ? init[3] : null);\\n    }\\n\\nIdentifierList\\n    = head:Identifier tail:(_ ',' _ Identifier)* {\\n        return buildList(head, tail, 3);\\n    }\\n\\n\\nInitializer\\n    = AssignmentExpression\\n    / '{' _ initializerList:InitializerList _ ','? _ &!'}' {\\n        return initializerList;\\n    }\\n\\nInitializerList\\n    = head:InitializerListItem tail:(_ ',' _ InitializerListItem)* {\\n        return new AST.InitializerList(getLocation(), buildList(head, tail, 3));\\n    }\\n\\nInitializerListItem\\n    = designators:(Designation _)? initializer:Initializer {\\n        return new AST.InitializerListItem(getLocation(), initializer);\\n    }\\n\\nDesignation\\n    = designators:DesignatorList _ '=' {\\n        return designators;\\n    }\\n\\nDesignatorList\\n    = head:Designator tail:(_ Designator)* {\\n        return buildList(head, tail, 1);\\n    }\\n\\nDesignator\\n    = '[' _ subscript:ConstantExpression _ &!']' {\\n        return new AST.SubscriptDesignator(getLocation(), subscript);\\n    }\\n    / '.' _ member:Identifier {\\n        return new AST.MemberDesignator(getLocation(), member);\\n    }\\n\\nFunctionDefinition\\n    = specifiers:DeclarationSpecifiers _ declarator:Declarator _ body:CompoundStatement {\\n        return new AST.FunctionDefinition(getLocation(), specifiers, declarator, body);\\n    }\\n\\nNewTypeName\\n    =  specifierQualifiers:DeclarationSpecifiers _ declarator:NewDeclarator? {\\n        return new AST.TypeName(getLocation(), specifierQualifiers, declarator)\\n    }\\n\\nTypeName\\n    = specifierQualifiers:DeclarationSpecifiers _ declarator:AbstractDeclarator? {\\n        return new AST.TypeName(getLocation(), specifierQualifiers, declarator)\\n    }\\n\\nNewDeclarator\\n    = pointer:Pointer declarator:(_ DirectNewDeclarator)? {\\n        return new AST.PointerDeclarator(getLocation(), null, pointer, extractOptional(declarator, 1));\\n    }\\n    / declarator:DirectNewDeclarator {\\n        return declarator;\\n    }\\n\\nAbstractDeclarator\\n    = pointer:Pointer declarator:(_ DirectAbstractDeclarator)? {\\n        return new AST.PointerDeclarator(getLocation(), null, pointer, extractOptional(declarator, 1));\\n    }\\n    / declarator:DirectAbstractDeclarator {\\n        return declarator;\\n    }\\n\\nDirectNewDeclarator\\n    = head:(element:DirectNewDeclaratorElement {\\n            return new element.type(getLocation(), null, ...element.arguments)\\n        }\\n    ) tail:(_ DirectNewDeclaratorElement)* {\\n        return extractList(tail, 1).reduce((result, element) => new element.type(element.location, result, ...element.arguments), head);\\n    }\\n\\nDirectAbstractDeclarator\\n    = head:(\\n        '(' _ declarator:AbstractDeclarator _ ')' {\\n            return declarator;\\n        }\\n        / element:DirectAbstractDeclaratorElement {\\n            return new element.type(getLocation(), null, ...element.arguments)\\n        }\\n    ) tail:(_ DirectAbstractDeclaratorElement)* {\\n        return extractList(tail, 1).reduce((result, element) => new element.type(element.location, result, ...element.arguments), head);\\n    }\\n\\nDirectNewDeclaratorElement\\n    = '[' _ length:AssignmentExpression? _ &!']' {\\n        return {\\n            location: getLocation(),\\n            type: AST.ArrayDeclarator,\\n            arguments: [false, [], length, false]\\n        };\\n    }\\n\\nDirectAbstractDeclaratorElement\\n    = '(' _ parameters:ParameterList? _ ')' {\\n        return {\\n            location: getLocation(),\\n            type: AST.FunctionDeclarator,\\n            arguments: [parameters || new AST.ParameterList(getLocation())]\\n        }\\n    }\\n    / DirectNewDeclaratorElement\\nTryBlock\\n    = 'try' _ body:CompoundStatement _ handlers:HandlerSeq {\\n        return new AST.TryBlock(getLocation(), body, handlers);\\n    }\\n\\nHandlerSeq\\n    = head:ExceptionHandler tail:(_ ExceptionHandler)* {\\n        return buildList(head, tail, 1);\\n    }\\n\\nExceptionHandler\\n    = 'catch' _ '(' _ decl:ExceptionDeclaration _ ')' _ body:CompoundStatement {\\n        return new AST.ExceptionHandler(getLocation(), decl, body);\\n    }\\n\\nExceptionDeclaration\\n \\t= specifiers:DeclarationSpecifiers _ declarator:Declarator {\\n \\t    return new AST.ExceptionDeclaration(getLocation(), specifiers, declarator);\\n \\t}\\n \\t/ specifiers:DeclarationSpecifiers _ declarator:AbstractDeclarator {\\n \\t    return new AST.ExceptionDeclaration(getLocation(), specifiers, declarator);\\n \\t}\\n\\nThrowExpression\\n \\t= 'throw' _ body:AssignmentExpression? {\\n \\t    return new AST.ThrowExpression(getLocation(), body);\\n \\t}\\nExpression\\n    = head:AssignmentExpression tail:(_ ',' _ AssignmentExpression)* {\\n        return buildBinaryExpression(head, tail);\\n    }\\n\\nAssignmentExpression\\n    = left:UnaryExpression _ operator:AssignmentOperator _ right:AssignmentExpression {\\n        return new AST.AssignmentExpression(getLocation(), operator, left, right);\\n    }\\n    / ConditionalExpression\\n\\nConditionalExpression\\n    = test:LogicalOrExpression _ '?' _ consequent:Expression _ &!':' _ alternate:ConditionalExpression {\\n        return new AST.ConditionalExpression(getLocation(), test, consequent, alternate);\\n    }\\n    / LogicalOrExpression\\n\\n\\nConstructorCallExpression\\n    = name:TypeIdentifier  _ '(' _ arguments_:ArgumentExpressionList? _ &!')' {\\n        return new AST.ConstructorCallExpression(getLocation(), name, arguments_ || []);\\n    }\\n\\nPostfixExpression\\n    = head:( PrimaryExpression / ConstructorCallExpression ) tail:(_ (\\n        '[' _ subscript:Expression _ &!']' {\\n            return {\\n                type: AST.SubscriptExpression,\\n                arguments: [subscript]\\n            };\\n        }\\n        / '(' _ arguments_:ArgumentExpressionList? _ ')' {\\n            return {\\n                type: AST.CallExpression,\\n                arguments: [arguments_ || []]\\n            };\\n        }\\n        / operator:('.' / '->') _ member:Identifier {\\n            return {\\n                type: AST.MemberExpression,\\n                arguments: [operator === '->', member]\\n            };\\n        }\\n        / operator:('++' / '--') {\\n            return {\\n                type: AST.PostfixExpression,\\n                arguments: [operator === '--']\\n            };\\n        }\\n    ))* {\\n        return extractList(tail, 1).reduce((result, element) => new element.type(getLocation(), result, ...element.arguments), head);\\n    }\\n\\nArgumentExpressionList\\n    = head:AssignmentExpression tail:(_ ',' _ AssignmentExpression)* {\\n        return buildList(head, tail, 3);\\n    }\\n\\nUnaryExpression\\n    = operator:('++' / '--') _ operand:UnaryExpression {\\n        return new AST.UnaryExpression(getLocation(), operator, operand);\\n    }\\n    / operator:UnaryOperator _ operand:CastExpression { //Hack: when parse '&' operator, the operator variable will be array of 2 elements\\n        return new AST.UnaryExpression(getLocation(), operator[0], operand);\\n    }\\n    / operator:'sizeof' !IdentifierPart _ operand:UnaryExpression {\\n        return new AST.UnaryExpression(getLocation(), operator, operand);\\n    }\\n    / operator:'sizeof' _ '(' _ operand:TypeName _ ')' {\\n        return new AST.UnaryExpression(getLocation(), operator, operand);\\n    }\\n    / PostfixExpression\\n    / NewExpression\\n    / DeleteExpression\\n\\nCastExpression\\n    = '(' _ typeName:TypeName _ ')' _ operand:CastExpression {\\n        return new AST.CastExpression(getLocation(), typeName, operand);\\n    }\\n    / UnaryExpression\\n\\nMultiplicativeExpression\\n    = head:CastExpression tail:(_ [*/%] _ CastExpression)* {\\n        return buildBinaryExpression(head, tail);\\n    }\\n\\nAdditiveExpression\\n    = head:MultiplicativeExpression tail:(_ [+\\\\-] _ MultiplicativeExpression)* {\\n        return buildBinaryExpression(head, tail);\\n    }\\n\\nShiftExpression\\n    = head:AdditiveExpression tail:(_ ('<<' / '>>') _ AdditiveExpression)* {\\n        return buildBinaryExpression(head, tail);\\n    }\\n\\nRelationalExpression\\n    = head:ShiftExpression tail:(_ ('<=' / '>=' / '<' / '>') _ ShiftExpression)* {\\n        return buildBinaryExpression(head, tail);\\n    }\\n\\nEqualityExpression\\n    = head:RelationalExpression tail:(_ ('==' / '!=') _ RelationalExpression)* {\\n        return buildBinaryExpression(head, tail);\\n    }\\n\\nAndExpression\\n    = head:EqualityExpression tail:(_ SingleAnd _ EqualityExpression)* {\\n        return buildBinaryExpression(head, tail);\\n    }\\n\\nExclusiveOrExpression\\n    = head:AndExpression tail:(_ '^' _ AndExpression)* {\\n        return buildBinaryExpression(head, tail);\\n    }\\n\\nInclusiveOrExpression\\n    = head:ExclusiveOrExpression tail:(_ '|' _ ExclusiveOrExpression)* {\\n        return buildBinaryExpression(head, tail);\\n    }\\n\\nLogicalAndExpression\\n    = head:InclusiveOrExpression tail:(_ AndAnd _ InclusiveOrExpression)* {\\n        return buildBinaryExpression(head, tail);\\n    }\\n\\nLogicalOrExpression\\n    = head:LogicalAndExpression tail:(_ '||' _ LogicalAndExpression)* {\\n        return buildBinaryExpression(head, tail);\\n    }\\n\\nConstantExpression\\n    = ConditionalExpression\\n\\nPrimaryExpression\\n    = Identifier\\n    / Constant\\n    / StringLiteral\\n    / '(' _ expression:Expression _ &!')' {\\n        return expression;\\n    }\\n\\n\\n\\nNewPlacement\\n    = '(' _  item:AssignmentExpression _ ')' {\\n        return item;\\n    }\\n\\nNewInitializer\\n    = '(' _ arguments_:ArgumentExpressionList? _ ')' {\\n        return arguments_;\\n    }\\n\\nNewExpression\\n    = '::'? 'new' !IdentifierPart _ placement:NewPlacement? _ type:NewTypeName _ initializer:NewInitializer?{\\n        return new AST.NewExpression(getLocation(), type, initializer || [], placement || null);\\n    }\\n    / '::'? 'new' !IdentifierPart _ placement:NewPlacement? _ '(' _ name:TypeName _ ')' _ initializer:NewInitializer?{\\n        return new AST.NewExpression(getLocation(), type, initializer || [], placement || null);\\n    }\\n\\nDeleteExpression\\n    = 'delete' _ expr:AssignmentExpression {\\n        return new AST.DeleteExpression(getLocation(), expr, false);\\n    }\\n    / 'delete[]' _ expr:AssignmentExpression {\\n        return new AST.DeleteExpression(getLocation(), expr, true);\\n    }\\nId\\n    = !Keyword head:IdentifierNondigit tail:IdentifierPart* {\\n        return new AST.SingleIdentifier(getLocation(), head + tail.join(''), AST.IDType.ID, []);\\n    }\\n\\nSingleIdentifier\\n    = id:Id &{\\n        return getTypeOfName(id.name) === ID_NAME;\\n    } {\\n        return id;\\n    }\\n    / 'operator' _ ope:OverloadOperator {\\n        return new AST.SingleIdentifier(getLocation(), \\\"#\\\" + ope, AST.IDType.ID, []);\\n    }\\n    / '~' name:TypeIdentifier {\\n        const result = name.clone();\\n        result.getLastID().name = '~' + result.identifier.name;\\n        result.getLastID().type = AST.IDType.TYPE;\\n        return result;\\n    }\\n\\nSingleTypeIdentifier\\n    =  id:Id &{\\n        return getTypeOfName(id.name) === TYPE_NAME;\\n    } {\\n        id.type = AST.IDType.TYPE;\\n        return id;\\n    }\\n\\nSingleTemplateFuncIdentifier\\n    =  id:Id &{\\n        return getTypeOfName(id.name) === TEMPLATE_FUNC_NAME;\\n    } {\\n        id.type = AST.IDType.T_FUNC;\\n        return id;\\n    }\\n\\nSingleTemplateClassIdentifier\\n    =  id:Id &{\\n        return getTypeOfName(id.name) === TEMPLATE_CLASS_NAME;\\n    } {\\n        id.type = AST.IDType.T_CLASS;\\n        return id;\\n    }\\n\\nUnifiedIdentifier\\n    = SingleTypeIdentifier/ TemplateClassInstanceIdentifier\\n\\nIdentifier\\n    = isFullName:'::'? namespace:(UnifiedIdentifier '::')* name:(SingleIdentifier/TemplateFuncInstanceIdentifier) {\\n        return new AST.Identifier(getLocation(), namespace.map(x=>x[0]).concat([name]), isFullName);\\n    }\\n\\nTypeIdentifier\\n    = isFullName:'::'? namespace:(UnifiedIdentifier '::')* name:UnifiedIdentifier {\\n        return new AST.Identifier(getLocation(), namespace.map(x=>x[0]).concat([name]), isFullName);\\n    }\\n\\nTemplateFuncIdentifier\\n    = isFullName:'::'? namespace:(UnifiedIdentifier '::')* name:SingleTemplateFuncIdentifier {\\n        return new AST.Identifier(getLocation(), namespace.map(x=>x[0]).concat([name]), isFullName);\\n    }\\n\\nTemplateClassIdentifier\\n    = isFullName:'::'? namespace:(SingleTypeIdentifier '::')* name:SingleTemplateClassIdentifier {\\n        return new AST.Identifier(getLocation(), namespace.map(x=>x[0]).concat([name]), isFullName);\\n    }\\n\\nTypeDeclarationIdentifier\\n    = identifier:Identifier{\\n        if( options.isCpp ) {\\n            globalMap.set(identifier.getLastID().name, TYPE_NAME);\\n            currScope.names.set(identifier.getLastID().name, TYPE_NAME);\\n        }\\n        return identifier;\\n    }\\n\\nWhiteSpace = [ \\\\t\\\\n\\\\v\\\\f]\\n\\n_ = WhiteSpace*\\n\\nKeyword\\n    = ('auto'\\n    / 'break'\\n    / 'case'\\n    / 'char'\\n    / 'const'\\n    / 'continue'\\n    / 'default'\\n    / 'double'\\n    / 'do'\\n    / 'else'\\n    / 'enum'\\n    / 'extern'\\n    / 'float'\\n    / 'for'\\n    / 'goto'\\n    / 'if'\\n    / 'inline'\\n    / 'int'\\n    / 'long'\\n    / 'register'\\n    / 'restrict'\\n    / 'return'\\n    / 'short'\\n    / 'signed'\\n    / 'sizeof'\\n    / 'static'\\n    / 'struct'\\n    / 'switch'\\n    / 'typedef'\\n    / 'union'\\n    / 'unsigned'\\n    / 'void'\\n    / 'volatile'\\n    / 'while'\\n    / 'class'\\n    / 'new'\\n    / 'delete'\\n    / 'operator'\\n    / 'override'\\n    / 'template'\\n    / 'typename'\\n    / 'namespace'\\n    / 'using') !IdentifierPart\\n\\nStorageClassSpecifier\\n    = ('typedef'\\n    / 'extern'\\n    / 'static'\\n    / 'virtual'\\n    / 'auto'\\n    / 'register') !IdentifierPart {\\n        return text();\\n    }\\n\\nPrimitiveTypeSpecifier\\n    = ('void'\\n    / 'char'\\n    / 'short'\\n    / 'int'\\n    / 'long'\\n    / 'float'\\n    / 'double'\\n    / 'signed'\\n    / 'unsigned'\\n    / 'bool') !IdentifierPart {\\n        return text();\\n     }\\n\\nOverloadOperator\\n    = '+' / '-' / '*' / '/' / '%' / '&' / '<' / '>' / '<=' / '>=' / '==' / '!='\\n    / '|' / '^' / '!' / '~' / '&&' / '||' / '>>' / '<<' / '++' / '--'\\n    /'()' / '[]' / '->'\\n    / AssignmentOperator\\n\\nAssignmentOperator\\n    = '=' !'=' {\\n        return text();\\n    }\\n    / '*='\\n    / '/='\\n    / '%='\\n    / '+='\\n    / '-='\\n    / '<<='\\n    / '>>='\\n    / '&='\\n    / '^='\\n    / '|='\\n\\nAndAnd\\n    = '&&'\\n\\nSingleAnd\\n    = '&'!'&'\\n\\nHexadecimalPrefix\\n    = '0x'\\n    / '0X'\\n\\nNonzeroDigit\\n    = [1-9]\\n\\nOctalDigit\\n    = [0-7]\\n\\nHexadecimalDigit\\n    = [0-9a-fA-F]\\n\\nIntegerSuffix\\n    = UnsignedSuffix (LongLongSuffix / LongSuffix)?\\n    / (LongLongSuffix / LongSuffix) UnsignedSuffix?\\n\\nUnsignedSuffix\\n    = [uU]\\n\\nLongSuffix\\n    = [lL]\\n\\nLongLongSuffix\\n    = 'll'\\n    / 'LL'\\n\\nIdentifierPart\\n    = IdentifierNondigit\\n    / Digit\\n\\nIdentifierNondigit\\n    = UniversalCharacterName\\n    / Nondigit\\n\\nNondigit\\n    = [_a-zA-Z]\\n\\nDigit\\n    = [0-9]\\n\\nStatement\\n    = CaseStatement\\n    / SelectionStatement\\n    / IterationStatement\\n    / JumpStatement\\n    / CompoundStatement\\n    / LabeledStatement\\n    / ExpressionStatement\\n    / UsingStatements\\n\\n// ADDED\\nCaseStatement\\n    = 'case' !IdentifierPart _ test:ConstantExpression _ &!':' _ body:Statement {\\n        return new AST.CaseStatement(getLocation(), test, body);\\n    }\\n    / 'default' !IdentifierPart _ &!':' _ body:Statement {\\n        return new AST.CaseStatement(getLocation(), null, body)\\n    }\\n\\n// MODIFICATION: No case or default.\\nLabeledStatement\\n    = label:Identifier _ ':' _ body:Statement {\\n        return new AST.LabeledStatement(getLocation(), label, body);\\n    }\\n\\nScopeStart\\n    = '{' {\\n        enterScope();\\n        return getLocation();\\n    }\\n\\nScopeEnd\\n    = &!'}' {\\n        exitScope();\\n        return getLocation();\\n    }\\n\\nCompoundStatement\\n    = left:ScopeStart _ body:BlockItemList? _ right:ScopeEnd {\\n        return new AST.CompoundStatement(getLocation(), body || []);\\n    }\\n\\nBlockItemList\\n    = head:BlockItem tail:(_ BlockItem)* {\\n        return buildList(head, tail, 1);\\n    }\\n\\nBlockItem\\n    = Statement\\n    / Declaration\\n    / Expression { // ExpressionStatementMissingSemicolon\\n        error('Missing \\\\';\\\\' at end of statement');\\n    }\\n    / DeclarationMissingSemicolon\\n\\nExpressionStatement\\n    = expression:(Expression _)? ';' {\\n        return expression ? new AST.ExpressionStatement(getLocation(), extractOptional(expression, 0))\\n                : new AST.NullStatement(getLocation());\\n    }\\n\\nSelectionStatement\\n    = 'if' !IdentifierPart _ &!'(' _ test:Expression _ &!')' _ consequent:Statement alternate:(_ 'else' !IdentifierPart _ Statement)? {\\n        return new AST.IfStatement(getLocation(), test, consequent, extractOptional(alternate, 4));\\n    }\\n    / 'switch' !IdentifierPart _ &!'(' _ discriminant:Expression _ &!')' _ body:Statement {\\n        return new AST.SwitchStatement(getLocation(), discriminant, body);\\n    }\\n\\nIterationStatement\\n    = 'while' !IdentifierPart _ &!'(' _ test:Expression _ &!')' _ body:Statement {\\n        return new AST.WhileStatement(getLocation(), test, body);\\n    }\\n    / 'do' !IdentifierPart _ body:Statement _ 'while' !IdentifierPart _ &!'(' _ test:Expression _ &!')' _ &!';' {\\n        return new AST.DoWhileStatement(getLocation(), body, test);\\n    }\\n    / 'for' !IdentifierPart _ &!'(' _ init:(Declaration / expression:Expression? _ ';' {\\n        return expression;\\n    } / (DeclarationWithoutSemicolon / Expression) {\\n        error('Missing \\\\';\\\\'');\\n    }) _ test:Expression? _ &!';' _ update:Expression? _ &!')' _ body:Statement {\\n        return new AST.ForStatement(getLocation(), init, test, update, body);\\n    }\\n\\nJumpStatement\\n    = 'goto' !IdentifierPart _ label:Identifier _ &!';' {\\n        return new AST.GotoStatement(getLocation(), label);\\n    }\\n    / 'continue' !IdentifierPart _ &!';' {\\n        return new AST.ContinueStatement(getLocation());\\n    }\\n    / 'break' !IdentifierPart _ &!';' {\\n        return new AST.BreakStatement(getLocation());\\n    }\\n    / 'return' !IdentifierPart _ argument:Expression? _ &!';' {\\n        return new AST.ReturnStatement(getLocation(), argument);\\n    }\\n\\n\\nUsingStatements\\n    = 'using' _ name:Identifier _ '=' _ decl:TypeName _ ';'{\\n        currScope.names.set(name.getLastID().name, TYPE_NAME);\\n        return new AST.UsingStatement(getLocation(), name, decl);\\n    }\\n    / 'using' _ name:(Identifier/TypeIdentifier/TemplateClassIdentifier/TemplateFuncIdentifier) _ ';'{\\n        return new AST.UsingStatement(getLocation(), name);\\n    }\\n    / 'using' _ 'namespace' _ name:TypeIdentifier _ ';'{\\n        return new AST.UsingNamespaceStatement(getLocation(), name);\\n    }\\nTemplateDeclaration\\n    = 'template' _ '<' _ &{\\n        enterScope();\\n        return true;\\n    } param:TemplateParameterList? _ &!'>' _ decl:(ClassSpecifierWithSemi/FunctionDefinition) {\\n        exitScope();\\n        const result = new AST.TemplateDeclaration(getLocation(), decl, param || []);\\n        const names = result.getTemplateNames();\\n        const typeId = (decl instanceof AST.FunctionDefinition) ? TEMPLATE_FUNC_NAME : TEMPLATE_CLASS_NAME;\\n        names.map(name => {currScope.names.set(name, typeId);\\n        if(typeId === TEMPLATE_CLASS_NAME) globalMap.set(name, typeId);});\\n        return result;\\n    }\\n\\nClassSpecifierWithSemi\\n    = id:ClassSpecifier _ ';' {\\n        return id;\\n    }\\n\\nTemplateParameterList\\n    = head:TemplateParameter tail:(_ ',' _ TemplateParameter)* {\\n        return buildList(head, tail, 3);\\n    }\\n\\nTemplateParameter\\n    = TypeParameter\\n    / ParameterDeclaration;\\n\\nTypeNameKeyword = 'class' / 'typename'\\n\\n// TODO:: identifier is optional?\\nTypeParameter\\n    = TypeNameKeyword _ id:TypeDeclarationIdentifier init:( _ '=' _ TypeName)? {\\n        return new AST.TypeParameter(getLocation(), id, init ? init[3] : null);\\n    }\\n\\nTemplateFuncInstanceIdentifier\\n    = id:SingleTemplateFuncIdentifier opt:(_ '<' _ TemplateArgumentList? _ &!'>' _ )? {\\n        id.type = AST.IDType.T_FUNC_INS;\\n        id.args = opt ? (opt[3] || []) : [];\\n        return id;\\n    }\\n\\nTemplateClassInstanceIdentifier\\n    = id:SingleTemplateClassIdentifier opt:(_ '<' _ TemplateArgumentList? _ &!'>' _ )? {\\n        id.type = AST.IDType.T_CLASS_INS;\\n        id.args = opt ? (opt[3] || []) : [];\\n        return id;\\n    }\\n\\nTemplateArgumentList\\n    = head:TemplateArgument tail:(_ ',' _ TemplateArgument)* {\\n        return buildList(head, tail, 3);\\n    }\\n\\nTemplateArgument\\n    = item:TypeName {\\n        return new AST.TemplateArgument(getLocation(), item);\\n    }\\n    / item:AdditiveExpression {\\n        return new AST.TemplateArgument(getLocation(), item);\\n    }\\n\\nExplicitInstantiation\\n    = FunctionTemplateInstantiation\\n    / ClassTemplateInstantiation\\n\\nFunctionTemplateInstantiation\\n    = 'template' _ specifiers:DeclarationSpecifiers _ declarator:Declarator _ ';'{\\n        return new AST.FunctionTemplateInstantiation(getLocation(), specifiers, declarator);\\n    }\\n\\nClassTemplateInstantiation\\n    = 'template' _ spec:ClassSpecifier _ ';'{\\n        return new AST.ClassTemplateInstantiation(getLocation(), spec);\\n    }\";"},"sourceMaps":{"js":{"mappings":[{"source":"../src/parser/c.lang.ts","name":null,"original":{"line":1244,"column":6},"generated":{"line":1,"column":0}},{"source":"../src/parser/c.lang.ts","name":null,"original":{"line":1244,"column":6},"generated":{"line":1,"column":13}},{"source":"../src/parser/c.lang.ts","name":null,"original":{"line":1244,"column":6},"generated":{"line":1,"column":20}},{"source":"../src/parser/c.lang.ts","name":null,"original":{"line":1244,"column":6},"generated":{"line":1,"column":35}},{"source":"../src/parser/c.lang.ts","name":null,"original":{"line":1244,"column":6},"generated":{"line":1,"column":43}},{"source":"../src/parser/c.lang.ts","name":null,"original":{"line":1244,"column":6},"generated":{"line":1,"column":56}},{"source":"../src/parser/c.lang.ts","name":null,"original":{"line":1244,"column":6},"generated":{"line":1,"column":57}},{"source":"../src/parser/c.lang.ts","name":null,"original":{"line":1244,"column":6},"generated":{"line":1,"column":64}},{"source":"../src/parser/c.lang.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":1,"column":68}},{"source":"../src/parser/c.lang.ts","name":null,"original":{"line":3,"column":0},"generated":{"line":1,"column":76}},{"source":"../src/parser/c.lang.ts","name":null,"original":{"line":3,"column":15},"generated":{"line":1,"column":84}}],"sources":{"../src/parser/c.lang.ts":"/* tslint:disable */\n// generate from resource/grammar        \nexport default `{\n    function newPosition(position) {\n        // For compatibility with source map.\n        return new AST.Position(position.offset, position.line, position.column - 1);\n    }\n\n    function getLocation() {\n        const location_ = location();\n        return new AST.SourceLocation(options.fileName, text(), newPosition(location_.start), newPosition(location_.end));\n    }\n\n    function extractOptional(optional, index) {\n        return optional ? optional[index] : null;\n    }\n\n    function extractList(list, index) {\n        return list.map(element => element[index]);\n    }\n\n    function buildList(head, tail, index) {\n        return [head].concat(extractList(tail, index));\n    }\n\n    function buildBinaryExpression(head, tail) {\n        return tail.reduce((result, element) => new AST.BinaryExpression(getLocation(), element[1], result, element[3]), head);\n    }\n\n    /**\n     * @param {string} hexSequence\n     */\n    function parseUniversalCharacter(hexSequence) {\n        // SAFE_NUMBER: At most 0xFFFFFFFF.\n        const charCode = Number.parseInt(hexSequence, 16);\n        // The disallowed characters are the characters in the basic character set and the code positions reserved by\n        // ISO/IEC 10646 for control characters, the character DELETE, and the S-zone (reserved for use by UTF−16).\n        if ((charCode >= 0x0000 && charCode <= 0x001F)\n                || (charCode >= 0x007F && charCode <= 0x009F)\n                || (charCode >= 0xD800 && charCode <= 0xDFFF)) {\n            error('Disallowed character in universal character name: 0x' + hexSequence, getLocation());\n        }\n        return String.fromCharCode(charCode);\n    }\n\n    let scopeRoot = { parent: null, names: new Map() };\n    let currScope = scopeRoot;\n    let globalMap = new Map();\n\n    function enterScope() {\n        currScope = { parent: currScope, names: new Map() };\n    }\n\n    function exitScope() {\n        currScope = currScope.parent;\n    }\n\n    let ID_NAME = 0;\n    let TYPE_NAME = 1;\n    let TEMPLATE_FUNC_NAME = 2;\n    let TEMPLATE_CLASS_NAME = 3;\n\n    function getTypeOfName(name, type) {\n        let c = currScope;\n        while(c != null) {\n            if (c.names.has(name)) {\n                return c.names.get(name);\n            }\n            c = c.parent;\n        }\n        if(globalMap.has(name)){\n            return globalMap.get(name);\n        }\n        return ID_NAME;\n    }\n}\nStart = TranslationUnit\nClassSpecifier\n    = classKey:ClassKeyword _ identifier:TypeDeclarationIdentifier _ ih:BaseClause? _ ScopeStart _ declarations:StructDeclarationList? _ ScopeEnd {\n        return new AST.ClassSpecifier(getLocation(), classKey, identifier, declarations || [] , ih || []);\n    }\n    / classKey:ClassKeyword _ identifier:TypeDeclarationIdentifier {\n        return new AST.ClassSpecifier(getLocation(), classKey, identifier, null, []);\n    }\n\nClassKeyword\n    = ('struct' / 'class' / 'union') !IdentifierPart {\n        return text();\n    }\n\nBaseSpecifier\n    = lb:AccessControlKey? _ className:TypeIdentifier{\n        return new AST.BaseSpecifier(getLocation(), lb || \"\", className);\n    }\n\nBaseClause\n    = ':' _ head:BaseSpecifier tail:(_ ',' _ BaseSpecifier)* {\n        return buildList(head, tail, 1);\n    }\n\nStructDeclarationList\n    = head:StructDeclaration tail:(_ StructDeclaration)* {\n        return buildList(head, tail, 1);\n    }\n\nAccessControlKey = 'public' / 'private' / 'protect'\n\nStructDeclaration\n    = id:TypeIdentifier _ '(' _ param:ParameterList? _ ')' _ initList:ConstructorInitializeList? _ body:CompoundStatement{\n        return new AST.ConstructorDeclaration(getLocation(), id, param || new AST.ParameterList(getLocation()), initList || [], body);\n    }\n    / id:TypeIdentifier _ '(' _ param:ParameterList? _ ')' _ initList:ConstructorInitializeList? _ ';'{\n        return new AST.ConstructorDeclaration(getLocation(), id, param || new AST.ParameterList(getLocation()), initList || [], nul);\n    }\n    / isVirtual:'virtual'? _ '~' id:TypeIdentifier _ '(' _ ')' _ body:CompoundStatement{\n        return new AST.DestructorDeclaration(getLocation(), id, body, isVirtual === \"virtual\");\n    }\n    / isVirtual:'virtual'? _ '~' id:TypeIdentifier _ '(' _ ')' _ ';'{\n        return new AST.DestructorDeclaration(getLocation(), id, null, isVirtual === \"virtual\");\n    }\n    / label:AccessControlKey _ ':' {\n        return new AST.AccessControlLabel(getLocation(), label);\n    }\n    / decl:Declaration {\n        return decl;\n    }\n\nConstructorInitializeList\n    = ':' _ head:ConstructorInitializeItem _ tail:(_ ',' _ ConstructorInitializeItem)* {\n         return buildList(head, tail, 3);\n    }\n\nConstructorInitializeItem\n    = key:Identifier _ '(' _ value:ArgumentExpressionList _ ')' {\n        return new AST.ConstructorInitializeItem(getLocation(), key, value, false);\n    }\n    / key:TypeIdentifier _ '(' _ value:ArgumentExpressionList _ ')' {\n        return new AST.ConstructorInitializeItem(getLocation(), key, value, true);\n    }\n\n\nStructDeclaratorList\n    = head:StructDeclarator tail:(_ ',' _ StructDeclarator)* {\n        return buildList(head, tail, 3);\n    }\n\nStructDeclarator\n    = ':' _ width:ConstantExpression {\n        return new AST.StructDeclarator(getLocation(), null, width, null);\n    }\n    / declarator:Declarator _ initDeclarators:InitDeclaratorList? width:(_ ':' _ ConstantExpression)? {\n        return new AST.StructDeclarator(getLocation(), declarator, extractOptional(width, 3), initDeclarators);\n    }\n\nEnumSpecifier\n    = 'enum' !IdentifierPart _ identifier:Identifier? _ '{' _ enumerators:EnumeratorList _ ','? _ &!'}' {\n        return new AST.EnumSpecifier(getLocation(), identifier, enumerators);\n    }\n    / 'enum' !IdentifierPart _ identifier:Identifier {\n        return new AST.EnumSpecifier(getLocation(), identifier, null);\n    }\n\nEnumeratorList\n    = head:Enumerator tail:(_ comma:','? _ enumerator:Enumerator)* {\n        return buildList(head, tail, 3);\n    }\n\n// MODIFICATION: EnumerationConstant => Identifier\nEnumerator\n    = identifier:Identifier value:(_ '=' _ ConstantExpression)? {\n        return new AST.Enumerator(getLocation(), identifier, extractOptional(value, 3));\n    }\n\n\nConstant\n    = FloatingConstant\n    / IntegerConstant\n    / CharacterConstant\n\nIntegerConstant\n    // REORDER: HexadecimalConstant / OctalConstant\n    = integer:(constant:(DecimalConstant / HexadecimalConstant / OctalConstant) {\n        return {\n            base: constant.base,\n            value: constant.value,\n            raw: text()\n        }\n        }) suffix:$IntegerSuffix? {\n        if (suffix.toLowerCase().includes('u')) {\n            integer.value.unsigned = true;\n        }\n        return new AST.IntegerConstant(getLocation(), integer.base, integer.value, integer.raw, suffix || null);\n    }\n\nDecimalConstant\n    = NonzeroDigit Digit* {\n        // SAFE_NUMBER: Using Long.\n        return {\n            base: 10,\n            value: Long.fromString(text())\n        };\n    }\n\nOctalConstant\n    = '0' digits:$OctalDigit* {\n        // SAFE_NUMBER: Using Long.\n        return {\n            base: 8,\n            value: digits.length ? Long.fromString(digits, 8) : Long.ZERO\n        };\n    }\n\nHexadecimalConstant\n    = HexadecimalPrefix digits:$HexadecimalDigit+ {\n        // SAFE_NUMBER: Using Long.\n        return {\n            base: 16,\n            value: Long.fromString(digits, 16)\n        };\n    }\n\nFloatingConstant\n    = DecimalFloatingConstant\n\nDecimalFloatingConstant\n    = raw:$((FractionalConstant ExponentPart?) / (DigitSequence ExponentPart)) suffix:$FloatingSuffix? {\n        return new AST.FloatingConstant(getLocation(), Number.parseFloat(raw), raw, suffix || null);\n    }\n\nHexadecimalFractionalConstant\n    = HexadecimalDigitSequence '.' HexadecimalDigitSequence?\n    / '.' HexadecimalDigitSequence\n\nCharacterConstant\n    = prefix:$[LuU]? '\\\\'' value:CCharSequence '\\\\'' {\n        return new AST.CharacterConstant(getLocation(), value, prefix || null);\n    }\n\nEncodingPrefix\n    = 'u8'\n    / 'u'\n    / 'U'\n    / 'L'\n\nUniversalCharacterName\n    = '\\\\\\\\u' hexQuad:$HexQuad {\n        return parseUniversalCharacter(hexQuad);\n    }\n    / '\\\\\\\\U' hexQuads:$(HexQuad HexQuad) {\n        return parseUniversalCharacter(hexQuads);\n    }\n\nHexQuad\n    = HexadecimalDigit HexadecimalDigit HexadecimalDigit HexadecimalDigit\n\nStringLiteral\n    = head:SingleStringLiteral tail:(_ SingleStringLiteral)* {\n        return buildList(head, tail, 1).reduce((left, right) => {\n            let prefix = null;\n            if (left.prefix !== right.prefix) {\n                if (left.prefix) {\n                    if (right.prefix) {\n                        error('Unsupported non-standard concatenation of string literals');\n                    } else {\n                        prefix = left.prefix;\n                    }\n                } else {\n                    prefix = right.prefix;\n                }\n            } else {\n                prefix = left.prefix;\n            }\n            const value = left.value.slice(0, -1) + right.value;\n            return new AST.StringLiteral(getLocation(), prefix, value);\n        });\n    }\n\nSingleStringLiteral\n    = prefix:$EncodingPrefix? '\"' value:SCharSequence? &!'\"' {\n        return new AST.StringLiteral(getLocation(), prefix || null, (value || '') + '\\\\0');\n    }\n\nSCharSequence\n    = chars:SChar+ {\n        return chars.join('');\n    }\n\nSChar\n    = [^\"\\\\\\\\\\\\n] // any member of the source character set except the double-quote \", backslash \\\\, or new-line character\n    / EscapeSequence\n\nUnaryOperator\n    = [*+\\\\-~!]\n    / SingleAnd\n\nCCharSequence\n    = chars:CChar+ {\n        return chars.join('');\n    }\n\nCChar\n    = [^'\\\\\\\\\\\\n] // any member of the source character set except the single-quote ', backslash \\\\, or new-line character\n    / EscapeSequence\n\nEscapeSequence\n    = SimpleEscapeSequence\n    / OctalEscapeSequence\n    / HexadecimalEscapeSequence\n    / UniversalCharacterName\n\nSimpleEscapeSequence\n    = ('\\\\\\\\\\\\''\n    / '\\\\\\\\\"'\n    / '\\\\\\\\?'\n    / '\\\\\\\\\\\\\\\\') {\n        return text().charAt(1);\n    }\n    / '\\\\\\\\a' {\n        return '\\\\x07';\n    }\n    / '\\\\\\\\b' {\n        return '\\\\b';\n    }\n    / '\\\\\\\\f' {\n        return '\\\\f';\n    }\n    / '\\\\\\\\n' {\n        return '\\\\n';\n    }\n    / '\\\\\\\\r' {\n        return '\\\\r';\n    }\n    / '\\\\\\\\t' {\n        return '\\\\t';\n    }\n    / '\\\\\\\\v' {\n        return '\\\\v';\n    }\n\nOctalEscapeSequence\n    = '\\\\\\\\' digits:$(OctalDigit OctalDigit? OctalDigit?) {\n        // SAFE_NUMBER: At most 0777.\n        return String.fromCharCode(Number.parseInt(digits, 8));\n    }\n\nHexadecimalEscapeSequence\n    = '\\\\\\\\x' digits:$HexadecimalDigit+ {\n        // TODO: Guard against very long digits.\n        return String.fromCharCode(Number.parseInt(digits, 16));\n    }\n\nBinaryExponentPart\n    = [pP] Sign? DigitSequence\n\nHexadecimalDigitSequence\n    = HexadecimalDigit+\n\nFloatingSuffix\n    = [flFL]\n\nFractionalConstant\n    = DigitSequence '.' DigitSequence?\n    / '.' DigitSequence\n\nExponentPart\n    = [eE] Sign? DigitSequence\n\nSign\n    = [+\\\\-]\n\nDigitSequence\n    = Digit+\n\nTranslationUnit\n    = list:DeclarationList{\n        return new AST.TranslationUnit(getLocation(), list);\n    }\n\nDeclarationList\n    = _ head:Declaration tail:(_ Declaration)* _ {\n        return buildList(head, tail, 1);\n    }\n\nDeclaration\n    = BlockDeclaration\n    / FunctionDefinition\n    / NamespaceDefinition\n    / TemplateDeclaration\n    / ExplicitInstantiation\n    / DeclarationMissingSemicolon\n\nBlockDeclaration\n    = SimpleDeclaration\n    / UsingStatements\n\nBlockDeclarationList\n    = head:BlockDeclaration tail:(_ BlockDeclaration)*{\n        return buildList(head, tail, 1);\n    }\n\nNamespaceDefinition\n    = 'namespace' _ name:Identifier _ '{' _ list:DeclarationList? _'}'{\n        currScope.names.set(name.getLastID().name, TYPE_NAME);\n        return new AST.NameSpaceBlock(getLocation(), name, list || []);\n    }\n\nSimpleDeclaration\n    = specifiers:DeclarationSpecifiers _ initDeclarators:InitDeclaratorList? _ ';' {\n        const declaration = new AST.Declaration(getLocation(), specifiers, initDeclarators || []);\n        declaration.getTypedefName().map(name => currScope.names.set(name, TYPE_NAME));\n        return declaration;\n    }\n\nDeclarationSpecifiers\n    = head:DeclarationSpecifier tail:(_ DeclarationSpecifier)* {\n        return new AST.SpecifierList(getLocation(), buildList(head, tail, 1));\n    }\n\nDeclarationSpecifier\n    = StorageClassSpecifier\n    / FunctionSpecifier\n    / TypeSpecifier\n\nTypeSpecifierList\n    = head:TypeSpecifier tail:( _ TypeSpecifier)* {\n        return buildList(head, tail, 3);\n    }\n\nTypeSpecifier\n    = ClassSpecifier\n    / EnumSpecifier\n    / SimpleTypeSpecifier\n    / TypenameSpecifier\n    / TypeQualifier\n\nSimpleTypeSpecifier\n    = PrimitiveTypeSpecifier\n    / TypeIdentifier\n\nTypenameSpecifier\n    = 'typename' id:TypeIdentifier{\n        return id;\n    }\n\nTypeQualifier\n    = ('const' / 'volatile') !IdentifierPart {\n        return text();\n    }\n\nTypeQualifierList\n    = head:TypeQualifier tail:(_ TypeQualifier)* {\n        return buildList(head, tail, 1);\n    }\n\nDeclarator\n    = pointer:(Pointer _)? declarator:DirectDeclarator {\n        return pointer ? new AST.PointerDeclarator(getLocation(), declarator, extractOptional(pointer, 0)) : declarator;\n    }\n\nDirectDeclarator\n    = head:(identifier:Identifier {\n        return new AST.IdentifierDeclarator(getLocation(), identifier);\n    } / '(' _ declarator:Declarator _ ')' {\n        return declarator;\n    } ) tail:(_ (\n        '[' _ length:AssignmentExpression? _ &!']' {\n            return {\n                location: getLocation(),\n                type: AST.ArrayDeclarator,\n                arguments: [false, [], length, false]\n            };\n        }\n        / '(' _ parameters: ParameterList? _ ')' {\n            return {\n                location: getLocation(),\n                type: AST.FunctionDeclarator,\n                arguments: [parameters || new AST.ParameterList(getLocation())]\n            }\n        }\n    ))* {\n        return extractList(tail, 1).reduce((result, element) => new element.type(element.location, result, ...element.arguments), head);\n    }\n\nPointer\n    = '*' _ qualifiers:TypeQualifierList? _ pointer:Pointer? {\n        return new AST.Pointer(getLocation(), qualifiers || [], pointer, '*');\n    }\n    /\n    '&' _ qualifiers:TypeQualifierList? _ pointer:Pointer? {\n        return new AST.Pointer(getLocation(), qualifiers || [], pointer, '&');\n    }\n    /\n    '&&' _ qualifiers:TypeQualifierList? _ pointer:Pointer? {\n        return new AST.Pointer(getLocation(), qualifiers || [], pointer, '&&');\n    }\n\nDeclarationWithoutSemicolon\n    = specifiers:DeclarationSpecifiers _ initDeclarators:InitDeclaratorList?\n\nDeclarationMissingSemicolon\n    = decl:DeclarationWithoutSemicolon {\n        error('Missing \\\\';\\\\' at end of declaration');\n    }\n\nFunctionSpecifier = ('inline' / '__libcall')\n\nInitDeclaratorList\n    = head:InitDeclarator tail:(_ ',' _ InitDeclarator)* {\n        return buildList(head, tail, 3);\n    }\n\nInitDeclarator\n    = declarator:Declarator initializer:CppInitializer? {\n        return new AST.InitDeclarator(getLocation(), declarator, initializer || null);\n    }\n    \nCppInitializer\n    = _'=' _ init:Initializer{\n        return init;\n    }\n    / _ '(' _ arguments_:ArgumentExpressionList? _ ')' {\n        return new AST.ObjectInitializer(getLocation(),  arguments_ || []);  \n    }\n\n\nParameterList\n    = head:ParameterDeclaration tail:(_ ',' _ ParameterDeclaration)* ellipsis:(_ ',' _ '...')? {\n        return new AST.ParameterList(getLocation(), buildList(head, tail, 3), !!ellipsis);\n    }\n\nParameterDeclaration\n    = specifiers:DeclarationSpecifiers _ declarator:(Declarator / AbstractDeclarator)? init:( _ '=' _ AssignmentExpression)?{\n        return new AST.ParameterDeclaration(getLocation(), specifiers, declarator, init ? init[3] : null);\n    }\n\nIdentifierList\n    = head:Identifier tail:(_ ',' _ Identifier)* {\n        return buildList(head, tail, 3);\n    }\n\n\nInitializer\n    = AssignmentExpression\n    / '{' _ initializerList:InitializerList _ ','? _ &!'}' {\n        return initializerList;\n    }\n\nInitializerList\n    = head:InitializerListItem tail:(_ ',' _ InitializerListItem)* {\n        return new AST.InitializerList(getLocation(), buildList(head, tail, 3));\n    }\n\nInitializerListItem\n    = designators:(Designation _)? initializer:Initializer {\n        return new AST.InitializerListItem(getLocation(), initializer);\n    }\n\nDesignation\n    = designators:DesignatorList _ '=' {\n        return designators;\n    }\n\nDesignatorList\n    = head:Designator tail:(_ Designator)* {\n        return buildList(head, tail, 1);\n    }\n\nDesignator\n    = '[' _ subscript:ConstantExpression _ &!']' {\n        return new AST.SubscriptDesignator(getLocation(), subscript);\n    }\n    / '.' _ member:Identifier {\n        return new AST.MemberDesignator(getLocation(), member);\n    }\n\nFunctionDefinition\n    = specifiers:DeclarationSpecifiers _ declarator:Declarator _ body:CompoundStatement {\n        return new AST.FunctionDefinition(getLocation(), specifiers, declarator, body);\n    }\n\nNewTypeName\n    =  specifierQualifiers:DeclarationSpecifiers _ declarator:NewDeclarator? {\n        return new AST.TypeName(getLocation(), specifierQualifiers, declarator)\n    }\n\nTypeName\n    = specifierQualifiers:DeclarationSpecifiers _ declarator:AbstractDeclarator? {\n        return new AST.TypeName(getLocation(), specifierQualifiers, declarator)\n    }\n\nNewDeclarator\n    = pointer:Pointer declarator:(_ DirectNewDeclarator)? {\n        return new AST.PointerDeclarator(getLocation(), null, pointer, extractOptional(declarator, 1));\n    }\n    / declarator:DirectNewDeclarator {\n        return declarator;\n    }\n\nAbstractDeclarator\n    = pointer:Pointer declarator:(_ DirectAbstractDeclarator)? {\n        return new AST.PointerDeclarator(getLocation(), null, pointer, extractOptional(declarator, 1));\n    }\n    / declarator:DirectAbstractDeclarator {\n        return declarator;\n    }\n\nDirectNewDeclarator\n    = head:(element:DirectNewDeclaratorElement {\n            return new element.type(getLocation(), null, ...element.arguments)\n        }\n    ) tail:(_ DirectNewDeclaratorElement)* {\n        return extractList(tail, 1).reduce((result, element) => new element.type(element.location, result, ...element.arguments), head);\n    }\n\nDirectAbstractDeclarator\n    = head:(\n        '(' _ declarator:AbstractDeclarator _ ')' {\n            return declarator;\n        }\n        / element:DirectAbstractDeclaratorElement {\n            return new element.type(getLocation(), null, ...element.arguments)\n        }\n    ) tail:(_ DirectAbstractDeclaratorElement)* {\n        return extractList(tail, 1).reduce((result, element) => new element.type(element.location, result, ...element.arguments), head);\n    }\n\nDirectNewDeclaratorElement\n    = '[' _ length:AssignmentExpression? _ &!']' {\n        return {\n            location: getLocation(),\n            type: AST.ArrayDeclarator,\n            arguments: [false, [], length, false]\n        };\n    }\n\nDirectAbstractDeclaratorElement\n    = '(' _ parameters:ParameterList? _ ')' {\n        return {\n            location: getLocation(),\n            type: AST.FunctionDeclarator,\n            arguments: [parameters || new AST.ParameterList(getLocation())]\n        }\n    }\n    / DirectNewDeclaratorElement\nTryBlock\n    = 'try' _ body:CompoundStatement _ handlers:HandlerSeq {\n        return new AST.TryBlock(getLocation(), body, handlers);\n    }\n\nHandlerSeq\n    = head:ExceptionHandler tail:(_ ExceptionHandler)* {\n        return buildList(head, tail, 1);\n    }\n\nExceptionHandler\n    = 'catch' _ '(' _ decl:ExceptionDeclaration _ ')' _ body:CompoundStatement {\n        return new AST.ExceptionHandler(getLocation(), decl, body);\n    }\n\nExceptionDeclaration\n \t= specifiers:DeclarationSpecifiers _ declarator:Declarator {\n \t    return new AST.ExceptionDeclaration(getLocation(), specifiers, declarator);\n \t}\n \t/ specifiers:DeclarationSpecifiers _ declarator:AbstractDeclarator {\n \t    return new AST.ExceptionDeclaration(getLocation(), specifiers, declarator);\n \t}\n\nThrowExpression\n \t= 'throw' _ body:AssignmentExpression? {\n \t    return new AST.ThrowExpression(getLocation(), body);\n \t}\nExpression\n    = head:AssignmentExpression tail:(_ ',' _ AssignmentExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nAssignmentExpression\n    = left:UnaryExpression _ operator:AssignmentOperator _ right:AssignmentExpression {\n        return new AST.AssignmentExpression(getLocation(), operator, left, right);\n    }\n    / ConditionalExpression\n\nConditionalExpression\n    = test:LogicalOrExpression _ '?' _ consequent:Expression _ &!':' _ alternate:ConditionalExpression {\n        return new AST.ConditionalExpression(getLocation(), test, consequent, alternate);\n    }\n    / LogicalOrExpression\n\n\nConstructorCallExpression\n    = name:TypeIdentifier  _ '(' _ arguments_:ArgumentExpressionList? _ &!')' {\n        return new AST.ConstructorCallExpression(getLocation(), name, arguments_ || []);\n    }\n\nPostfixExpression\n    = head:( PrimaryExpression / ConstructorCallExpression ) tail:(_ (\n        '[' _ subscript:Expression _ &!']' {\n            return {\n                type: AST.SubscriptExpression,\n                arguments: [subscript]\n            };\n        }\n        / '(' _ arguments_:ArgumentExpressionList? _ ')' {\n            return {\n                type: AST.CallExpression,\n                arguments: [arguments_ || []]\n            };\n        }\n        / operator:('.' / '->') _ member:Identifier {\n            return {\n                type: AST.MemberExpression,\n                arguments: [operator === '->', member]\n            };\n        }\n        / operator:('++' / '--') {\n            return {\n                type: AST.PostfixExpression,\n                arguments: [operator === '--']\n            };\n        }\n    ))* {\n        return extractList(tail, 1).reduce((result, element) => new element.type(getLocation(), result, ...element.arguments), head);\n    }\n\nArgumentExpressionList\n    = head:AssignmentExpression tail:(_ ',' _ AssignmentExpression)* {\n        return buildList(head, tail, 3);\n    }\n\nUnaryExpression\n    = operator:('++' / '--') _ operand:UnaryExpression {\n        return new AST.UnaryExpression(getLocation(), operator, operand);\n    }\n    / operator:UnaryOperator _ operand:CastExpression { //Hack: when parse '&' operator, the operator variable will be array of 2 elements\n        return new AST.UnaryExpression(getLocation(), operator[0], operand);\n    }\n    / operator:'sizeof' !IdentifierPart _ operand:UnaryExpression {\n        return new AST.UnaryExpression(getLocation(), operator, operand);\n    }\n    / operator:'sizeof' _ '(' _ operand:TypeName _ ')' {\n        return new AST.UnaryExpression(getLocation(), operator, operand);\n    }\n    / PostfixExpression\n    / NewExpression\n    / DeleteExpression\n\nCastExpression\n    = '(' _ typeName:TypeName _ ')' _ operand:CastExpression {\n        return new AST.CastExpression(getLocation(), typeName, operand);\n    }\n    / UnaryExpression\n\nMultiplicativeExpression\n    = head:CastExpression tail:(_ [*/%] _ CastExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nAdditiveExpression\n    = head:MultiplicativeExpression tail:(_ [+\\\\-] _ MultiplicativeExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nShiftExpression\n    = head:AdditiveExpression tail:(_ ('<<' / '>>') _ AdditiveExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nRelationalExpression\n    = head:ShiftExpression tail:(_ ('<=' / '>=' / '<' / '>') _ ShiftExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nEqualityExpression\n    = head:RelationalExpression tail:(_ ('==' / '!=') _ RelationalExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nAndExpression\n    = head:EqualityExpression tail:(_ SingleAnd _ EqualityExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nExclusiveOrExpression\n    = head:AndExpression tail:(_ '^' _ AndExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nInclusiveOrExpression\n    = head:ExclusiveOrExpression tail:(_ '|' _ ExclusiveOrExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nLogicalAndExpression\n    = head:InclusiveOrExpression tail:(_ AndAnd _ InclusiveOrExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nLogicalOrExpression\n    = head:LogicalAndExpression tail:(_ '||' _ LogicalAndExpression)* {\n        return buildBinaryExpression(head, tail);\n    }\n\nConstantExpression\n    = ConditionalExpression\n\nPrimaryExpression\n    = Identifier\n    / Constant\n    / StringLiteral\n    / '(' _ expression:Expression _ &!')' {\n        return expression;\n    }\n\n\n\nNewPlacement\n    = '(' _  item:AssignmentExpression _ ')' {\n        return item;\n    }\n\nNewInitializer\n    = '(' _ arguments_:ArgumentExpressionList? _ ')' {\n        return arguments_;\n    }\n\nNewExpression\n    = '::'? 'new' !IdentifierPart _ placement:NewPlacement? _ type:NewTypeName _ initializer:NewInitializer?{\n        return new AST.NewExpression(getLocation(), type, initializer || [], placement || null);\n    }\n    / '::'? 'new' !IdentifierPart _ placement:NewPlacement? _ '(' _ name:TypeName _ ')' _ initializer:NewInitializer?{\n        return new AST.NewExpression(getLocation(), type, initializer || [], placement || null);\n    }\n\nDeleteExpression\n    = 'delete' _ expr:AssignmentExpression {\n        return new AST.DeleteExpression(getLocation(), expr, false);\n    }\n    / 'delete[]' _ expr:AssignmentExpression {\n        return new AST.DeleteExpression(getLocation(), expr, true);\n    }\nId\n    = !Keyword head:IdentifierNondigit tail:IdentifierPart* {\n        return new AST.SingleIdentifier(getLocation(), head + tail.join(''), AST.IDType.ID, []);\n    }\n\nSingleIdentifier\n    = id:Id &{\n        return getTypeOfName(id.name) === ID_NAME;\n    } {\n        return id;\n    }\n    / 'operator' _ ope:OverloadOperator {\n        return new AST.SingleIdentifier(getLocation(), \"#\" + ope, AST.IDType.ID, []);\n    }\n    / '~' name:TypeIdentifier {\n        const result = name.clone();\n        result.getLastID().name = '~' + result.identifier.name;\n        result.getLastID().type = AST.IDType.TYPE;\n        return result;\n    }\n\nSingleTypeIdentifier\n    =  id:Id &{\n        return getTypeOfName(id.name) === TYPE_NAME;\n    } {\n        id.type = AST.IDType.TYPE;\n        return id;\n    }\n\nSingleTemplateFuncIdentifier\n    =  id:Id &{\n        return getTypeOfName(id.name) === TEMPLATE_FUNC_NAME;\n    } {\n        id.type = AST.IDType.T_FUNC;\n        return id;\n    }\n\nSingleTemplateClassIdentifier\n    =  id:Id &{\n        return getTypeOfName(id.name) === TEMPLATE_CLASS_NAME;\n    } {\n        id.type = AST.IDType.T_CLASS;\n        return id;\n    }\n\nUnifiedIdentifier\n    = SingleTypeIdentifier/ TemplateClassInstanceIdentifier\n\nIdentifier\n    = isFullName:'::'? namespace:(UnifiedIdentifier '::')* name:(SingleIdentifier/TemplateFuncInstanceIdentifier) {\n        return new AST.Identifier(getLocation(), namespace.map(x=>x[0]).concat([name]), isFullName);\n    }\n\nTypeIdentifier\n    = isFullName:'::'? namespace:(UnifiedIdentifier '::')* name:UnifiedIdentifier {\n        return new AST.Identifier(getLocation(), namespace.map(x=>x[0]).concat([name]), isFullName);\n    }\n\nTemplateFuncIdentifier\n    = isFullName:'::'? namespace:(UnifiedIdentifier '::')* name:SingleTemplateFuncIdentifier {\n        return new AST.Identifier(getLocation(), namespace.map(x=>x[0]).concat([name]), isFullName);\n    }\n\nTemplateClassIdentifier\n    = isFullName:'::'? namespace:(SingleTypeIdentifier '::')* name:SingleTemplateClassIdentifier {\n        return new AST.Identifier(getLocation(), namespace.map(x=>x[0]).concat([name]), isFullName);\n    }\n\nTypeDeclarationIdentifier\n    = identifier:Identifier{\n        if( options.isCpp ) {\n            globalMap.set(identifier.getLastID().name, TYPE_NAME);\n            currScope.names.set(identifier.getLastID().name, TYPE_NAME);\n        }\n        return identifier;\n    }\n\nWhiteSpace = [ \\\\t\\\\n\\\\v\\\\f]\n\n_ = WhiteSpace*\n\nKeyword\n    = ('auto'\n    / 'break'\n    / 'case'\n    / 'char'\n    / 'const'\n    / 'continue'\n    / 'default'\n    / 'double'\n    / 'do'\n    / 'else'\n    / 'enum'\n    / 'extern'\n    / 'float'\n    / 'for'\n    / 'goto'\n    / 'if'\n    / 'inline'\n    / 'int'\n    / 'long'\n    / 'register'\n    / 'restrict'\n    / 'return'\n    / 'short'\n    / 'signed'\n    / 'sizeof'\n    / 'static'\n    / 'struct'\n    / 'switch'\n    / 'typedef'\n    / 'union'\n    / 'unsigned'\n    / 'void'\n    / 'volatile'\n    / 'while'\n    / 'class'\n    / 'new'\n    / 'delete'\n    / 'operator'\n    / 'override'\n    / 'template'\n    / 'typename'\n    / 'namespace'\n    / 'using') !IdentifierPart\n\nStorageClassSpecifier\n    = ('typedef'\n    / 'extern'\n    / 'static'\n    / 'virtual'\n    / 'auto'\n    / 'register') !IdentifierPart {\n        return text();\n    }\n\nPrimitiveTypeSpecifier\n    = ('void'\n    / 'char'\n    / 'short'\n    / 'int'\n    / 'long'\n    / 'float'\n    / 'double'\n    / 'signed'\n    / 'unsigned'\n    / 'bool') !IdentifierPart {\n        return text();\n     }\n\nOverloadOperator\n    = '+' / '-' / '*' / '/' / '%' / '&' / '<' / '>' / '<=' / '>=' / '==' / '!='\n    / '|' / '^' / '!' / '~' / '&&' / '||' / '>>' / '<<' / '++' / '--'\n    /'()' / '[]' / '->'\n    / AssignmentOperator\n\nAssignmentOperator\n    = '=' !'=' {\n        return text();\n    }\n    / '*='\n    / '/='\n    / '%='\n    / '+='\n    / '-='\n    / '<<='\n    / '>>='\n    / '&='\n    / '^='\n    / '|='\n\nAndAnd\n    = '&&'\n\nSingleAnd\n    = '&'!'&'\n\nHexadecimalPrefix\n    = '0x'\n    / '0X'\n\nNonzeroDigit\n    = [1-9]\n\nOctalDigit\n    = [0-7]\n\nHexadecimalDigit\n    = [0-9a-fA-F]\n\nIntegerSuffix\n    = UnsignedSuffix (LongLongSuffix / LongSuffix)?\n    / (LongLongSuffix / LongSuffix) UnsignedSuffix?\n\nUnsignedSuffix\n    = [uU]\n\nLongSuffix\n    = [lL]\n\nLongLongSuffix\n    = 'll'\n    / 'LL'\n\nIdentifierPart\n    = IdentifierNondigit\n    / Digit\n\nIdentifierNondigit\n    = UniversalCharacterName\n    / Nondigit\n\nNondigit\n    = [_a-zA-Z]\n\nDigit\n    = [0-9]\n\nStatement\n    = CaseStatement\n    / SelectionStatement\n    / IterationStatement\n    / JumpStatement\n    / CompoundStatement\n    / LabeledStatement\n    / ExpressionStatement\n    / UsingStatements\n\n// ADDED\nCaseStatement\n    = 'case' !IdentifierPart _ test:ConstantExpression _ &!':' _ body:Statement {\n        return new AST.CaseStatement(getLocation(), test, body);\n    }\n    / 'default' !IdentifierPart _ &!':' _ body:Statement {\n        return new AST.CaseStatement(getLocation(), null, body)\n    }\n\n// MODIFICATION: No case or default.\nLabeledStatement\n    = label:Identifier _ ':' _ body:Statement {\n        return new AST.LabeledStatement(getLocation(), label, body);\n    }\n\nScopeStart\n    = '{' {\n        enterScope();\n        return getLocation();\n    }\n\nScopeEnd\n    = &!'}' {\n        exitScope();\n        return getLocation();\n    }\n\nCompoundStatement\n    = left:ScopeStart _ body:BlockItemList? _ right:ScopeEnd {\n        return new AST.CompoundStatement(getLocation(), body || []);\n    }\n\nBlockItemList\n    = head:BlockItem tail:(_ BlockItem)* {\n        return buildList(head, tail, 1);\n    }\n\nBlockItem\n    = Statement\n    / Declaration\n    / Expression { // ExpressionStatementMissingSemicolon\n        error('Missing \\\\';\\\\' at end of statement');\n    }\n    / DeclarationMissingSemicolon\n\nExpressionStatement\n    = expression:(Expression _)? ';' {\n        return expression ? new AST.ExpressionStatement(getLocation(), extractOptional(expression, 0))\n                : new AST.NullStatement(getLocation());\n    }\n\nSelectionStatement\n    = 'if' !IdentifierPart _ &!'(' _ test:Expression _ &!')' _ consequent:Statement alternate:(_ 'else' !IdentifierPart _ Statement)? {\n        return new AST.IfStatement(getLocation(), test, consequent, extractOptional(alternate, 4));\n    }\n    / 'switch' !IdentifierPart _ &!'(' _ discriminant:Expression _ &!')' _ body:Statement {\n        return new AST.SwitchStatement(getLocation(), discriminant, body);\n    }\n\nIterationStatement\n    = 'while' !IdentifierPart _ &!'(' _ test:Expression _ &!')' _ body:Statement {\n        return new AST.WhileStatement(getLocation(), test, body);\n    }\n    / 'do' !IdentifierPart _ body:Statement _ 'while' !IdentifierPart _ &!'(' _ test:Expression _ &!')' _ &!';' {\n        return new AST.DoWhileStatement(getLocation(), body, test);\n    }\n    / 'for' !IdentifierPart _ &!'(' _ init:(Declaration / expression:Expression? _ ';' {\n        return expression;\n    } / (DeclarationWithoutSemicolon / Expression) {\n        error('Missing \\\\';\\\\'');\n    }) _ test:Expression? _ &!';' _ update:Expression? _ &!')' _ body:Statement {\n        return new AST.ForStatement(getLocation(), init, test, update, body);\n    }\n\nJumpStatement\n    = 'goto' !IdentifierPart _ label:Identifier _ &!';' {\n        return new AST.GotoStatement(getLocation(), label);\n    }\n    / 'continue' !IdentifierPart _ &!';' {\n        return new AST.ContinueStatement(getLocation());\n    }\n    / 'break' !IdentifierPart _ &!';' {\n        return new AST.BreakStatement(getLocation());\n    }\n    / 'return' !IdentifierPart _ argument:Expression? _ &!';' {\n        return new AST.ReturnStatement(getLocation(), argument);\n    }\n\n\nUsingStatements\n    = 'using' _ name:Identifier _ '=' _ decl:TypeName _ ';'{\n        currScope.names.set(name.getLastID().name, TYPE_NAME);\n        return new AST.UsingStatement(getLocation(), name, decl);\n    }\n    / 'using' _ name:(Identifier/TypeIdentifier/TemplateClassIdentifier/TemplateFuncIdentifier) _ ';'{\n        return new AST.UsingStatement(getLocation(), name);\n    }\n    / 'using' _ 'namespace' _ name:TypeIdentifier _ ';'{\n        return new AST.UsingNamespaceStatement(getLocation(), name);\n    }\nTemplateDeclaration\n    = 'template' _ '<' _ &{\n        enterScope();\n        return true;\n    } param:TemplateParameterList? _ &!'>' _ decl:(ClassSpecifierWithSemi/FunctionDefinition) {\n        exitScope();\n        const result = new AST.TemplateDeclaration(getLocation(), decl, param || []);\n        const names = result.getTemplateNames();\n        const typeId = (decl instanceof AST.FunctionDefinition) ? TEMPLATE_FUNC_NAME : TEMPLATE_CLASS_NAME;\n        names.map(name => {currScope.names.set(name, typeId);\n        if(typeId === TEMPLATE_CLASS_NAME) globalMap.set(name, typeId);});\n        return result;\n    }\n\nClassSpecifierWithSemi\n    = id:ClassSpecifier _ ';' {\n        return id;\n    }\n\nTemplateParameterList\n    = head:TemplateParameter tail:(_ ',' _ TemplateParameter)* {\n        return buildList(head, tail, 3);\n    }\n\nTemplateParameter\n    = TypeParameter\n    / ParameterDeclaration;\n\nTypeNameKeyword = 'class' / 'typename'\n\n// TODO:: identifier is optional?\nTypeParameter\n    = TypeNameKeyword _ id:TypeDeclarationIdentifier init:( _ '=' _ TypeName)? {\n        return new AST.TypeParameter(getLocation(), id, init ? init[3] : null);\n    }\n\nTemplateFuncInstanceIdentifier\n    = id:SingleTemplateFuncIdentifier opt:(_ '<' _ TemplateArgumentList? _ &!'>' _ )? {\n        id.type = AST.IDType.T_FUNC_INS;\n        id.args = opt ? (opt[3] || []) : [];\n        return id;\n    }\n\nTemplateClassInstanceIdentifier\n    = id:SingleTemplateClassIdentifier opt:(_ '<' _ TemplateArgumentList? _ &!'>' _ )? {\n        id.type = AST.IDType.T_CLASS_INS;\n        id.args = opt ? (opt[3] || []) : [];\n        return id;\n    }\n\nTemplateArgumentList\n    = head:TemplateArgument tail:(_ ',' _ TemplateArgument)* {\n        return buildList(head, tail, 3);\n    }\n\nTemplateArgument\n    = item:TypeName {\n        return new AST.TemplateArgument(getLocation(), item);\n    }\n    / item:AdditiveExpression {\n        return new AST.TemplateArgument(getLocation(), item);\n    }\n\nExplicitInstantiation\n    = FunctionTemplateInstantiation\n    / ClassTemplateInstantiation\n\nFunctionTemplateInstantiation\n    = 'template' _ specifiers:DeclarationSpecifiers _ declarator:Declarator _ ';'{\n        return new AST.FunctionTemplateInstantiation(getLocation(), specifiers, declarator);\n    }\n\nClassTemplateInstantiation\n    = 'template' _ spec:ClassSpecifier _ ';'{\n        return new AST.ClassTemplateInstantiation(getLocation(), spec);\n    }`        \n"},"lineCount":null}},"error":null,"hash":"61ccad7aab78234335eceddcfae5552c","cacheData":{"env":{}}}