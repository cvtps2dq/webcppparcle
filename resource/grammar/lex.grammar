Id
    = !Keyword head:IdentifierNondigit tail:IdentifierPart* {
        return new AST.Identifier(getLocation(), head + tail.join(''));
    }

SingleIdentifier
    = id:Id &{
        return getTypeOfName(id.name) === ID_NAME;
    } {
        return id;
    }

SingleTypeIdentifier
    =  id:Id &{ //precondition
        return getTypeOfName(id.name) === TYPE_NAME;
    } {
        return id;
    }

SingleTemplateIdentifier
    =  id:Id &{ //precondition
        return getTypeOfName(id.name) === TEMPLATE_NAME;
    } {
        return id;
    }

Identifier
    = 'operator' ope:OverloadOperator {
        return new AST.Identifier(getLocation(), "#" + ope);
    }
    / isFullName:'::'? namespace:(Id '::')* name:SingleIdentifier {
        let prefix = isFullName === "::" ? "::" : "";
        name.name = prefix + namespace.map(x=>x[0].name+"::").join("") + name.name;
        return name;
    }
    / '~' name:TypeIdentifier {
        name.identifier.name = '~' + name.identifier.name;
        return name.identifier;
    }

TypeIdentifier
    = isFullName:'::'? namespace:(Id '::')* name:SingleTypeIdentifier {
        const prefix = isFullName === "::" ? "::" : "";
        const id = prefix + namespace.map(x=>x[0].name+"::").join("") + name.name;
        return new AST.TypeIdentifier(getLocation(), id);
    }

TemplateIdentifier
    = isFullName:'::'? namespace:(Id '::')* name:SingleTemplateIdentifier {
        const prefix = isFullName === "::" ? "::" : "";
        const id = prefix + namespace.map(x=>x[0].name+"::").join("") + name.name;
        return new AST.TemplateIdentifier(getLocation(), id);
    }

TypeDeclarationIdentifier
    = identifier:Identifier{
        if( options.isCpp ) { currScope.names.set(identifier.name, TYPE_NAME); }
        return identifier;
    }

TemplateDeclarationIdentifier
    = identifier:Identifier{
        if( options.isCpp ) { currScope.names.set(identifier.name, TEMPLATE_NAME); }
        return identifier;
    }

WhiteSpace = [ \\t\\n\\v\\f]

_ = WhiteSpace*

Keyword
    = ('auto'
    / 'break'
    / 'case'
    / 'char'
    / 'const'
    / 'continue'
    / 'default'
    / 'double'
    / 'do'
    / 'else'
    / 'enum'
    / 'extern'
    / 'float'
    / 'for'
    / 'goto'
    / 'if'
    / 'inline'
    / 'int'
    / 'long'
    / 'register'
    / 'restrict'
    / 'return'
    / 'short'
    / 'signed'
    / 'sizeof'
    / 'static'
    / 'struct'
    / 'switch'
    / 'typedef'
    / 'union'
    / 'unsigned'
    / 'void'
    / 'volatile'
    / 'while'
    / 'class'
    / 'new'
    / 'delete'
    / 'operator'
    / 'override'
    / 'template'
    / 'typename'
    / 'namespace'
    / 'using') !IdentifierPart

StorageClassSpecifier
    = ('typedef'
    / 'extern'
    / 'static'
    / 'virtual'
    / 'auto'
    / 'register') !IdentifierPart {
        return text();
    }

PrimitiveTypeSpecifier
    = ('void'
    / 'char'
    / 'short'
    / 'int'
    / 'long'
    / 'float'
    / 'double'
    / 'signed'
    / 'unsigned'
    / 'bool') !IdentifierPart {
        return text();
     }

OverloadOperator
    = '+' / '-' / '*' / '/' / '%' / '&' / '<' / '>' / '<=' / '>=' / '==' / '!='
    / '|' / '^' / '!' / '~' / '&&' / '||' / '>>' / '<<' / '++' / '--'
    /'()' / '[]' / '->'
    / AssignmentOperator

AssignmentOperator
    = '=' !'=' {
        return text();
    }
    / '*='
    / '/='
    / '%='
    / '+='
    / '-='
    / '<<='
    / '>>='
    / '&='
    / '^='
    / '|='

AndAnd
    = '&&'

SingleAnd
    = '&'!'&'

HexadecimalPrefix
    = '0x'
    / '0X'

NonzeroDigit
    = [1-9]

OctalDigit
    = [0-7]

HexadecimalDigit
    = [0-9a-fA-F]

IntegerSuffix
    = UnsignedSuffix (LongLongSuffix / LongSuffix)?
    / (LongLongSuffix / LongSuffix) UnsignedSuffix?

UnsignedSuffix
    = [uU]

LongSuffix
    = [lL]

LongLongSuffix
    = 'll'
    / 'LL'

IdentifierPart
    = IdentifierNondigit
    / Digit

IdentifierNondigit
    = UniversalCharacterName
    / Nondigit

Nondigit
    = [_a-zA-Z]

Digit
    = [0-9]
